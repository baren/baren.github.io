---
comments: true
date: 2014-03-03 23:06:00
layout: post
title: apue(标准I/O库)
summary: 'apue chapter5'
tags:
- linux
- 笔记
---
[dir-detail]: /assets/dir.png "file system dir detail"
[file-detail]: /assets/file.png "file system file detail"

# 流和FILE对象

## 流介绍

对于标准I/O库，他们的操作是围绕*流*进行的。

与JAVA使用Stream类来代表流不一样，标准I/O采用结构体FILE来代表流，由于大多数标准库的函数使用FILE *来作为参数，因此也用*文件指针*来代称流。

struct FILE结构体在stdio.h中做了声明：

```
typedef struct _sFILE{...} FILE;

```
数据类型FILE
	> 代表流对象，FILE对象含有所有的连接文件的内部状态，包括文件位置标记和缓存信息等。
	> 每一个流海包含error和文件末尾状态标记，可以通过ferror和feof函数进行测试。

## 流的定向

标准I/O可以用于单字节的字符集（ascii字符集）和多字节（宽）字符集，这就要求*流的定向*。
对于宽字节的处理，有一套专门的多字节处理函数（wchar.h中声明）。
对于同样的流，为了能处理宽的和正常的字符的操作，有一个限制：

* 流要么被标记为宽定向的，要么是字节定向的
* 一旦确定定向后，不能二者混用

有三种方式来定向流：

* 创建流后，任一个正常字符函数被使用，流被标记为字节定向的。
* 创建流后，任一个宽字符函数被使用，流被标记为宽定向的。
* 使用```fwide函数```来设置流的定向。
* freopen函数可以清除流的定向。

注意：

* 流刚被创建时，并没有定向
* 在未定向流上使用字节字符函数则置为字节定向的
* 在未定向流上使用宽字节函数则置为宽字节定向的

fwide函数说明：

```
#include <stdio.h>
#include <wchar.h>

# 返回值：若流是宽定向的，则返回正值；若流是字节定向的，则返回负值；若流是未定向的，则返回0.
int fwide(FILE *fp, int mode);
```

根据mode参数的值，fwide执行不同的工作：

* 若mode参数为负值，fwide试图使指定的流是字节定向的
* 若mode参数为正值，fwide试图使指定的流是宽定向的
* 若mode参数为0，fwide将不试图设置流的定向，但返回标识该流定向的值

> 注意:
> fwide不会改变已经设置定向的流
> fwide不会出错，想检查错误，唯一可用的是调用之前先清除errno，调用fwide后检查errno的值。（errno是全局变量，每次调用失败，系统会用错误代码赋值给errno）

# 标准输入/输出/错误

当main函数被调用，就已经有3哥预先定义的打开的流可以使用，这三个流在stdio.h中声明：

* FILE *stdin。标准输入流
* FILE *stdout。标准输出流
* FILE *stderr。标准错误流

在GNU C中，stdin、stdout和stderr是正常常量，可以直接用：

```
fclost(stdout);
stdout = fopen("filepath", "w");

```

# 缓冲

标准I/O提供了三种类型的缓冲：

* 全缓冲。填满缓冲区后才进行实际的I/O操作。对于磁盘文件，通常是全缓冲的。在一个流上第一次执行I/O操作时，标准I/O函数通常用malloc获取需要使用的缓冲区。
* 行缓冲。当输入和输出中遇到换行符时，标准I/O库执行I/O操作。当涉及到终端时，通常使用行缓冲。

> 行缓冲有两个限制：

> 缓冲区长度是固定的，所以只要填满了缓冲区，即使没有缓冲区，也进行I/O操作

> 任何时候，只要标准I/O库从 a）不带缓冲的流，或者 b）一个行缓冲的流（但数据从内核获取）得到输入数据，那么就会造成冲洗所有行缓冲输出流。

> 从实现角度说，这么个限制是有原因的：如果从不带缓冲的流中获取数据，那么缓冲区中的没有冲洗的旧数据会对新数据造成污染。

* 不带缓冲。标准I/O库不对字符进行缓冲存储。标准错误流通常不带缓冲的。

iso c 是这样设置缓冲的：
* 当且仅当标准输入和标准输出并不涉及交互设备时，他们才是全缓冲。
* 标准错误绝不会是全缓冲。

但是标准输入输出涉及交互设备时，一般：

* 标准错误不带缓冲。
* 其它流，涉及终端设备，则是行缓冲；否则是全缓冲。

对于这些默认的缓冲情况，可以使用函数进行修改：

```
#include <stdio.h>

void setbuf(FILE * fp, char * buf);
int servbuf(FILE * fp, char * buf, int mode, size_t size);

```

这些函数的使用限制是：

* 一定要在流已被打开后调用
* 在对流执行任何一个其它操作之前调用

setbuf可以打开和关闭缓冲，打开缓冲，将buf指向一个长为BUFSIZE的缓冲区（该常量被定义在stdio.h中）。关闭缓冲，则设置buf为NULL。
setvbuf，可以精确控制缓冲类型，通过mode参数指定：

* _IOFBF	全缓冲	
* _IOLBF	行缓冲
* _IONBF	不缓冲

> 注意：
> 如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流（也就是把数据冲洗一下）。
> 一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。这种情况下，关闭此流时，标准I/O库将自动释放缓冲区。

可以通过函数强制缓冲一个流：

```
#include <stdih.h>

int fflush(FILE * fp);
```

# 打开流

使用下列函数打开流：

```
#include <stdio.h>

FILE *fopen(char * pathname, char *type);
FILE *freopen(char *pachname, char *type, FILE *fp);
FILE *fdopen(int fd, char *type);

```

使用fopen函数打开一个文件，创建一个新流，并建立这个流和文件之间的连接。这个过程也会涉及到创建新文件。

其中，type参数指定对该流的读、写方式：

* ```'r'```: 只读打开文件
* ```'w'```: 只写打开，若文件存在，截断为0；否则创建新文件
* ```'a'```: 追加打开，为在文件为写而打开。文件若存在，则不改变内容。
* ```'r+'```: 读写打开文件，初始化内容不变，初始化文件位置在文件开头。
* ```'w+'```: 读写打开文件，若文件存在，截断为0.否则创建新文件
* ```'a+'```: 为在文件尾读和写而打开文件。

> 注意：

> '+'请求一个流可以读和写，当使用这种流时，在读写之间转换时，必须刷新buffer，fflush或者订货函数fseek都可以。不然内部的buffer可能不空。

freopen函数像fclos和fopen的联合。受限关闭有fp指向的流（这个过程会忽略任何错误），然后再打开pathname指向的文件，一般用于将一个指定的文件打开为一个预定义的流。

可以使用fclose关闭流：

```
#include <stdio.h>

int fclose(FILE *fp);
```

关闭一个流，关闭文件，并刷新缓冲区的输出数据，并释放由标准I/O库分配的内存。

> 注意：
> 当程序正常关闭时（调用exit函数和正常从main返回），所有未写缓冲数据的标准I/O流，都会被冲洗；所有打开的标准I/O都会关闭。

# 读和写流










