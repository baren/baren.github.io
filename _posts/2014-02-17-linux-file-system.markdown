---
comments: true
date: 2014-02-10 19:33:00
layout: post
title: linxu 文件系统笔记
summary: 'linux file sys'
tags:
- linux
- 笔记
---
[14-1]: /assets/Figure14-1.png "layout of disk partitions and a file system"
[14-2]: /assets/Figure14-2.png "Structure of file blocks for a file in an ext2 file system"
[14-3]: /assets/Figure14-3.png "he virtual file system"


# 设备特殊文件

设备可以划分成两种类型：

* 字符设备。一个字符一个字符的处理数据，终端和键盘就是例子。
* 块设备。一次处理一块数据。块大小依赖于设备类型。一般都是512字节的倍数。磁盘就是这种设备。

## 设备ID
每一个设备文件都有一个主ID号和副ID号。主ID号标记设备的一般类型，内核使用这个主ID来寻找这种类型设备对应的驱动。副ID号唯一的标记这个设备类型下得特殊设备了。ls -l可以显示主ID和副ID

# 磁盘和分区

* 一个磁盘可以分成多个分区。
* 信息都放在磁盘的磁道上，磁道被划分成扇区，每一个扇区都由一系列的物理块组成。物理块的大小一般时512或者其倍数个字节，代表了最小的信息单元。

## 分区

一个分区可以包含以下信息：

* 文件系统，也即每个分区可以包含一个文件系统
* 数据区域
* swap区域

# 文件系统

linux支持广泛的文件系统，包括
* 传统的ext2文件系统
* 原生的unix文件系统，包括 Minix, System V和 BSD文件系统
* 微软的FAT, FAT32, 和 NTFS
* apple的HFS
* 网络文件系统，包括sun的NFS等
* 一系列日志文件系统，包括xt3, ext4, Reiserfs, JFS, XFS, 和 Btrfs


以ext2文件系统为例，介绍文件系统，ext2文件系统源代码很小，大约5000行c程序（http://e2fsprogs.sourceforge.net/ext2.html.）

## 文件系统结构

磁盘分成多个逻辑分区，每一个分区可拥有一个文件系统，比如：
![alt text][14-1]

* boot块，总是文件系统的第一个块，文件系统不会使用这个块，boot块是用来重启操作系统的。虽然每个分区的文件系统都有一个boot块，但只有一个会被使用。
* superblock，紧随boot块后的一个单一块，包含如下信息
>* i-nod表的大小
>* 此文件系统的逻辑块大小
>* 文件系统的大小

* inode表。文件系统的每一个文件或者目录都在inode表中对应一个唯一的表项。这个表项记录了文件的各种信息。
* 数据块，磁盘的最主要的文件数据存储区域。

## i-node

对于所有的文件系统内的文件，文件系统的i-node表都有一个唯一的i-node表项与之对应。i-node使用i-node在表中的顺序号来引用（数组实现？）。
*i-node number*是ls -li命令的第一个字段.

i-node包含的信息有：

* 文件类型，比如目录、普通文件、符号链接等
* 拥有者
* 所属组
* 访问权限
* 三个文件相关时间（最后读时间、最后修改内容时间和最后修改i-node时间）
* 指向这个文件的硬链接数
* 文件大小
* 分配的块数
* 指向数据块的指针

## ext2的i-node的数据块指针

为了满足一下需求：

* i-node结构是固定大小的，同时又文件大小是任意的（因此，i-node的数据指针是任意的）
* 允许文件的数据库不是连续存储的，同时又允许文件数据任意的通过lseek()访问

基于以上几点，ext2设计了i-node的指针结构:

![alt text][14-2]


每一个i-node包含十五个pointer。前12个指针指向文件数据块的前十二个块。下一个指针指向一个指针块，指针块中指针的个数依赖块的大小。
每个指针需要4个字节，如果块大小是1024字节，则存放256个指针，如果是4096字节，则存放1024个指针。
为了能容纳更大数据，第13个指针，是一个双重间接指针（double indirect pointer），它指向一个指针块，块中的指针又指向一个指针块。
如果需要真正大的文件，还可以使用最后一个triple-indirect pointer。

这样设计的一个好处是，允许文件存在黑洞。对于具有hole的文件，他可以仅仅把指针赋值为0，而不需要为其分配数据位null的块。

# 虚拟文件系统（vfs）

linux支持各种文件系统，文件系统实现各不一样，但是对文件的操作，不会涉及到具体的文件系统实现，而是可以跨文件系统的。这是因为linux定义了一个抽象层，各种文件系统需要实现的。一般称为Virtual File System（vfs）。

vfs是linux的内核特征，定义一个抽象的文件操作层，也就是一系列操作文件的接口。一般包括：open(), read(), write(), lseek(), close(), truncate(), stat(), mount(), umount(), mmap(), mkdir(), link(), unlink(), symlink(), and rename().

如图所示：

![alt text][14-3]

# 日志文件系统（ournaling File Systems）

ext2文件系统是典型的传统unix文件系统的例子，也遭受经典的这种文件系统的限制：当down机后，在重启后需要进行一致性检查，来确保文件系统的完整性。这是因为，当系统崩溃时，文件系统的更新有可能只完成了部分操作。文件系统的元数据，包括目录下，i-node信息和数据库指针，可能会处于不一致状态。
如果不进行修复，文件系统会进一步被破坏。

但是一致性检查需要扫描所有文件，如果文件系统很大，花费时间也会大。

日志文件系统消除了当系统挂了后的漫长的一致性检查。日志文件系统在进行实际的操作时，先把更新的元数据记录到一个日志文件的磁盘文件中。
写入元数据到日志文件是事务性写入相关的数据。一旦系统崩溃，在重启后，只需要快速的重做未完成的更新，是系统进入一个一致性状态。

这有个缺点是延长了更新文件的时间。

linux的日志文件系统包括：

* Reiserfs是第一个整合到linux内核的日志文件系统（2.4.1）。
* ext3是在ext2上增加了日志功能的系统。
* JFS系统是IBM开发的，在2.4.20上整合到内核
* ext4，在2.6.19加入到内核
* Btrfs，通常发音是butter FS。提供了一些现代的系统功能。




























