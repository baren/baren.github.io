---
comments: true
date: 2014-06-24 20:00:00
layout: post
title: apue(信号)
summary: 'apue chapter10'
tags:
- linux
- 笔记
---


# 信号概念

信号是软中断，提供了一种处理异步事件的方法

关于信号：

* 每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中
* 产生信号的条件
> * 用户按终端键，印发终端产生信号
> * 硬件异常产生信号，比如无效的内存引用，除数为0等
> * 进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）
> * 用户用kill命令给进程发送信号
> * 当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。

几种处理信号的方式

* 忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的
* 捕捉信号——需要注册一个信号处理函数
* 执行默认操作——大多数的信号的默认动作是终止信号

# signal函数

unix系统提供了两个改变信号处理的方式：signal和signalaction函数

现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。

```
void (*signal(int sig, void (*func)(int)))(int)
// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址
```

signal函数太复杂，可以使用typedef类型定义简化一下：

```
typedef void Sigfunc(int);

Sigfunc *signal(int Sigfunc *func);

```

一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：

```
#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针

```

可以使用这几个预定义函数常量，来判断信号捕获程序。

关于信号处理程序，注意点：

* 只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误
* SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31
* kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的

# 中断的系统调用

## 中断低速系统调用

若进程调用了一个低速的系统调用，

并且这个系统调用正在阻塞

此时，

捕捉到一个信号。

结果是：该系统调用就被中断不被执行了。


*注意*：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用

低速系统调用是可能是进程阻塞的系统调用，一般包括

* 读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞
* 打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）
* pause和wait，pause会使调用进程一直休眠，指导捕获一个信号
* 某些ioctl操作
* 某些进程间通信函数

这个需要注意的是，磁盘IO操作并不是低速系统调用。

## 低速系统调用被中断后的处理和重启

一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。

这样我们就能够处理这种失败。有两种处理方式：

* 系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作
* 某些中断的系统调用支持自动重启动


### 手动检查

比如可以这样处理：

```
while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
	continue;  // 啥也不做

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

如果经常使用这种检查，还可以定义一个宏：

```
#define NO_EINTR(stmt)	while((stmt) == -1 && errno == EINTR);

// 然后

NO_EINTR(cnt == read(fd, buf, BUF_SIZE));

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

### 自动重启动

为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：

```
wait waitpid read write ioctl readv writev


```

如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。

# 可重入函数

在信号处理程序中，不能调用不可重入函数。

所谓不可重入函数是指：

1. 它们使用了静态数据结构或全局变量
2. 调用malloc和free，因为malloc维护了一个全局链表
3. 标准IO函数

而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数

在标准C函数库中，不可重入函数比较普遍。

比如malloc和fe
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。















 








