---
comments: true
date: 2014-06-24 20:00:00
layout: post
title: apue(信号)
summary: 'apue chapter10'
tags:
- linux
- 笔记
---


# 信号概念

信号是软中断，提供了一种处理异步事件的方法

关于信号：

* 每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中
* 产生信号的条件
> * 用户按终端键，印发终端产生信号
> * 硬件异常产生信号，比如无效的内存引用，除数为0等
> * 进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）
> * 用户用kill命令给进程发送信号
> * 当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。

几种处理信号的方式

* 忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的
* 捕捉信号——需要注册一个信号处理函数
* 执行默认操作——大多数的信号的默认动作是终止信号

# signal函数

unix系统提供了两个改变信号处理的方式：signal和signalaction函数

现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。

```
void (*signal(int sig, void (*func)(int)))(int)
// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址
```

signal函数太复杂，可以使用typedef类型定义简化一下：

```
typedef void Sigfunc(int);

Sigfunc *signal(int Sigfunc *func);

```

一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：

```
#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针

```

可以使用这几个预定义函数常量，来判断信号捕获程序。

关于信号处理程序，注意点：

* 只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误
* SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31
* kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的

# 中断的系统调用

## 中断低速系统调用

若进程调用了一个低速的系统调用，

并且这个系统调用正在阻塞

此时，

捕捉到一个信号。

结果是：该系统调用就被中断不被执行了。


*注意*：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用

低速系统调用是可能是进程阻塞的系统调用，一般包括

* 读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞
* 打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）
* pause和wait，pause会使调用进程一直休眠，指导捕获一个信号
* 某些ioctl操作
* 某些进程间通信函数

这个需要注意的是，磁盘IO操作并不是低速系统调用。

## 低速系统调用被中断后的处理和重启

一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。

这样我们就能够处理这种失败。有两种处理方式：

* 系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作
* 某些中断的系统调用支持自动重启动


### 手动检查

比如可以这样处理：

```
while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
	continue;  // 啥也不做

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

如果经常使用这种检查，还可以定义一个宏：

```
#define NO_EINTR(stmt)	while((stmt) == -1 && errno == EINTR);

// 然后

NO_EINTR(cnt == read(fd, buf, BUF_SIZE));

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

### 自动重启动

为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：

```
wait waitpid read write ioctl readv writev


```

如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。

# 可重入函数

在信号处理程序中，不能调用不可重入函数。

所谓不可重入函数是指：

1. 它们使用了静态数据结构或全局变量
2. 调用malloc和free，因为malloc维护了一个全局链表
3. 标准IO函数

而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数

在标准C函数库中，不可重入函数比较普遍。

比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。

# 可靠信号的术语和语义

* 递送（delivery）信号：当引发信号的事件*发生*时，为进程产生一个信号（或向进程产生一个信号）
* 未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的

进程可以设置阻塞信号。

若信号被进程设置为阻塞，并且对该信号的动作是系统**默认动作**或**捕捉该信号**，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。

解除未决状态：
	* 对信号解除了阻塞
	* 或者将此信号的动作改为忽略。

注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：

```
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/signal.h>
#include <stdio.h>
void sig_int(int sig);
int main(int argc, char **argv)
{
	sigset_t osig;
	sigset_t newsig, o_set;

	sigemptyset(&newsig);
	sigaddset(&newsig, SIGINT);
	// if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
	if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
	{
		printf("signal sigint err!\n");
		exit(-1);
	}
	if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
	{
		printf("sigprocmask err!\n");
		exit(-1);
	}
	//pause();
	sleep(4);

	if (signal(SIGINT, sig_int) == SIG_ERR)
	{
		printf("signal sigint 1 err!\n");
		exit(-1);
	}
	if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
	{
		printf("sigprocmask 1 err!\n");
		exit(-1);
	}
	printf(" pause ...\n");
	sigprocmask(0, NULL, &o_set);
	if (sigismember(&o_set, SIGINT))
	{
		printf("is mask\n");
	}
	return 0;
}
void sig_int(int sig)
{
	printf("int sig hand\n");
}
```
执行结果是：
```
如果是默认处理，在sleep过程中，产生中断信号，结果是：
$ ./test_pend
^Cint sig hand
 pause ...

 如果改成忽略，在sleep过程中，产生中断信号，结果是：
 ./test_pend
^C pause ...
```

注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。

# kill和raise函数

kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号

```
#include <signal.h>

int kill(pid_t pid, int signo);
int raise(int signo);
```
下面是等价的：

raise(signo) == kill(getpid(), signo)

kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid < 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。

上面提到了，给其它进程发信号需要权限，具体是指：

* 超级用户可以将信号发送给任一进程
* 非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID

注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH

# alarm和pause函数

alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程

```
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的

pause函数使调用进程挂起直到捕捉到一个信号

```
#include <unistd.h>
int pause(void)
```

条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR

## 使用alarm实现sleep函数，并暴露问题

使用信号时，需要精细而周到的考虑，下面代码列出几个问题：

* 问题1：竞争条件















 








