---
comments: true
date: 2014-06-24 20:00:00
layout: post
title: apue(信号)
summary: 'apue chapter10'
tags:
- linux
- 笔记
---


# 信号概念

信号是软中断，提供了一种处理异步事件的方法

关于信号：

* 每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中
* 产生信号的条件
> * 用户按终端键，印发终端产生信号
> * 硬件异常产生信号，比如无效的内存引用，除数为0等
> * 进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）
> * 用户用kill命令给进程发送信号
> * 当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。

几种处理信号的方式

* 忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的
* 捕捉信号——需要注册一个信号处理函数
* 执行默认操作——大多数的信号的默认动作是终止信号

# signal函数

unix系统提供了两个改变信号处理的方式：signal和signalaction函数

现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。

```
void (*signal(int sig, void (*func)(int)))(int)
// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址
```

signal函数太复杂，可以使用typedef类型定义简化一下：

```
typedef void Sigfunc(int);

Sigfunc *signal(int Sigfunc *func);

```

一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：

```
#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针

```

可以使用这几个预定义函数常量，来判断信号捕获程序。

关于信号处理程序，注意点：

* 只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误
* SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31
* kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的

# 中断的系统调用

## 中断低速系统调用

若进程调用了一个低速的系统调用，

并且这个系统调用正在阻塞

此时，

捕捉到一个信号。

结果是：该系统调用就被中断不被执行了。


*注意*：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用

低速系统调用是可能是进程阻塞的系统调用，一般包括

* 读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞
* 打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）
* pause和wait，pause会使调用进程一直休眠，指导捕获一个信号
* 某些ioctl操作
* 某些进程间通信函数

这个需要注意的是，磁盘IO操作并不是低速系统调用。

## 低速系统调用被中断后的处理和重启

一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。

这样我们就能够处理这种失败。有两种处理方式：

* 系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作
* 某些中断的系统调用支持自动重启动


### 手动检查

比如可以这样处理：

```
while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
	continue;  // 啥也不做

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

如果经常使用这种检查，还可以定义一个宏：

```
#define NO_EINTR(stmt)	while((stmt) == -1 && errno == EINTR);

// 然后

NO_EINTR(cnt == read(fd, buf, BUF_SIZE));

if (cnt == -1)	// read读取错误，而不是被中断
	errExit("read");  
```

### 自动重启动

为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：

```
wait waitpid read write ioctl readv writev


```

如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。

# 可重入函数

在信号处理程序中，不能调用不可重入函数。

所谓不可重入函数是指：

1. 它们使用了静态数据结构或全局变量
2. 调用malloc和free，因为malloc维护了一个全局链表
3. 标准IO函数

而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数

在标准C函数库中，不可重入函数比较普遍。

比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。

# 可靠信号的术语和语义

* 递送（delivery）信号：当引发信号的事件*发生*时，为进程产生一个信号（或向进程产生一个信号）
* 未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的

进程可以设置阻塞信号。

若信号被进程设置为阻塞，并且对该信号的动作是系统**默认动作**或**捕捉该信号**，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。

解除未决状态：
	* 对信号解除了阻塞
	* 或者将此信号的动作改为忽略。

注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：

```
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/signal.h>
#include <stdio.h>
void sig_int(int sig);
int main(int argc, char **argv)
{
	sigset_t osig;
	sigset_t newsig, o_set;

	sigemptyset(&newsig);
	sigaddset(&newsig, SIGINT);
	// if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
	if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
	{
		printf("signal sigint err!\n");
		exit(-1);
	}
	if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
	{
		printf("sigprocmask err!\n");
		exit(-1);
	}
	//pause();
	sleep(4);

	if (signal(SIGINT, sig_int) == SIG_ERR)
	{
		printf("signal sigint 1 err!\n");
		exit(-1);
	}
	if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
	{
		printf("sigprocmask 1 err!\n");
		exit(-1);
	}
	printf(" pause ...\n");
	sigprocmask(0, NULL, &o_set);
	if (sigismember(&o_set, SIGINT))
	{
		printf("is mask\n");
	}
	return 0;
}
void sig_int(int sig)
{
	printf("int sig hand\n");
}
```
执行结果是：
```
如果是默认处理，在sleep过程中，产生中断信号，结果是：
$ ./test_pend
^Cint sig hand
 pause ...

 如果改成忽略，在sleep过程中，产生中断信号，结果是：
 ./test_pend
^C pause ...
```

注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。

# kill和raise函数

kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号

```
#include <signal.h>

int kill(pid_t pid, int signo);
int raise(int signo);
```
下面是等价的：

raise(signo) == kill(getpid(), signo)

kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid < 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。

上面提到了，给其它进程发信号需要权限，具体是指：

* 超级用户可以将信号发送给任一进程
* 非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID

注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH

# alarm和pause函数

alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程

```
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的

pause函数使调用进程挂起直到捕捉到一个信号

```
#include <unistd.h>
int pause(void)
```

条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR

## 使用alarm实现sleep函数，并暴露问题

使用信号时，需要精细而周到的考虑，下面代码列出几个问题：

* 问题1：竞争条件

看下面的sleep1的实现：

```
unsigned int sleep1(unsigned int nsecs)
{
	if(signal(SIGABRT, sig_alarm) == SIG_ERR)
	{
		printf("can't signal alarm!\n");
		return nsecs;
	}
	alarm(nsecs);
	pause();
	return (alarm(0)); // 返回未完成的时间
}

void sig_alarm(int signo)
{
	;
}
```
这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。

* 问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序

使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。


第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：

```

#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/signal.h>
#include <setjmp.h>

void sig_alarm(int signo);
static jmp_buf env_alrm;
int sleep2(int);
int main(int argc, char **argv)
{
	sleep2(2);
	exit(0);
}

int sleep2(int sec)
{

	if(signal(SIGALRM, sig_alarm) == SIG_ERR)
	{
		printf("sigalarm err!\n");
		return sec;
	}
	if(setjmp(env_alrm) == 0)
	{
		alarm(sec);
		pause();
	}
	return (alarm(0));
}

void sig_alarm(int signo)
{
	longjmp(env_alrm, 1);
}


```

这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。

## 除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限

下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：

```
#include <stdlib.h>
#include <stdio.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/signal.h>
#include <unistd.h>

int read_timeout(int fd, void *buf, size_t size, int timeout);

static jmp_buf env_alarm;
void sig_alarm(int signo);
int main(int argc, char **argv)
{
	char line[100];
	int n;
	n = read_timeout(STDIN_FILENO, line, 100, 3);
	if(n < 0)
	{
		printf("read timeout\n");
	} else {
		printf("read len %d.\n", n);
	}
	exit(0);
}
int read_timeout(int fd, void *buf, size_t size, int timeout)
{
	int n = 0;
	if(signal(SIGALRM, sig_alarm) == SIG_ERR)
	{
		printf("sig alarm err\n");
		return -1;
	}
	if(setjmp(env_alarm) == 0)
	{
		alarm(timeout);
		if((n=read(fd, buf, size)) < 0)
		{
			printf("read err!\n");
			return n;
		}
		alarm(0);
		return n;
	}
	return -1;
}

void sig_alarm(int signo)
{
		longjmp(env_alarm, 1);
}

```

执行结果：
```
user@usertekiMacBook-Pro unix_test$ ./read_timeout
read timeout
user@usertekiMacBook-Pro unix_test$
user@usertekiMacBook-Pro unix_test$ ./read_timeout
dd
read len 3.
```

注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。

# 信号集

可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数


```
#include <signal.h>

int sigempty(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
	// 四个函数返回值：成功，返回0，失败返回-1
int sigismember(const sigset_t *set, int signo);
	// 若真，返回1，假，返回0，出错，返回-1

```

# sigpromask函数

调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。

```
#include <signal.h>

int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1

```
* oset非空，则进程当前信号屏蔽字通过oset返回
* set非空，则根据第一个参数how指示如何修改当前信号屏蔽字
* set为空，不改变

how的值：

* SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集
* SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集
* SIT_SETMASK: 被set指向的值替代


# sigpending函数

sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。

```
#include <signal.h>

int sigpending(sigset_t *set);
```

注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。

例子：

```
#include <stdlib.h>
#include <signal.h>
#include <sys/signal.h>
#include <unistd.h>
#include <stdio.h>

void sig_quit(int);

int main(int argc, char **argv)
{
	sigset_t oldset, newset, quitset;
	sigemptyset(&quitset);
	sigaddset(&quitset, SIGINT);

	// ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
	if (signal(SIGINT, sig_quit) == SIG_ERR)
	{
		printf("sig err\n");
		exit(-1);
	} 
	// ************

	if (sigprocmask(SIG_BLOCK, &quitset, &oldset) == -1)
	{
		printf("mask sig err!\n");
		exit(0);
	}
	// sleep 5 seconds
	sleep(5);
	if (sigpending(&newset) == -1)
	{
		printf("pending err \n");
		exit(0);
	}
	if (sigismember(&newset, SIGINT))
		printf("sigquit is block\n");

	if (sigprocmask(SIG_SETMASK, &oldset, NULL) == -1)
	{
		printf("mask ret sig err!\n");
		exit(0);
	}
	printf("sig int unblock\n");
	sleep(5);
	return 0;
}

void sig_quit(int signo)
{
	printf("sigquit catch\n");

	if (signal(SIGINT, sig_quit) == SIG_ERR)
	{
		printf("sig err\n");
		exit(-1);
	}
}
```

# sigaction函数






 








