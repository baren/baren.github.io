<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Baren Blog]]></title>
  <link href="http://baren.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2014-10-14T22:14:12+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[pthread 进一步细节]]></title>
    <link href="http://baren.github.io/blog/2014/09/28/pthread-further-details/"/>
    <updated>2014-09-28T20:43:21+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/28/pthread-further-details</id>
    <content type="html"><![CDATA[<h1>线程和信号</h1>

<p>信号的设计实现早于线程，导致线程与信号之间有许多冲突。冲突的地方主要在于：</p>

<ul>
<li>既要维护传统的在单线程进程环境下的信号语义</li>
<li>同时又要开发符合多线程进程环境下的信号程序</li>
</ul>


<!-- more -->


<h2>信号模式怎样映射到线程</h2>

<p>需要弄清楚信号的哪些方面是进程级别的，哪些方面是针对特定线程的。说明：</p>

<ul>
<li>信号动作是<em>进程</em>级别的。这意味着一个默认动作是终止进程的信号被内核递送到进程的任意线程，所有的进程内的线程都会终止。</li>
<li>信号处理是<em>进程</em>级别的。进程内的所有线程都共享同一个信号处理器。如果一个线程使用sigaction()建立的信号处理器，进程内的任意线程如果收到这个信号，都会调用这个处理器；如果一个线程设置了忽略某个信号，其它线程也自动忽略</li>
<li>如果信号递送给一个多线程的进程时，内核会随机选取一个线程，用来递送信号和执行信号处理程序。</li>
<li>屏蔽信号是基于线程的。线程可以使用pthread_sigmask()来屏蔽某些信号。</li>
<li>内核维护了针对进程的一个全局的阻塞（pending）的信号集；也维护了针对每个线程的阻塞的信号集。sigpending()函数会返回进程的全局阻塞的信号集和调用这个函数的线程的阻塞信号集的并集。一个新创建的线程，阻塞的信号集是空。如果一个线程阻塞了一个信号，这个信号一直被阻塞，直到线程取消阻塞或者线程停止。</li>
<li>如果一个信号处理中断了pthread_mutex_lock()调用，这个调用总是会自动启动。如果中断了pthread_cond_wait()，也会自动重启。</li>
</ul>


<p>以下几种情况，信号会递送给特定线程：</p>

<ul>
<li>在某个线程上下文中，执行了一个特定的硬件指令的直接结果，生成信号</li>
<li>线程试图写入到一个终端的pipe文件时，生成一个SIGPIPE</li>
<li>使用pthread_kill() 或 pthread_sigqueue()可以允许同一进程的线程给另一个线程发信号</li>
</ul>


<pre><code class="c">#include &lt;signal.h&gt;
int pthread_kill(pthread_t thread, int sig);

int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
</code></pre>

<h1>线程和进程控制</h1>

<p>就像信号一样exec(), fork(), and exit()也是早于线程。</p>

<h5>线程和exec()</h5>

<p>当任意线程调用exec()函数时，调用的程序会被完全取代。所有的线程，除了调用线程外，都会被终止。不会去执行线程的终止处理函数，属于进程的锁和条件变量都会消失。</p>

<h5>线程和fork()</h5>

<p>多线程环境的进程调用fork()函数，只有调用进程在子进程中复制。其它线程在子进程中会消失，线程特定的析构或者清理函数都不会执行。这会导致严重问题：</p>

<ul>
<li><p>虽然只有调用线程被复制了，但是进程全局状态，还有pthread对象（比如锁和条件变量）等全局对象，都会被复制到子进程。这会导致，如果在fork的同时，有个线程锁住了mutex，并且部分更新了全局数据结构，这种情况下，子进程中的线程将不能够解锁这个mutex。更进一步，子进程中的全局状态可能处于不一致状态。</p></li>
<li><p>由于线程的析构或者清理函数没有被调用，有可能导致子进程的内存泄露。</p></li>
</ul>


<p>由于在多线程环境下调用fork有这么多严重问题，通常的建议是：</p>

<ul>
<li>只有在后续立即调用exec函数的情况下，才会调用fork函数。否则不要调用。</li>
</ul>


<p>如果必须调用fork函数，但是后面不跟着调用exec函数，linux提供了一个这种情况下的解决办法：</p>

<pre><code class="c">pthread_atfork(prepare_func, parent_func, child_func);
</code></pre>

<h1>线程实现模式</h1>

<p>有许多线程实现方式，主要的区别是线程和内核的调度实体（kernel scheduling entities）之间映射的不同。</p>

<p>内核调度实体（kernel scheduling entities）是内核分配CPU和其他资源的单元。在传统的UNIX系统下，内核调用实体与进程是同义的。</p>

<h2>Many-to-one (M:1) 实现，用户级别线程</h2>

<p>在M:1线程实现模式下，所有的线程创建、调度和同步细节都在用户空间下的线程lib包实现。内核不知道关于线程的任何细节。</p>

<p>这种实现有以下几种好处：</p>

<ul>
<li>最大的好处是线程操作非常快速，因为这些全部在用户空间实现，不用切换到内核空间。</li>
<li>移植性好，由于是在用户空间实现的，可以很容易从一个系统移植到另一个系统</li>
</ul>


<p>不好处是：</p>

<ul>
<li>当一个线程调用了一个系统调用（比如read()），控制从用户空间的线程包转到内核，这意味着read()被阻塞了，那么其它线程就全部被阻塞了。</li>
<li>内核不能够调度线程。由于内核不知道线程的存在，因此内核不能调度线程到其它cpu上。</li>
</ul>


<h2>One-to-one (1:1)实现方式</h2>

<p>在1:1实现方式下，一个线程对应一个内核的调度实体。内核单独的处理每个线程的调度。这样，就解决了M:1的重大调度问题。</p>

<p>但是这种实现方式下，也有其它问题：</p>

<ul>
<li>线程的创建同步等操作就比较慢，因为需要切换到内核空间下。</li>
<li>一对一的关系，内核需要为每一个线程维护一个内核调度实体，如果有大量的线程，会降低整体性能。</li>
</ul>


<p>尽管如此，1:1的方式是大多数pthread线程实现的方式。两个linux的pthread实现都是采用1:1的方式</p>

<h2>linux的pthread实现方式</h2>

<p>linux有两种pthread的实现：</p>

<ul>
<li>LinuxThreads: 这是linux的最初实现。Xavier Leroy开发</li>
<li>NPTL (Native POSIX Threads Library): 新的linux下的pthread实现。Ulrich Dreppe（gun c也叫libc的管理者） 和 Ingo Molnar实现。性能比LinuxThreads好，也更符合pthread的规范。</li>
</ul>


<p>在glibc 2.4及其后续版本，不再支持LinuxThreads了。</p>

<h3>LinuxThreads实现细节</h3>

<ul>
<li>使用clone() 系统调用创建一个线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>

<p>这意味着LinuxThreads线程共享虚拟内存、文件描述符、文件相关信息（umask, root directory, and current working directory）和信号处理。</p>

<ul>
<li><p>除了由应用创建的线程，LinuxThreads还创建了额外的管理线程，来处理线程的创建的销毁。</p></li>
<li><p>实现采用了信号来进行内部的操作。</p></li>
</ul>


<p>当内核支持实时信号（Linux 2.2及其以后），前三个实时信号被使用；如果是老的内核，使用 SIGUSR1 and SIGUSR2，这样，应用不能够使用这几个信号。</p>

<p>关于实时信号，参考：
<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7">http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7</a></p>

<h3>NPTL</h3>

<ul>
<li>使用clone() 创建线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>

<ul>
<li><p>使用了前两个实时信号</p></li>
<li><p>不像LinuxThreads，NPTL没有实现管理线程</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[取消线程]]></title>
    <link href="http://baren.github.io/blog/2014/09/25/pthread-cancel/"/>
    <updated>2014-09-25T20:56:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/25/pthread-cancel</id>
    <content type="html"><![CDATA[<p>主要描述POSIX线程的取消机制和更进一步的线程细节，包括线程和信号，线程栈等。</p>

<h1>取消一个线程</h1>

<p>使用pthread_cancel函数取消特定的线程：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t thread);
// 返回0表示成功
</code></pre>

<p>pthread_cancel只是发送取消请求，然后立即返回。这意味着调用线程不用等待线程停止。目标线程什么时候停止，取决于目标线程的状态和类型。</p>

<h1>取消状态和类型</h1>

<p>使用pthread_setcancelstate()设置线程的取消状态；使用pthread_setcanceltype()设置线程的取消类型。这两个状态设置线程如何响应取消操作的。</p>

<p>pthread_setcancelstate()函数可设置的状态是：</p>

<ul>
<li>PTHREAD_CANCEL_DISABLE。 线程是不可取消的。这种线程如果接收到一个取消请求，会保持未决（pending）状态直到成为可取消状态</li>
<li>PTHREAD_CANCEL_ENABLE。线程是可取消的，这个状态也是默认的状态。</li>
</ul>


<p>线程在执行一段必须执行完的代码时，设置为不可取消状态，是非常有用的。</p>

<p>pthread_setcanceltype()函数可以设置两种类型：</p>

<ul>
<li>PTHREAD_CANCEL_DEFERRED。线程一直执行直到遇到取消点（特殊函数）。默认类型。</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS。线程可以在任意时间点取消，一般不大永。</li>
</ul>


<h1>取消点</h1>

<p>当一个线程是可取消的并且是延迟的（PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DEFERRED）。取消操作会在线程执行到下一个取消点时起作用。</p>

<p>SUSv3 定义了一组必须是取消点的函数，还定义了一组是可选取消点的函数。</p>

<p>可取消函数列表（略）</p>

<p>对于一个不是分离的线程，必须由其它函数调用pthread_join函数等待这个线程结束。如果这个线程接收了取消请求，并到达了一个取消点，则pthread_join返回的值是PTHREAD_CANCELED.</p>

<p>取消线程的例子：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static void *
threadFunc(void *arg)
{
    int j;
    printf("New thread started\n");
    for (j = 1; ; j++) {
        printf("Loop %d\n", j);
        sleep(1);
    /* NOTREACHED */
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    int s;
    void *res;

    s = pthread_create(&amp;thr, NULL, threadFunc, NULL); 
    if (s != 0)
        errExitEN(s, "pthread_create"); 

    sleep(3);       /* Allow new thread to run a while */

    s = pthread_cancel(thr);
    if (s != 0)
        errExitEN(s, "pthread_cancel");

    s = pthread_join(thr, &amp;res);
    if (s != 0)
        errExitEN(s, "pthread_join");

    if (res == PTHREAD_CANCELED) 
        printf("Thread was canceled\n");

    else
        printf("Thread was not canceled (should not happen!)\n");
    exit(EXIT_SUCCESS);
}
</code></pre>

<h1>测试取消点</h1>

<p>如果线程没有调用这些取消点函数（纯计算线程），为了也能够响应取消请求，可以使用pthread_testcancel()来当取消点。</p>

<pre><code class="c">#include &lt;pthread.h&gt;
void pthread_testcancel(void);
</code></pre>

<h1>清理处理器</h1>

<p>如果一个线程接收到取消请求，执行到一个取消点，则会停止。有可能会导致共享的变量和pthread对象（比如锁）处在不一致状态，可能会导致剩下的线程死锁等异常状态。</p>

<p>为了避免这个问题，需要定义线程结束的清理函数。</p>

<p>每一个线程都有一个线程处理函数栈。当线程被取消时，从上到下依次开始执行清理处理程序。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
void pthread_cleanup_push(void (*routine)(void*), void *arg);
void pthread_cleanup_pop(int execute);
</code></pre>

<blockquote><p>注意：
当线程正常执行完成，不会触发清理处理函数。</p></blockquote>

<p>一般来说，一个清理操作只有在执行一段特殊的代码时被取消时，才会用到。</p>

<p>下面例子在主main函数中创建了一个线程，他分配了一块内存，并锁住了一个互斥锁mtx。因为线程有可能被取消，因此使用pthread_cleanup_push()来安装清理处理函数，这个清理函数主要作用是释放分配的内存，并对互斥锁解锁。</p>

<p>安装完清理处理器后，线程进入所谓的特殊代码段（如果取消，需要走清理处理函数的）。</p>

<p>如果特殊代码段正常执行完成，则调用pthread_cleanup_pop()去掉处理函数。</p>

<p>例子：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static int glob = 0; /* Predicate variable */

static void         /* Free memory pointed to by 'arg' and unlock mutex */ cleanupHandler(void *arg)
{
    int s;

    printf("cleanup: freeing block at %p\n", arg);
    free(arg);

    printf("cleanup: unlocking mutex\n");
    s = pthread_mutex_unlock(&amp;mtx);
    if (s != 0)
        errExitEN(s, "pthread_mutex_unlock");
}


static void *
threadFunc(void *arg)
{
    int s;
    void *buf = NULL;   /* Buffer allocated by thread */

    buf = malloc(0x10000);
    printf("thread: allocated memory at %p\n", buf);

    s = pthread_mutex_lock(&amp;mtx);   /* Not a cancellation point */ 
    if (s != 0)
        errExitEN(s, "pthread_mutex_lock");

    pthread_cleanup_push(cleanupHandler, buf);

    while (glob == 0) {
        s = pthread_cond_wait(&amp;cond, &amp;mtx);     /* A cancellation point */
        if (s != 0)     
            errExitEN(s, "pthread_cond_wait"); 
    }
    printf("thread: condition wait loop completed\n");
    pthread_cleanup_pop(1);
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    void *res;
    int s;

    s = pthread_create(&amp;thr, NULL, threadFunc, NULL); 
    if (s != 0)
        errExitEN(s, "pthread_create");

    sleep(2);       /* Give thread a chance to get started */

    if (argc == 1) {        /* Cancel thread */
        printf("main: about to cancel thread\n");
        s = pthread_cancel(thr);
        if (s != 0)
            errExitEN(s, "pthread_cancel");
    } else {        /* Signal condition variable */
        printf("main: about to signal condition variable\n");
        glob = 1;
        s = pthread_cond_signal(&amp;cond);
        if (s != 0)
            errExitEN(s, "pthread_cond_signal");
    }

    s= pthread_join(thr, &amp;res); 
    if (s != 0)
        errExitEN(s, "pthread_join"); 

    if (res == PTHREAD_CANCELED)
        printf("main: thread was canceled\n"); 
    else
        printf("main: thread terminated normally\n");

    exit(EXIT_SUCCESS);
}   
</code></pre>

<blockquote><p>注意：
注意上面例子对pthread_cleanup_push()函数的的典型使用</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread control]]></title>
    <link href="http://baren.github.io/blog/2014/09/17/pthread-control/"/>
    <updated>2014-09-17T21:19:03+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/17/pthread-control</id>
    <content type="html"><![CDATA[<h1>线程属性</h1>

<p>在使用pthread_create函数：</p>

<pre><code class="c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
</code></pre>

<p>创建线程时，第三个参数attr是线程属性。可以使用pthread_attr_t结构来修改线程默认属性。</p>

<p>pthread_attr_t变量需要初始化，需要使用pthread_attr_init函数进行初始化。调用初始化函数后，pthread_attr_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p>

<!-- more -->


<p>pthread_attr_t属性的初始化和销毁接口：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_attr_init(ptread_attr_t *attr);
int pthread_attr_destory(pthread_attr_t *attr);
</code></pre>

<p>POSIX.1支持的线程属性包括：</p>

<ul>
<li>线程的分离状态属性</li>
<li>线程栈末尾的警戒缓冲区大小</li>
<li>线程栈的最低地址</li>
<li>线程栈的大小</li>
</ul>


<p>如果创建的线程不需要知道线程的终止状态，可以在创建的时候，以分离状态启动。通过设置pthread_attr_t的值为分离状态。设置pthread_attr_t的函数是：</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
</code></pre>

<p>设置分离状态的属性值是：PTHREAD_CREATE_DETACHED</p>

<h1>同步属性</h1>

<p>互斥量、读写锁和条件变量的属性</p>

<h2>互斥量属性</h2>

<p>主要讲互斥量属性的类型属性。类型属性有以下几种：</p>

<ul>
<li>PTHREAD_MUTEX_NORMAL——不检查死锁错误，如果一个线程试图去lock一个他已经锁住的互斥量，则发生死锁。</li>
<li>PTHREAD_MUTEX_ERRORCHECK——提供错误检查</li>
<li>PTHREAD_MUTEX_RECURSIVE——允许同一个线程多同一个互斥量多次加锁。会维持一个加锁计数量。</li>
</ul>


<p>对互斥量，属性初始化和销毁函数是：</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

int pthread_mutex_destroy(pthread_mutex_t *mutex);
</code></pre>

<p>可以通过下面函数设置互斥量属性：</p>

<pre><code class="c">int pthread_mutexattr_gettype(pthread_mutexattr_t *attr, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
</code></pre>

<h2>读写锁属性</h2>

<p>支持进程共享属性</p>

<h2>条件变量属性</h2>

<p>支持进程共享属性</p>

<h1>重入</h1>

<p>在信号处理时，可重入的函数是指函数没有访问静态数据结构，或者没有调用malloc和free等。在线程处理时，函数同样也有重用的概念。</p>

<p>在多线程环境下，一个函数是可重入的，意思是：一个函数在同一时刻可以被多个线程安全调用。</p>

<p>注意与信号的区别
* 一个函数对多线程来说是可重入的，意思是这个函数是线程安全的。
* 但并不意味着对信号处理程序来说该函数是可重入的（比如标准io函数，是线程安全的，会对流加锁保证，但是对信号处理是不可重入的，因为会修改全局数据结构）。</p>

<p>有一个列表，列出了posix.1中不能保证线程安全的函数：</p>

<p><img src="/images/assets/pthread-1.png" title="linux" alt="alt text" /></p>

<p>如果操作系统实现线程安全这一特性时，会同时提供一个对应的线程安全版本。</p>

<p>比如asctime，对应的就是asctime_r，后缀是_r表示可重入。</p>

<p>posix.1还提供了以线程按方式管理FILE对象的方法。</p>

<p>标准IO流的实现，会对流加锁解锁操作，如果频繁调用getc函数，会有性能下降，因为会有频繁的加锁解锁。</p>

<p>为了解决这个问题，posix1.c引入非可重入版本的流函数：</p>

<pre><code class="c">
#include &lt;stdio.h&gt;
int getchar_unlocked(void); 
int getc_unlocked(FILE *fp);

putchar_unlocked(int c);
int putc_unlocked(int c, FILE *fp);
</code></pre>

<p>同时提供了线程安全的方式管理FILE对象的方法：</p>

<pre><code class="c">
#include &lt;stdio.h&gt;
int ftrylockfile(FILE *fp);
void flockfile(FILE *fp); 
void funlockfile(FILE *fp);
</code></pre>

<p>使用非线程安全的流函数版本时，需要用flockfile和funlockfile包围，否则会出现不可预测的问题（因为是非线程安全的）。</p>

<p>好处：</p>

<ul>
<li>一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次数据读写上分摊总的加解锁开销。</li>
</ul>


<h1>线程私有数据</h1>

<p>让一个函数是线程安全的最有效的方式就是让函数是可重入的。新的函数最好这么实现。尽管如此，
一些老的函数，不是线程安全的，如果要将其改造成线程安全函数，需要满足：</p>

<ul>
<li>实现线程安全的</li>
<li>不能改变函数的签名，也就是不需要调用这个函数的程序去修改</li>
</ul>


<p>使用线程私有（thread-specific）数据可以实现。</p>

<blockquote><p>注意：
要理解线程私有数据，以函数的角度考虑问题。</p></blockquote>

<p>线程私有数据允许函数为每一个线程维持一个单独的数据拷贝。如图所示：</p>

<p><img src="/images/assets/pthread-psd.png" title="linux" alt="alt text" /></p>

<p>线程A调用函数myfunc时，myfunc函数为线程A维持一个单独数据，线程B调用myfunc函数时，myfunc为线程B维持一个线程B单独的数据。</p>

<p>线程私有数据有个特点：</p>

<ul>
<li>存储的数据是持久化的，每一份数据会一直存在，这允许函数间共享数据（虽然不推荐）。</li>
</ul>


<h2>从函数角度考虑线程私有数据</h2>

<p>为了更好的理解线程私有数据，需要从函数角度（实现角度）考虑如何使用线程私有数据</p>

<ul>
<li>在线程第一次调用函数时，函数为线程分配独立的存储块。存储块只分配一次，就是在线程第一次调用此函数时。</li>
<li>同一个线程对这个函数的随后的调用，函数能够获取这个第一次调用而分配存储块。因此不能用局部变量存储指向存储块的key；也不能用static变量存储，因为在进程内，只有一个static的实例。</li>
<li>不同的函数可能都需要线程私有数据，因此每个函数都得需要自己的线程私有数据key</li>
<li>当线程停止时，函数不需要控制私有数据，因为停止时，代码有可能已经执行到函数外了。因此需要有个地方来执行清理操作。</li>
</ul>


<h2>线程私有数据 API</h2>

<h3>创建私有数据key</h3>

<p>创建一个key，两个用处：</p>

<ul>
<li>用来获取函数分配的存储块</li>
<li>用来区分其它函数的线程私有数据对应的key</li>
</ul>


<p>使用pthread_key_create函数</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
</code></pre>

<p>destructor指向一个清理函数，用来释放函数内分配的存储块。</p>

<p>其签名是：</p>

<pre><code class="c">void dest(void *value)
{
/* Release storage pointed to by 'value' */ 
}
</code></pre>

<p>线程停止时，并且这个key关联的数据不是NULL时，就会自动调用这个函数来清理。</p>

<p>一般，线程私有数据的实现，使用一个全局数组来存储这个key，这个key有两个状态：</p>

<ul>
<li>是否使用的标记</li>
<li>清理函数指针</li>
</ul>


<p>如图：</p>

<p><img src="/images/assets/pthread-psd-key.png" title="linux" alt="alt text" /></p>

<p>根据图，pthread_key_create()返回的一般是全局数组的索引，数组元素包含两个字段，是否使用字段和清理函数地址字段。</p>

<h3>关联函数分配内存与key</h3>

<p>使用函数pthread_setspecific函数来关联函数分配的存储和pthread_key_create创建的key。</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_setspecific(pthread_key_t key, const void *value);
// value参数是一个分配的内存的指针
// 当线程停止时，这个值会传给create函数指定的清理函数。
void *pthread_getspecific(pthread_key_t key);
</code></pre>

<p>为了维护线程私有数据，Pthreads API 为每一个线程维护了一个指针数组，数据元素是函数分配的存储的指针。</p>

<p>如下图，假设pthread_keys[1]是函数myfunc分配的key，对于每一个线程，pthread api维护了一个指针数组，
数组元素指向函数内分配的内存，</p>

<p><img src="/images/assets/pthread-psd-key-2.png" title="linux" alt="alt text" /></p>

<h2>例子</h2>

<h3>非线程安全的</h3>

<p>下面是一个非线程安全的strerror()的实现：</p>

<pre><code class="c">#define _GNU_SOURCE  /* Get '_sys_nerr' and '_sys_errlist' declarations from &lt;stdio.h&gt; */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   /* Get declaration of strerror() */
#define MAX_ERROR_LEN 256  /* Maximum length of string returned by strerror() */
static char buf[MAX_ERROR_LEN];  /* Statically allocated return buffer */
char *
strerror(int err)
{

    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);

        buf[MAX_ERROR_LEN - 1] = '\0'; /* Ensure null termination */
    }
    return buf; 
}
</code></pre>

<h3>线程安全例子</h3>

<pre><code class="c">
#define _GNU_SOURCE     /* Get '_sys_nerr' and '_sys_errlist' declarations from &lt;stdio.h&gt; */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;     /* Get declaration of strerror() */
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"


static pthread_once_t once = PTHREAD_ONCE_INIT; 
static pthread_key_t strerrorKey;


#define MAX_ERROR_LEN 256       /* Maximum length of string in per-thread buffer returned by strerror() */

static void
destructor(void *buf)       /* Free thread-specific data buffer */
{
    free(buf);
}

static void
createKey(void)     /* One-time key creation function */
{
    int s;
    /* Allocate a unique thread-specific data key and save the address of the destructor for thread-specific data buffers */

    s = pthread_key_create(&amp;strerrorKey, destructor);
    if (s != 0)
        errExitEN(s, "pthread_key_create");
}

char *
strerror(int err)
{
    int s;
    char *buf;

    /* Make first caller allocate key for thread-specific data */

    s = pthread_once(&amp;once, createKey); 
    if (s != 0)
        errExitEN(s, "pthread_once");

    buf = pthread_getspecific(strerrorKey);
    if (buf == NULL) { /* If first call from this thread, allocate buffer for thread, and save its location */

        buf = malloc(MAX_ERROR_LEN);
        if (buf == NULL)
            errExit("malloc");

        s = pthread_setspecific(strerrorKey, buf); 
        if (s != 0)
            errExitEN(s, "pthread_setspecific");
    }

    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) { 
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '\0'; /* Ensure null termination */
    }

    return buf; 
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(线程)]]></title>
    <link href="http://baren.github.io/blog/2014/08/28/pthread/"/>
    <updated>2014-08-28T20:00:53+08:00</updated>
    <id>http://baren.github.io/blog/2014/08/28/pthread</id>
    <content type="html"><![CDATA[<h1>线程概念</h1>

<p>主要是POSIX线程，也就是pthread。</p>

<p>正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。</p>

<p>判断系统是否支持pthread，可以使用宏<em>POSIX_THREADS进行测试，还可以把</em>SC_THREADS传递给sysconf函数来运行时判断。</p>

<p>线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：</p>

<ul>
<li>进程之间共享数据非常困难</li>
<li>使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。</li>
</ul>


<p>使用线程，解决这上面这些问题：</p>

<ul>
<li>线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。</li>
<li>线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。</li>
</ul>


<p>除了共享全局内存，线程还共享一些其他属性，包括</p>

<ul>
<li>进程id和父进程id</li>
<li>进程组合session id</li>
<li>控制终端</li>
<li>进程凭证（用户和组id）</li>
<li>打开的文件描述符（比较重要）</li>
<li>信号处理</li>
<li>文件系统相关信息：umask、当前工作目录和根目录</li>
<li>等</li>
</ul>


<p>下面是各个线程不同的属性：</p>

<ul>
<li>线程id</li>
<li>信号mask</li>
<li>线程私有数据</li>
<li>errno变量</li>
<li>等</li>
</ul>


<!-- more -->


<h2>线程和errno</h2>

<p>进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。</p>

<p>这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。</p>

<p>注：</p>

<blockquote><p>在线程中，使用函数的返回错误码更为清晰整洁。</p></blockquote>

<h2>线程ID</h2>

<p>进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用<code>pid_t</code>来表示；线程的ID，使用<code>pthread_t</code>类型来表示。</p>

<p>为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。</p>

<p>下面是处理线程ID的函数：</p>

<pre><code>#include &lt;pthread.h&gt;
// 比较两个线程ID
int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值

// 获取线程的ID
pthread_t pthread_self(void);
</code></pre>

<h1>线程创建</h1>

<p>使用pthread_create函数创建线程：</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start)(void *), void *arg);

// 成功返回0
</code></pre>

<p>这个函数的参数意义是：</p>

<ul>
<li>thread——线程创建成功后，将线程的ID写入这个指针指向的内存中</li>
<li>attr——创建线程的属性</li>
<li>start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数</li>
<li>arg——无类型指针参数，作为线程执行函数的参数传入</li>
</ul>


<h1>线程终止</h1>

<ul>
<li><p>进程终止会导致线程终止：</p>

<ul>
<li>任一线程调用了exit，<em>Exit或</em>exit函数，整个进程终止</li>
<li>若信号的默认动作是终止进程，则把信号发送到线程会终止进程</li>
</ul>
</li>
<li><p>单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。</p>

<ul>
<li>线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）</li>
<li>线程可以被同一进程中的其它线程取消（pthread_cancel）</li>
<li>线程调用pthread_exit函数退出</li>
</ul>
</li>
</ul>


<pre><code>#include &lt;pthread.h&gt;
void pthread_exit(void *retval);
</code></pre>

<p>pthread_exit接收的参数，就是线程的返回值。</p>

<p>其它线程可以通过pthread_join获取这个值。</p>

<p>注意：</p>

<blockquote><p>pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。</p></blockquote>

<h2>pthread_join函数</h2>

<p>pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。</p>

<pre><code>include &lt;pthread.h&gt;
int pthread_join(pthread_t thread, void **retval); // 成功，返回0
</code></pre>

<p>如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。</p>

<p>注意：</p>

<blockquote><p>如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。</p></blockquote>

<p>如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程</p>

<p>还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &amp;status, options)); 等待任意进程，线程没有这个操作。</p>

<h2>pthread_detach函数</h2>

<p>默认情况下，线程是可<em>结合的（joinable）</em>，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。</p>

<p>某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是<em>分离的（detached）</em>。</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_detach(pthread_t thread);
// 成功返回0
</code></pre>

<p>注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。</p>

<h1>线程参数传递和返回值</h1>

<p>在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。</p>

<ul>
<li>在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数</li>
<li>当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：

<blockquote><ul>
<li>在线程执行函数返回一个指针</li>
<li>调用pthread_exit()，把返回值指针作为pthread_exit的参数</li>
</ul>
</blockquote></li>
</ul>


<p>例子：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

/* **************************************************************************/
/*  our macro for errors checking                                           */
/* **************************************************************************/
#define COND_CHECK(func, cond, retv, errv) \
if ( (cond) ) \
 { \
    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
                  __FILE__,__LINE__,func,retv,strerror(errv)); \
                     exit(EXIT_FAILURE); \
 }

#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)




void *th_func1(void *arg);
void *th_func2(void *arg);
void test_thread_ret();

int main(int argc, char *argv[])
{
    test_thread_ret();
    return 0;
}

void test_thread_ret()
{
    int t_ret;
    // pthread ret
    pthread_t t1, t2;
    void *tret;
    t_ret = pthread_create(&amp;t1, NULL, th_func1, NULL);
    PthreadCheck("pthread_create", t_ret);
    t_ret = pthread_create(&amp;t2, NULL, th_func2, (void *)2);
    PthreadCheck("pthread_create", t_ret);

    printf("join t1\n");
    t_ret = pthread_join(t1, &amp;tret);
    PthreadCheck("pthread_join", t_ret);
    printf("ret of thread 1 is %d.\n", (int) tret);

    printf("join t2\n");
    t_ret = pthread_join(t2, &amp;tret);
    PthreadCheck("pthread_join", t_ret);
    printf("ret of thread 2 is %d.\n", (int) tret);

}
void *th_func1(void *arg)
{
    printf("thread 1 runing\n");
    return (void *)1;
}

void *th_func2(void *arg)
{
    int * a;
    a = (int *)arg;
    printf("thread 2 arg is %d.\n", (int) a);
    pthread_exit((void *) 2);
}
</code></pre>

<h1>取消线程</h1>

<p>线程可以调用pthread_cancel函数<em>请求</em>取消同一进程中的其它线程。</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cancel(pthread_t tid);
</code></pre>

<p>pthread_cancel并不等待线程终止仅仅提出请求。</p>

<p>线程在取消请求发出后还继续运行，直到线程打到某个<em>取消点</em>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>

<h1>线程同步</h1>

<p>有三种同步方式：互斥量、读写锁以及条件变量</p>

<h2>互斥量</h2>

<p>互斥量用pthread_mutex_t数据类型表示，使用互斥量之前必须对其进行初始化
* 初始化为常量PTHREAD_MUTEX_INITIALIZER，前提是pthread_mutex_t为静态分配的
* 调用pthread_mutex_init函数初始化动态分配的pthread_mutex_t变量。</p>

<p>注意：
* 如果pthread_mutex_t是动态分配的（比如通过malloc），则须用pthread_mutex_destory函数来师傅内存。</p>

<pre><code class="c">
int pthread_mutex_init(pthread_mutex_t *restrict mutex, pthread_mutexattr_t *attr);
int pthread_mutex_destory(pthread_mutex_t *mutex)
</code></pre>

<p>对互斥量加锁解锁函数</p>

<pre><code>
#include &lt;pthread.h&gt;
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>

<p>对互斥量要找到平衡点，既不使锁得粒度太粗导致线程阻塞，又不能因为锁得粒度太细导致代码复杂性和过多锁导致性能下降。</p>

<h2>读写锁</h2>

<p>与互斥量类似，但是读写锁具有更高的并行性。读写锁有三种状态：
* 读模式下的锁状态
* 写模式下的加锁状态
* 不加锁状态</p>

<p>对于读写锁，有几个特征：</p>

<ul>
<li>一次只能有一个线程可以占有写锁，但是多个线程可以同时占用读锁。</li>
<li>当处于写锁状态时，所有试图对其进行加读锁的线程，都会被阻塞</li>
<li>当处于读锁状态时，所有试图对齐进行加读锁的线程，都可以立即获得</li>
<li>如果在读锁状态下，线程希望以写锁对此锁进行加锁，必须阻塞直到线程释放获的的读锁才可以加上写锁。</li>
<li>为了防止一直处于读锁中而使写锁一直阻塞，一旦进行加写锁阻塞，会阻塞后续对其进行的增加读锁行为。</li>
</ul>


<p>读写锁也叫共享-独占锁。</p>

<p>对读写锁也需要初始化和销毁操作。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;

int pthread_rwlock_init(pthread_rwlock_t rwlock, pthread_rwlockattr_t * attr);
int pthread_rwlock_destory(pthread_rwlock_t *rwlock);
</code></pre>

<p>读写锁加锁操作</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

// 实现读写锁的时候，可能会对共享模式下可获取的锁进行数量限制，因此要检查pthread_rwlock_rdlock()的返回值。
</code></pre>

<h2>条件变量</h2>

<p>mutex阻止了多个线程同时访问共享的变量。
条件变量允许一个线程在共享的变量状态改变的时候通知其他线程这个改变，并允许其它线程等待（block）这个通知。</p>

<p>下面代码，没有使用条件变量，只是使用互斥量来实现，来证明在特定情况下，条件变量的用处。</p>

<pre><code class="c">static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; 
static int avail = 0;  // 表示可消费的数目

// 在生产线程中的代码

s = pthread_mutex_lock(&amp;mtx);
if (s != 0)
    errExitEN(s, "pthread_mutex_lock");

avail++; /* 仅仅表示有可用资源，其它步骤省略*/

s = pthread_mutex_unlock(&amp;mtx); 

if (s != 0)
    errExitEN(s, "pthread_mutex_unlock");

// 在主线程中，主要用来消费生产线程生产的数据

for (;;) {
    s = pthread_mutex_lock(&amp;mtx);
    if (s != 0)
        errExitEN(s, "pthread_mutex_lock");

    while (avail &gt; 0) { /* 消耗生产的数据 */ 
        /* 用生产的数据做一些其它时期 */
        avail--;
    }
    s = pthread_mutex_unlock(&amp;mtx); 
    if (s != 0)
        errExitEN(s, "pthread_mutex_unlock");
}
</code></pre>

<p>上面用互斥量实现的生产者消费者同步代码，问题有：</p>

<ol>
<li>空耗CPU，会一直持续循环来检查avail的状态</li>
</ol>


<p>条件变量解决了这个问题，允许消费进程在没有数据的时候挂起（wait），当有数据的时候通知线程。</p>

<p>条件变量通常与互斥量联合使用：</p>

<ul>
<li>互斥量保护共享变量的修改</li>
<li>条件变量则用来通知状态的修改</li>
</ul>


<p>条件变量在使用前必须初始化，跟互斥量一样，既可以静态初始化，也可以动态初始化。</p>

<pre><code class="c">// 静态
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// 动态，pthread_cond_t变量是动态分配的。需要调用下面函数

#include &lt;pthread.h&gt;
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

int pthread_cond_destroy(pthread_cond_t *cond);
</code></pre>

<h2>基于条件变量的通知和等待</h2>

<p>条件变量的主要操作就是signal（通知）和wait（等待），通知可以一次给一个线程通知，也可以广播给所有等待线程。
wait操作是等待，直到有通知到来。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
const struct timespec *abstime);
</code></pre>

<p>下面代码是使用条件变量的典型代码：</p>

<pre><code class="c 消耗线程代码">
pthread_mutex_lock(&amp;mutex);         /* 锁住互斥量          */
while (!predicate) {                    /* 检查 predicate      */
    pthread_cond_wait(&amp;condvar,&amp;mutex);   /* go to sleep - recheck pred on awakening    */

}
pthread_mutex_unlock(&amp;mutex); 
</code></pre>

<p>pthread_cond_wait() 做了以下事情：</p>

<ul>
<li>释放互斥量的锁</li>
<li>让线程进入休眠状态（sleep）</li>
</ul>


<p>当某个线程进入休眠状态，需要有其它线程唤醒它，这就是生产线程：</p>

<pre><code class="c 生产线程">
pthread_mutex_lock(&amp;mutex);                 /* 锁住互斥量       */
predicate=1;                                /* 设置 predicate    */
pthread_cond_broadcast(&amp;condvar);           /* 唤醒每一个等待条件变量的线程     */
pthread_mutex_unlock(&amp;mutex);               /* 解锁互斥量     */
</code></pre>

<p>这里，重要的调用是pthread_cond_broadcast()，他会唤醒每一个等待条件变量的线程。第一个被唤醒的线程还是处于pthread_cond_wait函数调用中。然后，pthread_cond_wait完成了下面操作：</p>

<ul>
<li>重新获得互斥量锁。</li>
</ul>


<p>然后执行就再次检查predicate。</p>

<h3>条件变量实际例子（join任何终止的线程）</h3>

<p>使用pthread_join仅仅可以等待一个指定的线程，并没办法join任何终止的线程。使用条件变量可以实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(信号)]]></title>
    <link href="http://baren.github.io/blog/2014/06/24/signal/"/>
    <updated>2014-06-24T20:00:20+08:00</updated>
    <id>http://baren.github.io/blog/2014/06/24/signal</id>
    <content type="html"><![CDATA[<h1>信号概念</h1>

<p>信号是软中断，提供了一种处理异步事件的方法</p>

<p>关于信号：</p>

<ul>
<li>每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中</li>
<li>产生信号的条件

<blockquote><ul>
<li>用户按终端键，印发终端产生信号</li>
<li>硬件异常产生信号，比如无效的内存引用，除数为0等</li>
<li>进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）</li>
<li>用户用kill命令给进程发送信号</li>
<li>当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。</li>
</ul>
</blockquote></li>
</ul>


<!-- more -->


<p>几种处理信号的方式</p>

<ul>
<li>忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的</li>
<li>捕捉信号——需要注册一个信号处理函数</li>
<li>执行默认操作——大多数的信号的默认动作是终止信号</li>
</ul>


<h1>signal函数</h1>

<p>unix系统提供了两个改变信号处理的方式：signal和signalaction函数</p>

<p>现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。</p>

<pre><code>void (*signal(int sig, void (*func)(int)))(int)
// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址
</code></pre>

<p>signal函数太复杂，可以使用typedef类型定义简化一下：</p>

<pre><code>typedef void Sigfunc(int);

Sigfunc *signal(int Sigfunc *func);
</code></pre>

<p>一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：</p>

<pre><code>#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针
</code></pre>

<p>可以使用这几个预定义函数常量，来判断信号捕获程序。</p>

<p>关于信号处理程序，注意点：</p>

<ul>
<li>只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误</li>
<li>SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31</li>
<li>kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的</li>
</ul>


<h1>中断的系统调用</h1>

<h2>中断低速系统调用</h2>

<p>若进程调用了一个低速的系统调用，</p>

<p>并且这个系统调用正在阻塞</p>

<p>此时，</p>

<p>捕捉到一个信号。</p>

<p>结果是：该系统调用就被中断不被执行了。</p>

<p><em>注意</em>：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用</p>

<p>低速系统调用是可能是进程阻塞的系统调用，一般包括</p>

<ul>
<li>读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞</li>
<li>打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）</li>
<li>pause和wait，pause会使调用进程一直休眠，指导捕获一个信号</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数</li>
</ul>


<p>这个需要注意的是，磁盘IO操作并不是低速系统调用。</p>

<h2>低速系统调用被中断后的处理和重启</h2>

<p>一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。</p>

<p>这样我们就能够处理这种失败。有两种处理方式：</p>

<ul>
<li>系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作</li>
<li>某些中断的系统调用支持自动重启动</li>
</ul>


<h3>手动检查</h3>

<p>比如可以这样处理：</p>

<pre><code>while((cnt=read(fd, buf, BUF_SIZE)) == -1 &amp;&amp; errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
    continue;  // 啥也不做

if (cnt == -1)  // read读取错误，而不是被中断
    errExit("read");  
</code></pre>

<p>如果经常使用这种检查，还可以定义一个宏：</p>

<pre><code>#define NO_EINTR(stmt)  while((stmt) == -1 &amp;&amp; errno == EINTR);

// 然后

NO_EINTR(cnt == read(fd, buf, BUF_SIZE));

if (cnt == -1)  // read读取错误，而不是被中断
    errExit("read");  
</code></pre>

<h3>自动重启动</h3>

<p>为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：</p>

<pre><code>wait waitpid read write ioctl readv writev
</code></pre>

<p>如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。</p>

<h1>可重入函数</h1>

<p>在信号处理程序中，不能调用不可重入函数。</p>

<p>所谓不可重入函数是指：</p>

<ol>
<li>它们使用了静态数据结构或全局变量</li>
<li>调用malloc和free，因为malloc维护了一个全局链表</li>
<li>标准IO函数</li>
</ol>


<p>而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数</p>

<p>在标准C函数库中，不可重入函数比较普遍。</p>

<p>比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。</p>

<h1>可靠信号的术语和语义</h1>

<ul>
<li>递送（delivery）信号：当引发信号的事件<em>发生</em>时，为进程产生一个信号（或向进程产生一个信号）</li>
<li>未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的</li>
</ul>


<p>进程可以设置阻塞信号。</p>

<p>若信号被进程设置为阻塞，并且对该信号的动作是系统<strong>默认动作</strong>或<strong>捕捉该信号</strong>，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。</p>

<p>解除未决状态：
    * 对信号解除了阻塞
    * 或者将此信号的动作改为忽略。</p>

<p>注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;stdio.h&gt;
void sig_int(int sig);
int main(int argc, char **argv)
{
    sigset_t osig;
    sigset_t newsig, o_set;

    sigemptyset(&amp;newsig);
    sigaddset(&amp;newsig, SIGINT);
    // if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
    if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
    {
        printf("signal sigint err!\n");
        exit(-1);
    }
    if (sigprocmask(SIG_SETMASK, &amp;newsig, &amp;osig) == -1)
    {
        printf("sigprocmask err!\n");
        exit(-1);
    }
    //pause();
    sleep(4);

    if (signal(SIGINT, sig_int) == SIG_ERR)
    {
        printf("signal sigint 1 err!\n");
        exit(-1);
    }
    if (sigprocmask(SIG_SETMASK, &amp;osig, NULL) == -1)
    {
        printf("sigprocmask 1 err!\n");
        exit(-1);
    }
    printf(" pause ...\n");
    sigprocmask(0, NULL, &amp;o_set);
    if (sigismember(&amp;o_set, SIGINT))
    {
        printf("is mask\n");
    }
    return 0;
}
void sig_int(int sig)
{
    printf("int sig hand\n");
}
</code></pre>

<p>执行结果是：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果是默认处理，在sleep过程中，产生中断信号，结果是：
</span><span class='line'>$ ./test_pend
</span><span class='line'>^Cint sig hand
</span><span class='line'> pause &hellip;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt; 如果改成忽略，在sleep过程中，产生中断信号，结果是：
</span><span class='line'> ./test_pend
</span><span class='line'>^C pause &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。</p>

<h1>kill和raise函数</h1>

<p>kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号</p>

<pre><code>#include &lt;signal.h&gt;

int kill(pid_t pid, int signo);
int raise(int signo);
</code></pre>

<p>下面是等价的：</p>

<p>raise(signo) == kill(getpid(), signo)</p>

<p>kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid &lt; 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。</p>

<p>上面提到了，给其它进程发信号需要权限，具体是指：</p>

<ul>
<li>超级用户可以将信号发送给任一进程</li>
<li>非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID</li>
</ul>


<p>注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH</p>

<h1>alarm和pause函数</h1>

<p>alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程</p>

<pre><code>#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int seconds);
</code></pre>

<p>对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的</p>

<p>pause函数使调用进程挂起直到捕捉到一个信号</p>

<pre><code>#include &lt;unistd.h&gt;
int pause(void)
</code></pre>

<p>条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR</p>

<h2>使用alarm实现sleep函数，并暴露问题</h2>

<p>使用信号时，需要精细而周到的考虑，下面代码列出几个问题：</p>

<ul>
<li>问题1：竞争条件</li>
</ul>


<p>看下面的sleep1的实现：</p>

<pre><code>unsigned int sleep1(unsigned int nsecs)
{
    if(signal(SIGABRT, sig_alarm) == SIG_ERR)
    {
        printf("can't signal alarm!\n");
        return nsecs;
    }
    alarm(nsecs);
    pause();
    return (alarm(0)); // 返回未完成的时间
}

void sig_alarm(int signo)
{
    ;
}
</code></pre>

<p>这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。</p>

<ul>
<li>问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序</li>
</ul>


<p>使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。</p>

<p>第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：</p>

<pre><code>
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;setjmp.h&gt;

void sig_alarm(int signo);
static jmp_buf env_alrm;
int sleep2(int);
int main(int argc, char **argv)
{
    sleep2(2);
    exit(0);
}

int sleep2(int sec)
{

    if(signal(SIGALRM, sig_alarm) == SIG_ERR)
    {
        printf("sigalarm err!\n");
        return sec;
    }
    if(setjmp(env_alrm) == 0)
    {
        alarm(sec);
        pause();
    }
    return (alarm(0));
}

void sig_alarm(int signo)
{
    longjmp(env_alrm, 1);
}
</code></pre>

<p>这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。</p>

<h2>除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限</h2>

<p>下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;unistd.h&gt;

int read_timeout(int fd, void *buf, size_t size, int timeout);

static jmp_buf env_alarm;
void sig_alarm(int signo);
int main(int argc, char **argv)
{
    char line[100];
    int n;
    n = read_timeout(STDIN_FILENO, line, 100, 3);
    if(n &lt; 0)
    {
        printf("read timeout\n");
    } else {
        printf("read len %d.\n", n);
    }
    exit(0);
}
int read_timeout(int fd, void *buf, size_t size, int timeout)
{
    int n = 0;
    if(signal(SIGALRM, sig_alarm) == SIG_ERR)
    {
        printf("sig alarm err\n");
        return -1;
    }
    if(setjmp(env_alarm) == 0)
    {
        alarm(timeout);
        if((n=read(fd, buf, size)) &lt; 0)
        {
            printf("read err!\n");
            return n;
        }
        alarm(0);
        return n;
    }
    return -1;
}

void sig_alarm(int signo)
{
        longjmp(env_alarm, 1);
}
</code></pre>

<p>执行结果：</p>

<pre><code>user@usertekiMacBook-Pro unix_test$ ./read_timeout
read timeout
user@usertekiMacBook-Pro unix_test$
user@usertekiMacBook-Pro unix_test$ ./read_timeout
dd
read len 3.
</code></pre>

<p>注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。</p>

<h1>信号集</h1>

<p>可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数</p>

<pre><code>#include &lt;signal.h&gt;

int sigempty(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
    // 四个函数返回值：成功，返回0，失败返回-1
int sigismember(const sigset_t *set, int signo);
    // 若真，返回1，假，返回0，出错，返回-1
</code></pre>

<h1>sigpromask函数</h1>

<p>调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。</p>

<pre><code>#include &lt;signal.h&gt;

int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1
</code></pre>

<ul>
<li>oset非空，则进程当前信号屏蔽字通过oset返回</li>
<li>set非空，则根据第一个参数how指示如何修改当前信号屏蔽字</li>
<li>set为空，不改变</li>
</ul>


<p>how的值：</p>

<ul>
<li>SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集</li>
<li>SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集</li>
<li>SIT_SETMASK: 被set指向的值替代</li>
</ul>


<h1>sigpending函数</h1>

<p>sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。</p>

<pre><code>#include &lt;signal.h&gt;

int sigpending(sigset_t *set);
</code></pre>

<p>注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。</p>

<p>例子：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

void sig_quit(int);

int main(int argc, char **argv)
{
    sigset_t oldset, newset, quitset;
    sigemptyset(&amp;quitset);
    sigaddset(&amp;quitset, SIGINT);

    // ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
    if (signal(SIGINT, sig_quit) == SIG_ERR)
    {
        printf("sig err\n");
        exit(-1);
    } 
    // ************

    if (sigprocmask(SIG_BLOCK, &amp;quitset, &amp;oldset) == -1)
    {
        printf("mask sig err!\n");
        exit(0);
    }
    // sleep 5 seconds
    sleep(5);
    if (sigpending(&amp;newset) == -1)
    {
        printf("pending err \n");
        exit(0);
    }
    if (sigismember(&amp;newset, SIGINT))
        printf("sigquit is block\n");

    if (sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1)
    {
        printf("mask ret sig err!\n");
        exit(0);
    }
    printf("sig int unblock\n");
    sleep(5);
    return 0;
}

void sig_quit(int signo)
{
    printf("sigquit catch\n");

    if (signal(SIGINT, sig_quit) == SIG_ERR)
    {
        printf("sig err\n");
        exit(-1);
    }
}
</code></pre>

<h1>sigaction函数</h1>

<p>sigaction函数的功能是<em>检查</em>或<em>修改</em>与指定信号相关联的处理动作（或同时执行）。</p>

<pre><code>#include &lt;signal.h&gt;

int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
// 成功，返回0，出错返回-1
</code></pre>

<p>对于参数：</p>

<ul>
<li>signo是信号</li>
<li>act非空，则修改信号动作</li>
<li>oact非空，则由oact返回上一个动作</li>
</ul>


<p>结构体struct sigaction的定义：</p>

<pre><code>
struct sigaction {
    void (*sa_handler)(int); // 信号处理函数的地址，或者SIG_IGN或SIG_DFL
    sigset_t sa_mask; // 额外需要阻塞的信号集
    int sa_flags;  // 信号选项，可以设置这个选项来控制处理函数行为

    /*替换的处理程序，当指定sa_flags为SA_SIGINFO时，采用这个处理函数，提供了额外的一些信息*/
    void (*sa_sigaction)(int, siginfo_t *, void *);
}
</code></pre>

<p>若更改信号处理函数，则：
* sa_handler指定处理函数的地址
* sa_mask则是信号集，在调用该信号处理函数之前，会先把这个信号集指定的信号加到进程的信号屏蔽字中。信号处理函数返回时，再复原。在信号处理程序被调用时，操作系统建立的新信号屏蔽字也包括正在被递送的信号，这会保证在当前信号处理时，这个信号再次发生，会一直阻塞，直到处理函数完成。
* sa_flags字段指定对信号处理的各个选项:</p>

<blockquote><ul>
<li>SA_RESTART:由此信号中断的系统调用自动重新启动</li>
<li>SA_INTERRUPT: 由此信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 有此选项对信号，会调用sa_sigaction函数，此函数会给额外提供了附加信息：1）指向siginfo结构的指针；2）指向进程上下文标识符的指针</li>
</ul>
</blockquote>

<p>注意：</p>

<blockquote><p>除了那些为了兼容而继续保留原始的signal函数的语义的系统外，大部分系统都是用sigaction来实现signal函数的。</p></blockquote>

<h1>sigsetjmp和siglongjmp函数</h1>

<p>在捕捉到一个信号时，会进入信号捕捉函数，此时会发生：</p>

<ul>
<li>进入信号处理函数时，当前信号会被自动加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序</li>
<li>当正常从信号处理函数中返回时，会自动恢复当前信号为非屏蔽</li>
</ul>


<p>但是，当在信号处理函数内，调用了longjmp函数，那么是否恢复这个被屏蔽的当前信号？</p>

<p>FreeBSD 5.2.1 和Mac OS X10.3中，setjmp和longjmp保持和恢复信号屏蔽字</p>

<p>Linux2.4.22和Solaris9 并不执行这种操作。FreeBSD 5.2.1 和Mac OS X10.3提供函数<em>setjmp和</em>longjmp，他们不保存和恢复信号屏蔽字</p>

<p>为了允许两种形式的行为存在， POSIX.1并没有说明setjmp和longjmp对屏蔽字的作用，而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部跳转是，使用这两个。</p>

<pre><code>#include &lt;setjmp.h&gt; // 与setjmp和longjmp一个头

int sigsetjmp(sigjmp_buf env, int savemask); // 直接调用，返回0，若从siglongjmp调用返回，则返回非0值

void siglongjmp(sigjmp_buf env, int val);
</code></pre>

<p>若savemask非零，则env保存进程的当前屏蔽字。并在siglongjmp调用时，恢复由env保存进程的当前屏蔽字。</p>

<p>涉及到信号时，使用sigsetjmp和siglongjmp的典型使用模板是：</p>

<pre><code>static sigjmp_buf;
static volatile sig_atomic_t canjump;


....

// 在主函数中
if (sigsetjmp(jmpbuf, 1)) {
    ....
}

canjump = 1; // 调用sigsetjmp后才设置canjump为非零



// 然后，在信号处理程序中，这样：
void sig_handler(int) {}

if (canjmp == 0) // 只有非零时，才调用siglongjmp
    return

....

siglongjmp(jmpbuf, 1);


} 
</code></pre>

<blockquote><p>原因：
之所以使用canjump，主要是保护机制，防止当jmpbuf还没有被sigsetjmp初始化时，就调用了信号处理程序。
在非信号环境下没有问题，但在信号环境下，信号是随时发生的，因此需要保护</p></blockquote>

<h1>sigsuspend函数</h1>

<p>屏蔽进程的信号，使用这种技术，可以保护不希望由信号中断的代码临界区。然后在临界区之后等待以前的信号发生。</p>

<p>但是下面的实现方式有问题：</p>

<pre><code>sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);

// .....临界区代码

1) sigprocmask(SIG_BLOCK, &amp;oldmask, NULL);
2) pause(); // 等待之前阻塞的信号发生
</code></pre>

<p>上面代码，1）和2）代码出有问题，会有竞争条件，在sigprocmask和pause之间有可能信号会发生，这会导致pause无法返回，永远阻塞。</p>

<p>解决这个竞争条件的办法就是让这两个操作合并成一个原子操作。这就是sigsuspend函数的由来。</p>

<pre><code>
#include &lt;signal.h&gt;

int sigsuspend(const sigset_t * sigmask);
</code></pre>

<p>用sigsuspend实现临界区代码，可以这样：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/signal.h&gt;

void sig_int(int signo);

int main(int argc, char **argv)
{

    sigset_t newsigset, oldsigset, waitsigset;
    sigemptyset(&amp;newsigset);
    sigaddset(&amp;waitsigset, SIGUSR1);
    struct sigaction act;
    act.sa_handler = sig_int;

    if(sigaction(SIGINT, &amp;act, NULL) &lt; 0)
    {
        printf("siganction err.\n");
        exit(-1);
    }
    if(sigprocmask(SIG_BLOCK, &amp;newsigset, &amp;oldsigset) &lt; 0)
    {
        printf("sigprocmask err\n");
        exit(-1);
    }
    // code procted
    printf("this is procted code!\n");

    if(sigsuspend(&amp;waitsigset) != -1)
    {
        printf("sigsuspend err\n");
        exit(-1);
    }
    printf("after sigsuspend\n");
    if(sigprocmask(SIG_SETMASK, &amp;oldsigset, NULL) &lt; 0)
    {
        printf("revert old sig mask err\n");
        exit(-1);
    }

    return 0;
}

void sig_int(int signo)
{
    printf("catch signo %d\n", signo);
}
</code></pre>

<p>注意sigsuspend函数实现的巧妙之处：</p>

<ul>
<li>为了实现解除屏蔽（sigprocmask）和等待（pause），sigsuspend把进程的屏蔽信号设置为参数信号，并在返回后设置为调用sigsuspend之前的屏蔽信号值。</li>
</ul>


<p>sigsuspend函数还有两种经典应用：</p>

<ol>
<li>等待一个信号处理程序设置一个全局变量</li>
<li>父子进程实现同步</li>
</ol>


<p>注意：在实现父子进程通讯，可以使用kill给对象发信号，并使用sigsuspend等待某种条件</p>

<h1>abort函数</h1>

<p>abort函数使异常程序终止。</p>

<pre><code>#include &lt;stdlib.h&gt;

void abort(void);
</code></pre>

<p>这个函数将SIGABRT信号发送给调用进程。</p>

<p>ISO C规定 abort的实现须向主机环境递送一个成功的通知，一般是通过raise(SITABRT)或kill(gitpid(), SIGABRT)实现，这个规定，允许程序做清理工作。</p>

<p>一般系统的abort实现，都会冲洗输出流以及是否要删除临时文件。</p>

<p>可以看一下abort的函数实现示例，通过这个示例，学会：</p>

<ul>
<li>sigaction函数的使用</li>
<li>kill函数的使用：kill函数可以给其它进程发送信号。若发给本进程，并且此信号是不被阻塞的，那么kill返回之前，该信号（或某个未决、未阻塞的信号）就被传送给了该进程。这样，kill返回了，就知道该进程一定捕捉到该信号。</li>
</ul>


<h1>system函数</h1>

<p>ISO C定义了system函数，这个函数可以执行系统命令，这个函数的实现也牵扯到信号问题。若不处理，会有问题。</p>

<p>这里通过system的实现，注意信号程序开发的各种问题。</p>

<p>看下面调用过程：
<img src="/images/assets/Figure10-1.png" title="time-function" alt="alt text" /></p>

<p>若没有处理信号，问题有：</p>

<ul>
<li>若进程（a.out）捕获SIGCHID信号，当system创建的子进程结束，系统会向父进程（a.out）发送SIGCHID信号，父进程会捕捉。<em>但这阻止了system函数获取它自己创建子进程的状态</em></li>
<li>若system系统没有屏蔽中断和退出信号，则如果想给shell调用程序发送中断信号时，系统会同时向负责进程发送信号（因为都属于前台进程组）</li>
</ul>

]]></content>
  </entry>
  
</feed>
