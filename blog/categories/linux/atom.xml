<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Baren Blog]]></title>
  <link href="http://baren.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2014-10-24T21:10:41+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[daemon简介]]></title>
    <link href="http://baren.github.io/blog/2014/10/20/daemon/"/>
    <updated>2014-10-20T21:09:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/10/20/daemon</id>
    <content type="html"><![CDATA[<p>要理解daemon，需要了解</p>

<ul>
<li>进程组</li>
<li>会话</li>
<li>控制终端</li>
<li>SIGHUP信号（kill -HUP）</li>
<li>fg和bg命令</li>
<li>使用nohup使进程变为后台进程</li>
<li>一个命令后采用“&amp;”使之在后台执行</li>
</ul>


<p>等这些相关知识。</p>

<!-- more -->


<h1>外围知识</h1>

<h2>进程组</h2>

<p>进程组是一个或多个具有共同进程组ID的进程集。
进程组的特点是：</p>

<ul>
<li>进程组的首进程是创建了进程组的进程，并且进程组的进程ID与进程组ID相等</li>
<li>子进程会继承父进程的进程组ID</li>
<li>进程组有生命周期，从进程创建进程组开始，到最后一个进程离开进程组结束</li>
</ul>


<h2>会话</h2>

<p>一个会话是进程组的集合。</p>

<p>一个进程是否属于一个会话是靠进程的进程会话ID，</p>

<ul>
<li>一个会话头进程是创建会话的进程，会话ID与进程的进程ID一样</li>
<li>子进程继承父进程的会话ID</li>
</ul>


<h2>进程组、会话与控制终端</h2>

<ul>
<li>所有的会话中的进程共享一个控制终端。</li>
<li>控制终端的建立是当会话的首进程第一次打开控制终端时。</li>
<li>如果一个会话有控制终端，那么在一个时刻，一个会话中，只有一个进程组是前台进程。其它进程组都是后台进程组</li>
<li>只有前台进程组中的进程可以从控制终端中读取输入。</li>
<li>当在控制终端输入终端字符（Control-C）生成SIGINT信号，并发送给前台进程组中的所有进程</li>
<li>会话首进程对于控制终端来说是控制进程，如果与控制终端断开，内核会给控制进程发送SIGHUP信号。</li>
</ul>


<p>会话进程组控制终端之间关系的例子：</p>

<pre><code>$ echo $$
400
$ find / 2&gt; /dev/null | wc -l &amp; 
[1] 659
$ sort &lt; longlist | uniq -c
</code></pre>

<p>图示：
<img src="/images/assets/session_crt.png" title="linux" alt="alt text" /></p>

<h2>SIGHUP信号</h2>

<p>当控制进程与控制终端连接断开时，内核会发送SIGHUP信号给控制进程。SIGHUP的默认动作是终止进程。</p>

<p>会发生以下事情：</p>

<ul>
<li>如果控制进程是shell，他会建立处理SIGHUP信号的函数，在终止之前，会发送SIGHUP信号给它自己创建的每一个作业。</li>
<li>控制终端的控制进程停止时，内核断开会话内的所有进程与控制终端的连接。</li>
</ul>


<h1>daemon进程</h1>

<p>一个daemon是一个进程，具有以下特征：</p>

<ul>
<li>长时间运行的</li>
<li>在后台运行，并没有控制终端。没有控制终端，保证了内核不会为daemon进程生成任何作业控制或者终端相关信号（SIGINT, SIGTSTP, 和 SIGHUP）</li>
</ul>


<p>系统的一些daemon进程：</p>

<ul>
<li>cron：在指定时间执行任务的后台进程</li>
<li>sshd: secure shell进程</li>
<li>inetd：后台进程，监听在特定TCP/IP端口进来的网络连接，并启动相应的程序处理连接</li>
</ul>


<h2>创建一个daemon</h2>

<p>创建一个daemon有一些固定的步骤和流程。</p>

<ol>
<li>fork，然后父进程退出。

<blockquote><p>这样的好处是：</p></blockquote></li>
</ol>


<blockquote><p>1 fork后的子进程的父进程的父进程就成了init。</p>

<p>2 如果该守护进程是从shell启动，父进程退出，会让shell认为这条命令执行完成</p>

<p>3 保证子进程不是组长进程</p></blockquote>

<ol>
<li>进程独立，调用setsid函数</li>
</ol>


<blockquote><p>因为所有会话中的进程会共享同一个控制终端，（控制进程的子进程，都会继承这个控制终端），具有控制终端的进程都会收到控制终端发出的信号，因此，必须让daemon与控制终端分离。</p>

<p>调用setsid()函数使daemon独立，这会让进程处在一个新的会话和进程组中，并与控制终端分离</p></blockquote>

<ol>
<li>关闭不需要的文件描述符。

<blockquote><p>根据函数确认进程可拥有的最大进程描述符的值，一个个关闭，比如：</p></blockquote></li>
</ol>


<blockquote><p>for (i=getdtablesize();i>=0;&ndash;i) close(i); /<em> close all descriptors </em>/</p>

<p>有些标准库程序会读或者写入标准IO，可能会发生在终端或者文件中，因此最好也重定向标准IO无害设备上，比如/dev/null。</p>

<p>i=open(&ldquo;/dev/null&rdquo;,O_RDWR); /<em> open stdin </em>/</p>

<p>dup(i); /<em> stdout </em>/</p>

<p>dup(i); /<em> stderr </em>/</p></blockquote>

<ol>
<li>修改创建文件屏蔽字</li>
</ol>


<blockquote><p>有时候daemon会保护他创建的文件，因此会回收组写和其它写功能，</p>

<p>umask(027)</p></blockquote>

<ol>
<li>将当前工作目录改成根目录</li>
</ol>


<blockquote><p>好处方便查到程序的一些配置文件等</p>

<p>如果进程的工作目录是“/”，那么将不能使用unmount来卸载文件系统，因为unmount两种条件下出错：有打开的文件和在有执行的后台进程，其工作目录处于文件系统中</p>

<p>比如：chdir(&ldquo;/servers/&rdquo;);</p></blockquote>

<ol>
<li>设置排他性，只有一个进程运行</li>
</ol>


<blockquote><p>比如cron进程，肯定只需要一个就够了。</p>

<p>文件锁方法对于排他性执行是个好方法。</p></blockquote>

<ol>
<li>捕获信号</li>
</ol>


<blockquote><p>进程可以从用户和进程收到信号，最好是捕获信号并做处理。</p>

<p>子进程终止时，会给父进程发送SIGCHLD信号，daemon要么忽略要么处理这个信号</p>

<p>许多服务进程使用hang-up信号来重启服务。用这个信号来重启是哥不错的主意。</p></blockquote>

<ol>
<li>记录日志

<blockquote><p>可以指定一个日志文件</p></blockquote></li>
</ol>


<blockquote><p>使用log服务（syslogd守护进程提供）</p></blockquote>

<p>参考：<a href="http://www.enderunix.org/docs/eng/daemon.php">http://www.enderunix.org/docs/eng/daemon.php</a></p>

<h2>使用SIGHUP重新初始化daemon进程</h2>

<p>大部分daemon都是一直执行直到系统关闭。
但是，如果想重新初始化进程而又不想停止进程再重启（重新读取配置文件）。可以使用SIGHUP信号来实现。通过捕获这个信号来完成相应初始化逻辑。</p>

<p>SIGHUP信号是当控制进程与控制终端断开时，发送给控制进程的。由于daemon没有控制终端，因此内核不会给daemon进程发送SIGHUP信号。因此daemon可以使用这个信号来完成这个处理功能。</p>

<h2>daemon的日志</h2>

<p>只需要记住这个图就可以。</p>

<p><img src="/images/assets/daemon-log.png" title="linux" alt="alt text" /></p>

<p>/etc/syslog.conf文件控制的syslogd的日志控制。格式是：</p>

<hr />

<p>facility.level  action</p>

<hr />

<p>其中facility和level是选择器，action决定的消息被发送到的地方。</p>

<p>facility可以是：</p>

<table>
<thead>
<tr>
<th> facility        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_AUTH     </td>
</tr>
<tr>
<td> LOG_AUTHPRIV     </td>
</tr>
<tr>
<td> LOG_CRON     </td>
</tr>
<tr>
<td> LOG_DAEMON     </td>
</tr>
<tr>
<td> LOG_FTP     </td>
</tr>
<tr>
<td> LOG_MAIL     </td>
</tr>
<tr>
<td> LOG_NEWS     </td>
</tr>
<tr>
<td> LOG_SYSLOG     </td>
</tr>
<tr>
<td> LOG_USER     </td>
</tr>
<tr>
<td> LOG_KERN     </td>
</tr>
<tr>
<td> 等     </td>
</tr>
</tbody>
</table>


<p>level可以是：</p>

<table>
<thead>
<tr>
<th> level        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_EMERG     </td>
</tr>
<tr>
<td> LOG_ALERT     </td>
</tr>
<tr>
<td> LOG_CRIT     </td>
</tr>
<tr>
<td> LOG_ERR     </td>
</tr>
<tr>
<td> LOG_WARNING     </td>
</tr>
<tr>
<td> LOG_NOTICE     </td>
</tr>
<tr>
<td> LOG_INFO     </td>
</tr>
<tr>
<td> LOG_DEBUG     </td>
</tr>
</tbody>
</table>


<p>比如
<code>
*.LOG_ERR                       /dev/tty10 所有的错误发到控制终端
auth.notice                     root # 发送到root登陆的控制台或终端
*.debug;mail.none;news.none     -/var/log/messages
</code></p>

<p>一行可以包含多个选择器，用分号分割。*.debug;mail.none;news.</p>

<p>none表示所有的debug信息，但是拍出mail和news的信息。-/var/log/messages前面有个“-”表示不需要每次写入都同步到磁盘，这使的写入速度快。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread 进一步细节]]></title>
    <link href="http://baren.github.io/blog/2014/09/28/pthread-further-details/"/>
    <updated>2014-09-28T20:43:21+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/28/pthread-further-details</id>
    <content type="html"><![CDATA[<h1>线程和信号</h1>

<p>信号的设计实现早于线程，导致线程与信号之间有许多冲突。冲突的地方主要在于：</p>

<ul>
<li>既要维护传统的在单线程进程环境下的信号语义</li>
<li>同时又要开发符合多线程进程环境下的信号程序</li>
</ul>


<!-- more -->


<h2>信号模式怎样映射到线程</h2>

<p>需要弄清楚信号的哪些方面是进程级别的，哪些方面是针对特定线程的。说明：</p>

<ul>
<li>信号动作是<em>进程</em>级别的。这意味着一个默认动作是终止进程的信号被内核递送到进程的任意线程，所有的进程内的线程都会终止。</li>
<li>信号处理是<em>进程</em>级别的。进程内的所有线程都共享同一个信号处理器。如果一个线程使用sigaction()建立的信号处理器，进程内的任意线程如果收到这个信号，都会调用这个处理器；如果一个线程设置了忽略某个信号，其它线程也自动忽略</li>
<li>如果信号递送给一个多线程的进程时，内核会随机选取一个线程，用来递送信号和执行信号处理程序。</li>
<li>屏蔽信号是基于线程的。线程可以使用pthread_sigmask()来屏蔽某些信号。</li>
<li>内核维护了针对进程的一个全局的阻塞（pending）的信号集；也维护了针对每个线程的阻塞的信号集。sigpending()函数会返回进程的全局阻塞的信号集和调用这个函数的线程的阻塞信号集的并集。一个新创建的线程，阻塞的信号集是空。如果一个线程阻塞了一个信号，这个信号一直被阻塞，直到线程取消阻塞或者线程停止。</li>
<li>如果一个信号处理中断了pthread_mutex_lock()调用，这个调用总是会自动启动。如果中断了pthread_cond_wait()，也会自动重启。</li>
</ul>


<p>以下几种情况，信号会递送给特定线程：</p>

<ul>
<li>在某个线程上下文中，执行了一个特定的硬件指令的直接结果，生成信号</li>
<li>线程试图写入到一个终端的pipe文件时，生成一个SIGPIPE</li>
<li>使用pthread_kill() 或 pthread_sigqueue()可以允许同一进程的线程给另一个线程发信号</li>
</ul>


<pre><code class="c">#include &lt;signal.h&gt;
int pthread_kill(pthread_t thread, int sig);

int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
</code></pre>

<h1>线程和进程控制</h1>

<p>就像信号一样exec(), fork(), and exit()也是早于线程。</p>

<h5>线程和exec()</h5>

<p>当任意线程调用exec()函数时，调用的程序会被完全取代。所有的线程，除了调用线程外，都会被终止。不会去执行线程的终止处理函数，属于进程的锁和条件变量都会消失。</p>

<h5>线程和fork()</h5>

<p>多线程环境的进程调用fork()函数，只有调用进程在子进程中复制。其它线程在子进程中会消失，线程特定的析构或者清理函数都不会执行。这会导致严重问题：</p>

<ul>
<li><p>虽然只有调用线程被复制了，但是进程全局状态，还有pthread对象（比如锁和条件变量）等全局对象，都会被复制到子进程。这会导致，如果在fork的同时，有个线程锁住了mutex，并且部分更新了全局数据结构，这种情况下，子进程中的线程将不能够解锁这个mutex。更进一步，子进程中的全局状态可能处于不一致状态。</p></li>
<li><p>由于线程的析构或者清理函数没有被调用，有可能导致子进程的内存泄露。</p></li>
</ul>


<p>由于在多线程环境下调用fork有这么多严重问题，通常的建议是：</p>

<ul>
<li>只有在后续立即调用exec函数的情况下，才会调用fork函数。否则不要调用。</li>
</ul>


<p>如果必须调用fork函数，但是后面不跟着调用exec函数，linux提供了一个这种情况下的解决办法：</p>

<pre><code class="c">pthread_atfork(prepare_func, parent_func, child_func);
</code></pre>

<h1>线程实现模式</h1>

<p>有许多线程实现方式，主要的区别是线程和内核的调度实体（kernel scheduling entities）之间映射的不同。</p>

<p>内核调度实体（kernel scheduling entities）是内核分配CPU和其他资源的单元。在传统的UNIX系统下，内核调用实体与进程是同义的。</p>

<h2>Many-to-one (M:1) 实现，用户级别线程</h2>

<p>在M:1线程实现模式下，所有的线程创建、调度和同步细节都在用户空间下的线程lib包实现。内核不知道关于线程的任何细节。</p>

<p>这种实现有以下几种好处：</p>

<ul>
<li>最大的好处是线程操作非常快速，因为这些全部在用户空间实现，不用切换到内核空间。</li>
<li>移植性好，由于是在用户空间实现的，可以很容易从一个系统移植到另一个系统</li>
</ul>


<p>不好处是：</p>

<ul>
<li>当一个线程调用了一个系统调用（比如read()），控制从用户空间的线程包转到内核，这意味着read()被阻塞了，那么其它线程就全部被阻塞了。</li>
<li>内核不能够调度线程。由于内核不知道线程的存在，因此内核不能调度线程到其它cpu上。</li>
</ul>


<h2>One-to-one (1:1)实现方式</h2>

<p>在1:1实现方式下，一个线程对应一个内核的调度实体。内核单独的处理每个线程的调度。这样，就解决了M:1的重大调度问题。</p>

<p>但是这种实现方式下，也有其它问题：</p>

<ul>
<li>线程的创建同步等操作就比较慢，因为需要切换到内核空间下。</li>
<li>一对一的关系，内核需要为每一个线程维护一个内核调度实体，如果有大量的线程，会降低整体性能。</li>
</ul>


<p>尽管如此，1:1的方式是大多数pthread线程实现的方式。两个linux的pthread实现都是采用1:1的方式</p>

<h2>linux的pthread实现方式</h2>

<p>linux有两种pthread的实现：</p>

<ul>
<li>LinuxThreads: 这是linux的最初实现。Xavier Leroy开发</li>
<li>NPTL (Native POSIX Threads Library): 新的linux下的pthread实现。Ulrich Dreppe（gun c也叫libc的管理者） 和 Ingo Molnar实现。性能比LinuxThreads好，也更符合pthread的规范。</li>
</ul>


<p>在glibc 2.4及其后续版本，不再支持LinuxThreads了。</p>

<h3>LinuxThreads实现细节</h3>

<ul>
<li>使用clone() 系统调用创建一个线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>

<p>这意味着LinuxThreads线程共享虚拟内存、文件描述符、文件相关信息（umask, root directory, and current working directory）和信号处理。</p>

<ul>
<li><p>除了由应用创建的线程，LinuxThreads还创建了额外的管理线程，来处理线程的创建的销毁。</p></li>
<li><p>实现采用了信号来进行内部的操作。</p></li>
</ul>


<p>当内核支持实时信号（Linux 2.2及其以后），前三个实时信号被使用；如果是老的内核，使用 SIGUSR1 and SIGUSR2，这样，应用不能够使用这几个信号。</p>

<p>关于实时信号，参考：
<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7">http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7</a></p>

<h3>NPTL</h3>

<ul>
<li>使用clone() 创建线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>

<ul>
<li><p>使用了前两个实时信号</p></li>
<li><p>不像LinuxThreads，NPTL没有实现管理线程</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[取消线程]]></title>
    <link href="http://baren.github.io/blog/2014/09/25/pthread-cancel/"/>
    <updated>2014-09-25T20:56:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/25/pthread-cancel</id>
    <content type="html"><![CDATA[<p>主要描述POSIX线程的取消机制和更进一步的线程细节，包括线程和信号，线程栈等。</p>

<!-- more -->


<h1>取消一个线程</h1>

<p>使用pthread_cancel函数取消特定的线程：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_cancel(pthread_t thread);
// 返回0表示成功
</code></pre>

<p>pthread_cancel只是发送取消请求，然后立即返回。这意味着调用线程不用等待线程停止。目标线程什么时候停止，取决于目标线程的状态和类型。</p>

<h1>取消状态和类型</h1>

<p>使用pthread_setcancelstate()设置线程的取消状态；使用pthread_setcanceltype()设置线程的取消类型。这两个状态设置线程如何响应取消操作的。</p>

<p>pthread_setcancelstate()函数可设置的状态是：</p>

<ul>
<li>PTHREAD_CANCEL_DISABLE。 线程是不可取消的。这种线程如果接收到一个取消请求，会保持未决（pending）状态直到成为可取消状态</li>
<li>PTHREAD_CANCEL_ENABLE。线程是可取消的，这个状态也是默认的状态。</li>
</ul>


<p>线程在执行一段必须执行完的代码时，设置为不可取消状态，是非常有用的。</p>

<p>pthread_setcanceltype()函数可以设置两种类型：</p>

<ul>
<li>PTHREAD_CANCEL_DEFERRED。线程一直执行直到遇到取消点（特殊函数）。默认类型。</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS。线程可以在任意时间点取消，一般不大永。</li>
</ul>


<h1>取消点</h1>

<p>当一个线程是可取消的并且是延迟的（PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DEFERRED）。取消操作会在线程执行到下一个取消点时起作用。</p>

<p>SUSv3 定义了一组必须是取消点的函数，还定义了一组是可选取消点的函数。</p>

<p>可取消函数列表（略）</p>

<p>对于一个不是分离的线程，必须由其它函数调用pthread_join函数等待这个线程结束。如果这个线程接收了取消请求，并到达了一个取消点，则pthread_join返回的值是PTHREAD_CANCELED.</p>

<p>取消线程的例子：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static void *
threadFunc(void *arg)
{
    int j;
    printf("New thread started\n");
    for (j = 1; ; j++) {
        printf("Loop %d\n", j);
        sleep(1);
    /* NOTREACHED */
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    int s;
    void *res;

    s = pthread_create(&amp;thr, NULL, threadFunc, NULL); 
    if (s != 0)
        errExitEN(s, "pthread_create"); 

    sleep(3);       /* Allow new thread to run a while */

    s = pthread_cancel(thr);
    if (s != 0)
        errExitEN(s, "pthread_cancel");

    s = pthread_join(thr, &amp;res);
    if (s != 0)
        errExitEN(s, "pthread_join");

    if (res == PTHREAD_CANCELED) 
        printf("Thread was canceled\n");

    else
        printf("Thread was not canceled (should not happen!)\n");
    exit(EXIT_SUCCESS);
}
</code></pre>

<h1>测试取消点</h1>

<p>如果线程没有调用这些取消点函数（纯计算线程），为了也能够响应取消请求，可以使用pthread_testcancel()来当取消点。</p>

<pre><code class="c">#include &lt;pthread.h&gt;
void pthread_testcancel(void);
</code></pre>

<h1>清理处理器</h1>

<p>如果一个线程接收到取消请求，执行到一个取消点，则会停止。有可能会导致共享的变量和pthread对象（比如锁）处在不一致状态，可能会导致剩下的线程死锁等异常状态。</p>

<p>为了避免这个问题，需要定义线程结束的清理函数。</p>

<p>每一个线程都有一个线程处理函数栈。当线程被取消时，从上到下依次开始执行清理处理程序。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
void pthread_cleanup_push(void (*routine)(void*), void *arg);
void pthread_cleanup_pop(int execute);
</code></pre>

<blockquote><p>注意：
当线程正常执行完成，不会触发清理处理函数。</p></blockquote>

<p>一般来说，一个清理操作只有在执行一段特殊的代码时被取消时，才会用到。</p>

<p>下面例子在主main函数中创建了一个线程，他分配了一块内存，并锁住了一个互斥锁mtx。因为线程有可能被取消，因此使用pthread_cleanup_push()来安装清理处理函数，这个清理函数主要作用是释放分配的内存，并对互斥锁解锁。</p>

<p>安装完清理处理器后，线程进入所谓的特殊代码段（如果取消，需要走清理处理函数的）。</p>

<p>如果特殊代码段正常执行完成，则调用pthread_cleanup_pop()去掉处理函数。</p>

<p>例子：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"

static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static int glob = 0; /* Predicate variable */

static void         /* Free memory pointed to by 'arg' and unlock mutex */ cleanupHandler(void *arg)
{
    int s;

    printf("cleanup: freeing block at %p\n", arg);
    free(arg);

    printf("cleanup: unlocking mutex\n");
    s = pthread_mutex_unlock(&amp;mtx);
    if (s != 0)
        errExitEN(s, "pthread_mutex_unlock");
}


static void *
threadFunc(void *arg)
{
    int s;
    void *buf = NULL;   /* Buffer allocated by thread */

    buf = malloc(0x10000);
    printf("thread: allocated memory at %p\n", buf);

    s = pthread_mutex_lock(&amp;mtx);   /* Not a cancellation point */ 
    if (s != 0)
        errExitEN(s, "pthread_mutex_lock");

    pthread_cleanup_push(cleanupHandler, buf);

    while (glob == 0) {
        s = pthread_cond_wait(&amp;cond, &amp;mtx);     /* A cancellation point */
        if (s != 0)     
            errExitEN(s, "pthread_cond_wait"); 
    }
    printf("thread: condition wait loop completed\n");
    pthread_cleanup_pop(1);
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    void *res;
    int s;

    s = pthread_create(&amp;thr, NULL, threadFunc, NULL); 
    if (s != 0)
        errExitEN(s, "pthread_create");

    sleep(2);       /* Give thread a chance to get started */

    if (argc == 1) {        /* Cancel thread */
        printf("main: about to cancel thread\n");
        s = pthread_cancel(thr);
        if (s != 0)
            errExitEN(s, "pthread_cancel");
    } else {        /* Signal condition variable */
        printf("main: about to signal condition variable\n");
        glob = 1;
        s = pthread_cond_signal(&amp;cond);
        if (s != 0)
            errExitEN(s, "pthread_cond_signal");
    }

    s= pthread_join(thr, &amp;res); 
    if (s != 0)
        errExitEN(s, "pthread_join"); 

    if (res == PTHREAD_CANCELED)
        printf("main: thread was canceled\n"); 
    else
        printf("main: thread terminated normally\n");

    exit(EXIT_SUCCESS);
}   
</code></pre>

<blockquote><p>注意：
注意上面例子对pthread_cleanup_push()函数的的典型使用</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread control]]></title>
    <link href="http://baren.github.io/blog/2014/09/17/pthread-control/"/>
    <updated>2014-09-17T21:19:03+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/17/pthread-control</id>
    <content type="html"><![CDATA[<h1>线程属性</h1>

<p>在使用pthread_create函数：</p>

<pre><code class="c">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
</code></pre>

<p>创建线程时，第三个参数attr是线程属性。可以使用pthread_attr_t结构来修改线程默认属性。</p>

<p>pthread_attr_t变量需要初始化，需要使用pthread_attr_init函数进行初始化。调用初始化函数后，pthread_attr_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p>

<!-- more -->


<p>pthread_attr_t属性的初始化和销毁接口：</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_attr_init(ptread_attr_t *attr);
int pthread_attr_destory(pthread_attr_t *attr);
</code></pre>

<p>POSIX.1支持的线程属性包括：</p>

<ul>
<li>线程的分离状态属性</li>
<li>线程栈末尾的警戒缓冲区大小</li>
<li>线程栈的最低地址</li>
<li>线程栈的大小</li>
</ul>


<p>如果创建的线程不需要知道线程的终止状态，可以在创建的时候，以分离状态启动。通过设置pthread_attr_t的值为分离状态。设置pthread_attr_t的函数是：</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
</code></pre>

<p>设置分离状态的属性值是：PTHREAD_CREATE_DETACHED</p>

<h1>同步属性</h1>

<p>互斥量、读写锁和条件变量的属性</p>

<h2>互斥量属性</h2>

<p>主要讲互斥量属性的类型属性。类型属性有以下几种：</p>

<ul>
<li>PTHREAD_MUTEX_NORMAL——不检查死锁错误，如果一个线程试图去lock一个他已经锁住的互斥量，则发生死锁。</li>
<li>PTHREAD_MUTEX_ERRORCHECK——提供错误检查</li>
<li>PTHREAD_MUTEX_RECURSIVE——允许同一个线程多同一个互斥量多次加锁。会维持一个加锁计数量。</li>
</ul>


<p>对互斥量，属性初始化和销毁函数是：</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

int pthread_mutex_destroy(pthread_mutex_t *mutex);
</code></pre>

<p>可以通过下面函数设置互斥量属性：</p>

<pre><code class="c">int pthread_mutexattr_gettype(pthread_mutexattr_t *attr, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
</code></pre>

<h2>读写锁属性</h2>

<p>支持进程共享属性</p>

<h2>条件变量属性</h2>

<p>支持进程共享属性</p>

<h1>重入</h1>

<p>在信号处理时，可重入的函数是指函数没有访问静态数据结构，或者没有调用malloc和free等。在线程处理时，函数同样也有重用的概念。</p>

<p>在多线程环境下，一个函数是可重入的，意思是：一个函数在同一时刻可以被多个线程安全调用。</p>

<p>注意与信号的区别
* 一个函数对多线程来说是可重入的，意思是这个函数是线程安全的。
* 但并不意味着对信号处理程序来说该函数是可重入的（比如标准io函数，是线程安全的，会对流加锁保证，但是对信号处理是不可重入的，因为会修改全局数据结构）。</p>

<p>有一个列表，列出了posix.1中不能保证线程安全的函数：</p>

<p><img src="/images/assets/pthread-1.png" title="linux" alt="alt text" /></p>

<p>如果操作系统实现线程安全这一特性时，会同时提供一个对应的线程安全版本。</p>

<p>比如asctime，对应的就是asctime_r，后缀是_r表示可重入。</p>

<p>posix.1还提供了以线程按方式管理FILE对象的方法。</p>

<p>标准IO流的实现，会对流加锁解锁操作，如果频繁调用getc函数，会有性能下降，因为会有频繁的加锁解锁。</p>

<p>为了解决这个问题，posix1.c引入非可重入版本的流函数：</p>

<pre><code class="c">
#include &lt;stdio.h&gt;
int getchar_unlocked(void); 
int getc_unlocked(FILE *fp);

putchar_unlocked(int c);
int putc_unlocked(int c, FILE *fp);
</code></pre>

<p>同时提供了线程安全的方式管理FILE对象的方法：</p>

<pre><code class="c">
#include &lt;stdio.h&gt;
int ftrylockfile(FILE *fp);
void flockfile(FILE *fp); 
void funlockfile(FILE *fp);
</code></pre>

<p>使用非线程安全的流函数版本时，需要用flockfile和funlockfile包围，否则会出现不可预测的问题（因为是非线程安全的）。</p>

<p>好处：</p>

<ul>
<li>一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次数据读写上分摊总的加解锁开销。</li>
</ul>


<h1>线程私有数据</h1>

<p>让一个函数是线程安全的最有效的方式就是让函数是可重入的。新的函数最好这么实现。尽管如此，
一些老的函数，不是线程安全的，如果要将其改造成线程安全函数，需要满足：</p>

<ul>
<li>实现线程安全的</li>
<li>不能改变函数的签名，也就是不需要调用这个函数的程序去修改</li>
</ul>


<p>使用线程私有（thread-specific）数据可以实现。</p>

<blockquote><p>注意：
要理解线程私有数据，以函数的角度考虑问题。</p></blockquote>

<p>线程私有数据允许函数为每一个线程维持一个单独的数据拷贝。如图所示：</p>

<p><img src="/images/assets/pthread-psd.png" title="linux" alt="alt text" /></p>

<p>线程A调用函数myfunc时，myfunc函数为线程A维持一个单独数据，线程B调用myfunc函数时，myfunc为线程B维持一个线程B单独的数据。</p>

<p>线程私有数据有个特点：</p>

<ul>
<li>存储的数据是持久化的，每一份数据会一直存在，这允许函数间共享数据（虽然不推荐）。</li>
</ul>


<h2>从函数角度考虑线程私有数据</h2>

<p>为了更好的理解线程私有数据，需要从函数角度（实现角度）考虑如何使用线程私有数据</p>

<ul>
<li>在线程第一次调用函数时，函数为线程分配独立的存储块。存储块只分配一次，就是在线程第一次调用此函数时。</li>
<li>同一个线程对这个函数的随后的调用，函数能够获取这个第一次调用而分配存储块。因此不能用局部变量存储指向存储块的key；也不能用static变量存储，因为在进程内，只有一个static的实例。</li>
<li>不同的函数可能都需要线程私有数据，因此每个函数都得需要自己的线程私有数据key</li>
<li>当线程停止时，函数不需要控制私有数据，因为停止时，代码有可能已经执行到函数外了。因此需要有个地方来执行清理操作。</li>
</ul>


<h2>线程私有数据 API</h2>

<h3>创建私有数据key</h3>

<p>创建一个key，两个用处：</p>

<ul>
<li>用来获取函数分配的存储块</li>
<li>用来区分其它函数的线程私有数据对应的key</li>
</ul>


<p>使用pthread_key_create函数</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
</code></pre>

<p>destructor指向一个清理函数，用来释放函数内分配的存储块。</p>

<p>其签名是：</p>

<pre><code class="c">void dest(void *value)
{
/* Release storage pointed to by 'value' */ 
}
</code></pre>

<p>线程停止时，并且这个key关联的数据不是NULL时，就会自动调用这个函数来清理。</p>

<p>一般，线程私有数据的实现，使用一个全局数组来存储这个key，这个key有两个状态：</p>

<ul>
<li>是否使用的标记</li>
<li>清理函数指针</li>
</ul>


<p>如图：</p>

<p><img src="/images/assets/pthread-psd-key.png" title="linux" alt="alt text" /></p>

<p>根据图，pthread_key_create()返回的一般是全局数组的索引，数组元素包含两个字段，是否使用字段和清理函数地址字段。</p>

<h3>关联函数分配内存与key</h3>

<p>使用函数pthread_setspecific函数来关联函数分配的存储和pthread_key_create创建的key。</p>

<pre><code class="c">#include &lt;pthread.h&gt;
int pthread_setspecific(pthread_key_t key, const void *value);
// value参数是一个分配的内存的指针
// 当线程停止时，这个值会传给create函数指定的清理函数。
void *pthread_getspecific(pthread_key_t key);
</code></pre>

<p>为了维护线程私有数据，Pthreads API 为每一个线程维护了一个指针数组，数据元素是函数分配的存储的指针。</p>

<p>如下图，假设pthread_keys[1]是函数myfunc分配的key，对于每一个线程，pthread api维护了一个指针数组，
数组元素指向函数内分配的内存，</p>

<p><img src="/images/assets/pthread-psd-key-2.png" title="linux" alt="alt text" /></p>

<h2>例子</h2>

<h3>非线程安全的</h3>

<p>下面是一个非线程安全的strerror()的实现：</p>

<pre><code class="c">#define _GNU_SOURCE  /* Get '_sys_nerr' and '_sys_errlist' declarations from &lt;stdio.h&gt; */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   /* Get declaration of strerror() */
#define MAX_ERROR_LEN 256  /* Maximum length of string returned by strerror() */
static char buf[MAX_ERROR_LEN];  /* Statically allocated return buffer */
char *
strerror(int err)
{

    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) {
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);

        buf[MAX_ERROR_LEN - 1] = '\0'; /* Ensure null termination */
    }
    return buf; 
}
</code></pre>

<h3>线程安全例子</h3>

<pre><code class="c">
#define _GNU_SOURCE     /* Get '_sys_nerr' and '_sys_errlist' declarations from &lt;stdio.h&gt; */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;     /* Get declaration of strerror() */
#include &lt;pthread.h&gt;
#include "tlpi_hdr.h"


static pthread_once_t once = PTHREAD_ONCE_INIT; 
static pthread_key_t strerrorKey;


#define MAX_ERROR_LEN 256       /* Maximum length of string in per-thread buffer returned by strerror() */

static void
destructor(void *buf)       /* Free thread-specific data buffer */
{
    free(buf);
}

static void
createKey(void)     /* One-time key creation function */
{
    int s;
    /* Allocate a unique thread-specific data key and save the address of the destructor for thread-specific data buffers */

    s = pthread_key_create(&amp;strerrorKey, destructor);
    if (s != 0)
        errExitEN(s, "pthread_key_create");
}

char *
strerror(int err)
{
    int s;
    char *buf;

    /* Make first caller allocate key for thread-specific data */

    s = pthread_once(&amp;once, createKey); 
    if (s != 0)
        errExitEN(s, "pthread_once");

    buf = pthread_getspecific(strerrorKey);
    if (buf == NULL) { /* If first call from this thread, allocate buffer for thread, and save its location */

        buf = malloc(MAX_ERROR_LEN);
        if (buf == NULL)
            errExit("malloc");

        s = pthread_setspecific(strerrorKey, buf); 
        if (s != 0)
            errExitEN(s, "pthread_setspecific");
    }

    if (err &lt; 0 || err &gt;= _sys_nerr || _sys_errlist[err] == NULL) { 
        snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
    } else {
        strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
        buf[MAX_ERROR_LEN - 1] = '\0'; /* Ensure null termination */
    }

    return buf; 
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(线程)]]></title>
    <link href="http://baren.github.io/blog/2014/08/28/pthread/"/>
    <updated>2014-08-28T20:00:53+08:00</updated>
    <id>http://baren.github.io/blog/2014/08/28/pthread</id>
    <content type="html"><![CDATA[<h1>线程概念</h1>

<p>主要是POSIX线程，也就是pthread。</p>

<p>正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。</p>

<p>判断系统是否支持pthread，可以使用宏<em>POSIX_THREADS进行测试，还可以把</em>SC_THREADS传递给sysconf函数来运行时判断。</p>

<p>线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：</p>

<ul>
<li>进程之间共享数据非常困难</li>
<li>使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。</li>
</ul>


<p>使用线程，解决这上面这些问题：</p>

<ul>
<li>线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。</li>
<li>线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。</li>
</ul>


<p>除了共享全局内存，线程还共享一些其他属性，包括</p>

<ul>
<li>进程id和父进程id</li>
<li>进程组合session id</li>
<li>控制终端</li>
<li>进程凭证（用户和组id）</li>
<li>打开的文件描述符（比较重要）</li>
<li>信号处理</li>
<li>文件系统相关信息：umask、当前工作目录和根目录</li>
<li>等</li>
</ul>


<p>下面是各个线程不同的属性：</p>

<ul>
<li>线程id</li>
<li>信号mask</li>
<li>线程私有数据</li>
<li>errno变量</li>
<li>等</li>
</ul>


<!-- more -->


<h2>线程和errno</h2>

<p>进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。</p>

<p>这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。</p>

<p>注：</p>

<blockquote><p>在线程中，使用函数的返回错误码更为清晰整洁。</p></blockquote>

<h2>线程ID</h2>

<p>进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用<code>pid_t</code>来表示；线程的ID，使用<code>pthread_t</code>类型来表示。</p>

<p>为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。</p>

<p>下面是处理线程ID的函数：</p>

<pre><code>#include &lt;pthread.h&gt;
// 比较两个线程ID
int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值

// 获取线程的ID
pthread_t pthread_self(void);
</code></pre>

<h1>线程创建</h1>

<p>使用pthread_create函数创建线程：</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start)(void *), void *arg);

// 成功返回0
</code></pre>

<p>这个函数的参数意义是：</p>

<ul>
<li>thread——线程创建成功后，将线程的ID写入这个指针指向的内存中</li>
<li>attr——创建线程的属性</li>
<li>start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数</li>
<li>arg——无类型指针参数，作为线程执行函数的参数传入</li>
</ul>


<h1>线程终止</h1>

<ul>
<li><p>进程终止会导致线程终止：</p>

<ul>
<li>任一线程调用了exit，<em>Exit或</em>exit函数，整个进程终止</li>
<li>若信号的默认动作是终止进程，则把信号发送到线程会终止进程</li>
</ul>
</li>
<li><p>单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。</p>

<ul>
<li>线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）</li>
<li>线程可以被同一进程中的其它线程取消（pthread_cancel）</li>
<li>线程调用pthread_exit函数退出</li>
</ul>
</li>
</ul>


<pre><code>#include &lt;pthread.h&gt;
void pthread_exit(void *retval);
</code></pre>

<p>pthread_exit接收的参数，就是线程的返回值。</p>

<p>其它线程可以通过pthread_join获取这个值。</p>

<p>注意：</p>

<blockquote><p>pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。</p></blockquote>

<h2>pthread_join函数</h2>

<p>pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。</p>

<pre><code>include &lt;pthread.h&gt;
int pthread_join(pthread_t thread, void **retval); // 成功，返回0
</code></pre>

<p>如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。</p>

<p>注意：</p>

<blockquote><p>如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。</p></blockquote>

<p>如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程</p>

<p>还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &amp;status, options)); 等待任意进程，线程没有这个操作。</p>

<h2>pthread_detach函数</h2>

<p>默认情况下，线程是可<em>结合的（joinable）</em>，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。</p>

<p>某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是<em>分离的（detached）</em>。</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_detach(pthread_t thread);
// 成功返回0
</code></pre>

<p>注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。</p>

<h1>线程参数传递和返回值</h1>

<p>在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。</p>

<ul>
<li>在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数</li>
<li>当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：

<blockquote><ul>
<li>在线程执行函数返回一个指针</li>
<li>调用pthread_exit()，把返回值指针作为pthread_exit的参数</li>
</ul>
</blockquote></li>
</ul>


<p>例子：</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

/* **************************************************************************/
/*  our macro for errors checking                                           */
/* **************************************************************************/
#define COND_CHECK(func, cond, retv, errv) \
if ( (cond) ) \
 { \
    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
                  __FILE__,__LINE__,func,retv,strerror(errv)); \
                     exit(EXIT_FAILURE); \
 }

#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)




void *th_func1(void *arg);
void *th_func2(void *arg);
void test_thread_ret();

int main(int argc, char *argv[])
{
    test_thread_ret();
    return 0;
}

void test_thread_ret()
{
    int t_ret;
    // pthread ret
    pthread_t t1, t2;
    void *tret;
    t_ret = pthread_create(&amp;t1, NULL, th_func1, NULL);
    PthreadCheck("pthread_create", t_ret);
    t_ret = pthread_create(&amp;t2, NULL, th_func2, (void *)2);
    PthreadCheck("pthread_create", t_ret);

    printf("join t1\n");
    t_ret = pthread_join(t1, &amp;tret);
    PthreadCheck("pthread_join", t_ret);
    printf("ret of thread 1 is %d.\n", (int) tret);

    printf("join t2\n");
    t_ret = pthread_join(t2, &amp;tret);
    PthreadCheck("pthread_join", t_ret);
    printf("ret of thread 2 is %d.\n", (int) tret);

}
void *th_func1(void *arg)
{
    printf("thread 1 runing\n");
    return (void *)1;
}

void *th_func2(void *arg)
{
    int * a;
    a = (int *)arg;
    printf("thread 2 arg is %d.\n", (int) a);
    pthread_exit((void *) 2);
}
</code></pre>

<h1>取消线程</h1>

<p>线程可以调用pthread_cancel函数<em>请求</em>取消同一进程中的其它线程。</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cancel(pthread_t tid);
</code></pre>

<p>pthread_cancel并不等待线程终止仅仅提出请求。</p>

<p>线程在取消请求发出后还继续运行，直到线程打到某个<em>取消点</em>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>

<h1>线程同步</h1>

<p>有三种同步方式：互斥量、读写锁以及条件变量</p>

<h2>互斥量</h2>

<p>互斥量用pthread_mutex_t数据类型表示，使用互斥量之前必须对其进行初始化
* 初始化为常量PTHREAD_MUTEX_INITIALIZER，前提是pthread_mutex_t为静态分配的
* 调用pthread_mutex_init函数初始化动态分配的pthread_mutex_t变量。</p>

<p>注意：
* 如果pthread_mutex_t是动态分配的（比如通过malloc），则须用pthread_mutex_destory函数来师傅内存。</p>

<pre><code class="c">
int pthread_mutex_init(pthread_mutex_t *restrict mutex, pthread_mutexattr_t *attr);
int pthread_mutex_destory(pthread_mutex_t *mutex)
</code></pre>

<p>对互斥量加锁解锁函数</p>

<pre><code>
#include &lt;pthread.h&gt;
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>

<p>对互斥量要找到平衡点，既不使锁得粒度太粗导致线程阻塞，又不能因为锁得粒度太细导致代码复杂性和过多锁导致性能下降。</p>

<h2>读写锁</h2>

<p>与互斥量类似，但是读写锁具有更高的并行性。读写锁有三种状态：
* 读模式下的锁状态
* 写模式下的加锁状态
* 不加锁状态</p>

<p>对于读写锁，有几个特征：</p>

<ul>
<li>一次只能有一个线程可以占有写锁，但是多个线程可以同时占用读锁。</li>
<li>当处于写锁状态时，所有试图对其进行加读锁的线程，都会被阻塞</li>
<li>当处于读锁状态时，所有试图对齐进行加读锁的线程，都可以立即获得</li>
<li>如果在读锁状态下，线程希望以写锁对此锁进行加锁，必须阻塞直到线程释放获的的读锁才可以加上写锁。</li>
<li>为了防止一直处于读锁中而使写锁一直阻塞，一旦进行加写锁阻塞，会阻塞后续对其进行的增加读锁行为。</li>
</ul>


<p>读写锁也叫共享-独占锁。</p>

<p>对读写锁也需要初始化和销毁操作。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;

int pthread_rwlock_init(pthread_rwlock_t rwlock, pthread_rwlockattr_t * attr);
int pthread_rwlock_destory(pthread_rwlock_t *rwlock);
</code></pre>

<p>读写锁加锁操作</p>

<pre><code>#include &lt;pthread.h&gt;
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

// 实现读写锁的时候，可能会对共享模式下可获取的锁进行数量限制，因此要检查pthread_rwlock_rdlock()的返回值。
</code></pre>

<h2>条件变量</h2>

<p>mutex阻止了多个线程同时访问共享的变量。
条件变量允许一个线程在共享的变量状态改变的时候通知其他线程这个改变，并允许其它线程等待（block）这个通知。</p>

<p>下面代码，没有使用条件变量，只是使用互斥量来实现，来证明在特定情况下，条件变量的用处。</p>

<pre><code class="c">static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; 
static int avail = 0;  // 表示可消费的数目

// 在生产线程中的代码

s = pthread_mutex_lock(&amp;mtx);
if (s != 0)
    errExitEN(s, "pthread_mutex_lock");

avail++; /* 仅仅表示有可用资源，其它步骤省略*/

s = pthread_mutex_unlock(&amp;mtx); 

if (s != 0)
    errExitEN(s, "pthread_mutex_unlock");

// 在主线程中，主要用来消费生产线程生产的数据

for (;;) {
    s = pthread_mutex_lock(&amp;mtx);
    if (s != 0)
        errExitEN(s, "pthread_mutex_lock");

    while (avail &gt; 0) { /* 消耗生产的数据 */ 
        /* 用生产的数据做一些其它时期 */
        avail--;
    }
    s = pthread_mutex_unlock(&amp;mtx); 
    if (s != 0)
        errExitEN(s, "pthread_mutex_unlock");
}
</code></pre>

<p>上面用互斥量实现的生产者消费者同步代码，问题有：</p>

<ol>
<li>空耗CPU，会一直持续循环来检查avail的状态</li>
</ol>


<p>条件变量解决了这个问题，允许消费进程在没有数据的时候挂起（wait），当有数据的时候通知线程。</p>

<p>条件变量通常与互斥量联合使用：</p>

<ul>
<li>互斥量保护共享变量的修改</li>
<li>条件变量则用来通知状态的修改</li>
</ul>


<p>条件变量在使用前必须初始化，跟互斥量一样，既可以静态初始化，也可以动态初始化。</p>

<pre><code class="c">// 静态
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// 动态，pthread_cond_t变量是动态分配的。需要调用下面函数

#include &lt;pthread.h&gt;
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

int pthread_cond_destroy(pthread_cond_t *cond);
</code></pre>

<h2>基于条件变量的通知和等待</h2>

<p>条件变量的主要操作就是signal（通知）和wait（等待），通知可以一次给一个线程通知，也可以广播给所有等待线程。
wait操作是等待，直到有通知到来。</p>

<pre><code class="c">
#include &lt;pthread.h&gt;
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
const struct timespec *abstime);
</code></pre>

<p>下面代码是使用条件变量的典型代码：</p>

<pre><code class="c 消耗线程代码">
pthread_mutex_lock(&amp;mutex);         /* 锁住互斥量          */
while (!predicate) {                    /* 检查 predicate      */
    pthread_cond_wait(&amp;condvar,&amp;mutex);   /* go to sleep - recheck pred on awakening    */

}
pthread_mutex_unlock(&amp;mutex); 
</code></pre>

<p>pthread_cond_wait() 做了以下事情：</p>

<ul>
<li>释放互斥量的锁</li>
<li>让线程进入休眠状态（sleep）</li>
</ul>


<p>当某个线程进入休眠状态，需要有其它线程唤醒它，这就是生产线程：</p>

<pre><code class="c 生产线程">
pthread_mutex_lock(&amp;mutex);                 /* 锁住互斥量       */
predicate=1;                                /* 设置 predicate    */
pthread_cond_broadcast(&amp;condvar);           /* 唤醒每一个等待条件变量的线程     */
pthread_mutex_unlock(&amp;mutex);               /* 解锁互斥量     */
</code></pre>

<p>这里，重要的调用是pthread_cond_broadcast()，他会唤醒每一个等待条件变量的线程。第一个被唤醒的线程还是处于pthread_cond_wait函数调用中。然后，pthread_cond_wait完成了下面操作：</p>

<ul>
<li>重新获得互斥量锁。</li>
</ul>


<p>然后执行就再次检查predicate。</p>

<h3>条件变量实际例子（join任何终止的线程）</h3>

<p>使用pthread_join仅仅可以等待一个指定的线程，并没办法join任何终止的线程。使用条件变量可以实现。</p>
]]></content>
  </entry>
  
</feed>
