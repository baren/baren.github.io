<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Baren Blog]]></title>
  <link href="http://baren.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2014-09-14T16:28:39+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python decorator 深入理解]]></title>
    <link href="http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator/"/>
    <updated>2014-09-14T11:38:09+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator</id>
    <content type="html"><![CDATA[<h1>装饰器介绍</h1>

<p>装饰器是一个函数，其主要目的是包装另一个函数或类，来透明的修改或者增强被包装对象的功能。语法上，装饰器用<em>@</em>表示，比如：</p>

<pre><code class="python">
@trace
def square(x):
    return x*x
</code></pre>

<p>上面装饰器，类似于这样的：</p>

<pre><code class="python">
def square(x):
    return x*x

square = trace(square)
</code></pre>

<!-- more -->


<h1>不带参数的装饰器</h1>

<p>装饰器不带参数，被装饰的函数可以带参数，也可以不带，</p>

<h2>被装饰函数不带参数</h2>

<p>不带参数的装饰器，比较简单，只需要接收一个函数作为参数即可。
例子：</p>

<pre><code class="python">
import time

def timing_function(some_function):  # 装饰器，接收一个函数作为参数

    """
    Outputs the time a function takes
    to execute.
    """

    def wrapper():
        t1 = time.time()
        some_function()
        t2 = time.time()
        return "Time it took to run the function: " + str((t2-t1)) + "\n"
    return wrapper

@timing_function
def my_function():
    num_list = []
    for x in (range(0,10000)):
        num_list.append(x)
    print "\nSum of all the numbers: " +str((sum(num_list)))


print my_function()
</code></pre>

<h2>被装饰函数带参数</h2>

<p>如果被装饰的函数带参数，让包装函数带着参数就可以。
例子：</p>

<pre><code class="python">
# It’s not black magic, you just have to let the wrapper 
# pass the argument:

def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print "I got args! Look:", arg1, arg2
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments

# Since when you are calling the function returned by the decorator, you are
# calling the wrapper, passing arguments to the wrapper will let it pass them to 
# the decorated function

@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print "My name is", first_name, last_name

print_full_name("Peter", "Venkman")
# outputs:
#I got args! Look: Peter Venkman
#My name is Peter Venkman
</code></pre>

<p>为了函数通用，可以让包装器接收参数设置为(*args, **kwargs)的形式：</p>

<pre><code class="python">
def common_decorator(function):

    """
    Limits how fast the function is
    called.
    """

    def wrapper(*args, **kwargs):
        # 处理代码
        function(*args, **kwargs)
        # 处理代码
    return wrapper


@common_decorator
def print_number(num):
    return num
</code></pre>

<h1>装饰器需要参数</h1>

<p>有时候为了装饰器的功能性，需要装饰器本身也需要接收参数，但是装饰器应该接收一个函数作为参数，为了达到让装饰器也能接收参数，需要：</p>

<ul>
<li>多套一层函数，最外层函数接收装饰器用到的参数</li>
<li>在打装饰器时，把参数传给装饰器，也就是在<em>@</em>后面是一个函数调用，而不是仅仅是装饰器的名字。</li>
</ul>


<p>例子：</p>

<pre><code class="python">
def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):

    print "I make decorators! And I accept arguments:", decorator_arg1, decorator_arg2

    def my_decorator(func):
        # The ability to pass arguments here is a gift from closures.
        # If you are not comfortable with closures, you can assume it’s ok,
        # or read: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python
        print "I am the decorator. Somehow you passed me arguments:", decorator_arg1, decorator_arg2

        # Don't confuse decorator arguments and function arguments!
        def wrapped(function_arg1, function_arg2) :
            print ("I am the wrapper around the decorated function.\n"
                  "I can access all the variables\n"
                  "\t- from the decorator: {0} {1}\n"
                  "\t- from the function call: {2} {3}\n"
                  "Then I can pass them to the decorated function"
                  .format(decorator_arg1, decorator_arg2,
                          function_arg1, function_arg2))
            return func(function_arg1, function_arg2)

        return wrapped

    return my_decorator

@decorator_maker_with_arguments("Leonard", "Sheldon")
def decorated_function_with_arguments(function_arg1, function_arg2):
    print ("I am the decorated function and only knows about my arguments: {0}"
           " {1}".format(function_arg1, function_arg2))

decorated_function_with_arguments("Rajesh", "Howard")
#outputs:
#I make decorators! And I accept arguments: Leonard Sheldon
#I am the decorator. Somehow you passed me arguments: Leonard Sheldon
#I am the wrapper around the decorated function. 
#I can access all the variables 
#   - from the decorator: Leonard Sheldon 
#   - from the function call: Rajesh Howard 
#Then I can pass them to the decorated function
#I am the decorated function and only knows about my arguments: Rajesh Howard
</code></pre>

<p>注意上面的例子：
1、打装饰器的时候，其实是一个函数调用：@decorator_maker_with_arguments(&ldquo;Leonard&rdquo;, &ldquo;Sheldon&rdquo;)。
2、装饰器返回的包装函数，实际上是一个闭包，它引用了装饰器的参数（decorator_arg1和decorator_arg2）。</p>

<h1>functools模块用于装饰器</h1>

<p>functools在python2.5引入的，他包含了函数functools.wraps()，这个函数的作用是拷贝被包装的函数的名字、模块和docstring到它的包装器上。
functools。wraps()实际上也是个装饰器。</p>

<p>例子：</p>

<pre><code class="python">
# For debugging, the stacktrace prints you the function __name__
def foo():
    print "foo"

print foo.__name__
#outputs: foo

# With a decorator, it gets messy    
def bar(func):
    def wrapper():
        print "bar"
        return func()
    return wrapper

@bar
def foo():
    print "foo"

print foo.__name__
#outputs: wrapper
# 输出的信息是包装器的信息，而不是原始函数的信息。

# 使用"functools" 来解决上面问题

import functools

def bar(func):
    # We say that "wrapper", is wrapping "func"
    # and the magic begins
    @functools.wraps(func)
    def wrapper():
        print "bar"
        return func()
    return wrapper

@bar
def foo():
    print "foo"

print foo.__name__
#outputs: foo
# 输出的信息是实际的foo函数的信息
</code></pre>

<h1>类作为装饰器</h1>

<p>装饰器除了使用函数的方式外（大部分都是用函数来实现装饰器），还可以使用类的形式。</p>

<p>对于装饰器来说，唯一的约束是：<em>装饰器返回的对象必须可以被当成函数使用，也就是它可以被调用</em>。</p>

<p>如果类被当成装饰器，那么，类必须实现<strong>call</strong>函数。</p>

<p>需要注意的点：</p>

<ul>
<li>类的初始化函数（<strong>init</strong>）需要接受一个函数作为参赛</li>
<li>在给函数打装饰器时，<strong>init</strong>会执行</li>
<li>在调用被装饰的函数时，类的<strong>call</strong>被调用</li>
</ul>


<p>例子：</p>

<pre><code class="python">
&gt;&gt;&gt; class myDecorator(object):
...     def __init__(self, f):
...             print "inside myDecorator.__init__()"
...             f()
...     def __call__(self):
...             print "inside myDecorator.__call__()"
...
&gt;&gt;&gt; @myDecorator
... def aFunction():
...     print "inside aFunction()"
...
inside myDecorator.__init__()
inside aFunction()
&gt;&gt;&gt; aFunction()
inside myDecorator.__call__()
</code></pre>

<h2>被装饰函数带参数</h2>

<p>如果使用类来作为装饰器，如果被装饰函数需要参数，则定义在<strong>call</strong>函数上。比如：</p>

<pre><code class="python">
class decoratorWithoutArguments(object):

    def __init__(self, f):
        """
        If there are no decorator arguments, the function
        to be decorated is passed to the constructor.
        """
        print "Inside __init__()"
        self.f = f

    def __call__(self, *args):  # 传给被装饰器的参数，传递给__call__()
        """
        The __call__ method is not called until the
        decorated function is called.
        """
        print "Inside __call__()"
        self.f(*args)
        print "After self.f(*args)"

@decoratorWithoutArguments
def sayHello(a1, a2, a3, a4):
    print 'sayHello arguments:', a1, a2, a3, a4

print "After decoration"

print "Preparing to call sayHello()"
sayHello("say", "hello", "argument", "list")
print "After first sayHello() call"
sayHello("a", "different", "set of", "arguments")
print "After second sayHello() call"
</code></pre>

<p>结果是：</p>

<pre><code class="text">
# 函数定义的执行结果
Inside __init__()
After decoration

Preparing to call sayHello()  

# 下面结果是一次函数调用
Inside __call__()  
sayHello arguments: say hello argument list
After self.f(*args)

After first sayHello() call

# 下面结果是一次函数调用
Inside __call__()
sayHello arguments: a different set of arguments
After self.f(*args)

After second sayHello() call
</code></pre>

<h2>装饰器带参数</h2>

<p>如果类作为装饰器，装饰器如果带参数，则需要注意的比较多：</p>

<ul>
<li>参数传递给<strong>init</strong>函数。</li>
<li><strong>call</strong>函数需要返回一个包装函数（因为装饰器有参数，所有打装饰器的地方，实际上是个函数调用，这会导致class的<strong>call</strong>调用）。</li>
</ul>


<p>比如：</p>

<pre><code class="python">
class decoratorWithArguments(object):

    def __init__(self, arg1, arg2, arg3):
        """
        If there are decorator arguments, the function
        to be decorated is not passed to the constructor!
        """
        print "Inside __init__()"
        self.arg1 = arg1
        self.arg2 = arg2
        self.arg3 = arg3

    def __call__(self, f):
        """
        If there are decorator arguments, __call__() is only called
        once, as part of the decoration process! You can only give
        it a single argument, which is the function object.
        """
        print "Inside __call__()"
        def wrapped_f(*args):
            print "Inside wrapped_f()"
            print "Decorator arguments:", self.arg1, self.arg2, self.arg3
            f(*args)
            print "After f(*args)"
        return wrapped_f

@decoratorWithArguments("hello", "world", 42)
def sayHello(a1, a2, a3, a4):
    print 'sayHello arguments:', a1, a2, a3, a4

print "After decoration"

print "Preparing to call sayHello()"
sayHello("say", "hello", "argument", "list")
print "after first sayHello() call"
sayHello("a", "different", "set of", "arguments")
print "after second sayHello() call"
</code></pre>

<p>输出结果是：</p>

<pre><code class="text">定义输出
Inside __init__()
Inside __call__()  # 因此装饰器是函数调用，因此走到__call__调用


After decoration

Preparing to call sayHello()

# 下面结果是一次函数调用装饰器调用
Inside wrapped_f()
Decorator arguments: hello world 42
sayHello arguments: say hello argument list
After f(*args)

after first sayHello() call

# 下面结果是一次函数调用
Inside wrapped_f()
Decorator arguments: hello world 42
sayHello arguments: a different set of arguments
After f(*args)

after second sayHello() call
</code></pre>

<h1>总结</h1>

<p>装饰器可以由函数实现，也可以由类实现，由类实现需要类实现<strong>call</strong>函数。
不管用哪种方式，装饰器返回的必须是一个接受一个函数参数的可调用对象。</p>

<h1>实际例子</h1>

<p>关于装饰器的实际例子，可以参考</p>

<p><a href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a></p>

<h1>参考</h1>

<p><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484</a></p>

<p><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845">http://www.artima.com/weblogs/viewpost.jsp?thread=240845</a>
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 作用域规则]]></title>
    <link href="http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming/"/>
    <updated>2014-09-13T17:07:23+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming</id>
    <content type="html"><![CDATA[<h1>作用域规则</h1>

<p>每当一个函数执行，都会创建一个局部命名空间（local namespace）。这个命名空间代表了一个局部环境，这个环境包含了凡是参数的名字、在函数内定义的局部变量等。当解析一个名字时，解析器会：</p>

<ul>
<li>首先检查局部环境变量</li>
<li>如果在局部命名空间中找不到，然后再往上寻找全局命名空间（global namespace），全局命名空间是函数定义所在的模块。</li>
<li>如果在全局命名空间不存在，解释器会查找内置的命名空间，如果还找不到，则NameError异常抛出</li>
</ul>


<p>python的命名空间的一个特点就是：在函数内处理全局变量。</p>

<p>比如：</p>

<!-- more -->


<pre><code class="python">
a = 42 
def foo():
    a = 13 
foo()
# a 还是 42
</code></pre>

<p>这里，虽然在函数foo内给a赋值为13，但是：<em>当一个变量在函数内赋值时，结果总是把这个变量绑定到局部命名空间中</em>，因此在foo内，a与全局变量的a是不一样的。</p>

<p>如果要在函数内修改全局变量，必须使用<em>global</em>关键字来修饰变量。表示的意思是简单的生命这个名字属于全局命名空间。这只在这个变量需要被修改的情况下。
例子：</p>

<pre><code class="python">
a = 42
b = 37 

def foo():
    global a  # 'a' 此时在全局命名空间中
    a = 13 
    b=0

foo()
# a 是 13. b 仍然是 37.
</code></pre>

<h2>嵌套函数中的变量作用域</h2>

<p>python支持嵌套函数定义，也就是在函数内定义函数：</p>

<pre><code class="python">
def countdown(start): 
    n = start
    def display(): # Nested function definition 
        print('T-minus %d' % n)
    while n &gt; 0: 
        display()
        n -= 1
</code></pre>

<p>当作用域涉及到嵌套函数时，变量的搜寻是按照<em>词法范围（lexical scoping）</em>来查找的。意思是：</p>

<ul>
<li>变量名字受限检查局部范围</li>
<li>然后是函数定义处外围范围，依次往外查找，从最内层到最外层范围</li>
<li>然后就是全局命名空间</li>
<li>最后是内置的命名空间</li>
</ul>


<p>在给变量赋值时，牵扯到嵌套函数，python2有个限制是：</p>

<ul>
<li>只允许在最内层范围的和全局范围的（使用global）的变量可以被赋值。</li>
</ul>


<p>这意味着：</p>

<ul>
<li>内部函数不能够给一个局部变量赋值，这个局部变量是定义在内部函数的外围函数内。</li>
</ul>


<p>比如：</p>

<pre><code>def countdown(start):
    n = start

    def display():
        print('T-minus %d' % n)

    def decrement():
        n -= 1 # 在Python 2是错误的，这里不能修改这个值。

    while n &gt; 0: 
        display()
        decrement()
</code></pre>

<p>在python3中，可以使用<em>nonlocal</em>关键字来修改：</p>

<pre><code class="python">
def countdown(start):
    n = start

    def display(): 
        print('T-minus %d' % n) 

    def decrement():
        nonlocal n
        n -= 1  # 绑定到外围的 n (Python 3)

    while n &gt; 0: 
        display()
        decrement()
</code></pre>

<p>如果一个局部变量在赋值前被使用，则会抛出UnboundLocalError的错误，比如：</p>

<pre><code class="python">
i=0
def foo():
    i = i + 1 # 导致UnboundLocalError 异常 
    print(i)
</code></pre>

<p>在这个例子中，变量<em>i</em>被定义为局部变量（在函数内被赋值，并且没有global关键字声明），这样，在执行 i = i +1 语句时，会试图读取变量“i”的值，会导致错误。</p>

<h1>函数作为对象和闭包（closure）</h1>

<h2>函数作为对象</h2>

<p>python中，函数是一级对象（first-class），意思是</p>

<ul>
<li>函数可以作为参数传递给其它函数</li>
<li>放在数据结构中</li>
<li>以及作为结果从函数中返回。</li>
</ul>


<p>注意：</p>

<blockquote><p>当函数作为数据被处理时，需要注意的是：函数隐含的携带了在函数定义处的外围环境信息。这会影响到自由的变量在函数内怎么被绑定。</p></blockquote>

<p>比如下面例子：</p>

<pre><code class="python foo_test.py">
x = 33
def print_x():
    print x
</code></pre>

<p>然后在foo.py文件中导入foo_test：</p>

<pre><code class="python foo.py">
x = 42

def foo(func):
    func()


if __name__ == "__main__":
    foo(foo_test.print_x)

// 输出结果是33，而不是此处定义的42
</code></pre>

<p>在这个例子中，需要注意的是print_x使用的x是他所定义处的x的值，而不是在执行处的值，虽然在执行的地方，也定义了同样的变量。</p>

<h2>闭包</h2>

<p>闭包的定义：
组成函数的语句，与执行的环境绑定在一起，产生的对象，被称为闭包。可以简单的认为闭包是一个函数，它在词法上下文中引用了自由变量，所谓自由变量就是除局部变量以外的变量。</p>

<p>闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例</p>

<p>一般有闭包特征的语言有下面这样的特性：</p>

<ul>
<li>函数是第一级对象（first-class）</li>
<li>函数可以嵌套定义。</li>
</ul>


<p>当嵌套函数被使用时，闭包会捕获嵌套函数执行所需要的整个环境。比如：</p>

<pre><code class="python">
import foo 
def bar(): 
    x = 13

def helloworld():
    return "Hello World. x is %d" % x
    foo.callf(helloworld)   # returns 'Hello World, x is 13'
</code></pre>

<p>闭包和嵌套函数在你想延迟计算时，比较有用：</p>

<pre><code class="python">
from urllib import urlopen
# from urllib.request import urlopen (Python 3) 

def page(url):

    def get():
        return urlopen(url).read()
    return get
</code></pre>

<p>执行如下：</p>

<pre><code class="python">
&gt;&gt;&gt; python_url = page("http://www.python.org") 
&gt;&gt;&gt; jython_url = page("http://www.jython.org") 
&gt;&gt;&gt; python_url
&lt;function get at 0x95d5f0&gt;
&gt;&gt;&gt; jython
&lt;function get at 0x9735f0&gt;
&gt;&gt;&gt; pydata = python()  # 读取url内容
&gt;&gt;&gt; jydata = jython()  # 读取url内容
</code></pre>

<p>对于上面这个闭包例子，解释如下：</p>

<ul>
<li>两个变量python_url和jython_url实际上是两个不同的get函数的版本（语句与外围环境的绑定）</li>
<li>即使创建这两个变量的函数page不再运行，get函数暗中的携带了get函数使用的外围get函数定义处的变量。</li>
<li>当get调用时，绑定了代码和外围的变量。</li>
</ul>


<p>闭包一个非常有用的方式是：<em>可以用来保存跨越一系列函数调用的状态（函数式编程所用到的状态的保存）</em>，比如：</p>

<pre><code class="python">
def countdown(n): 
    def next():
        nonlocal n  # python3
        r=n
        n -= 1 
        return r
    return next

# Example use
next = countdown(10) 
while True:
    v = next()  # 获取下一个值
    if not v: 
        break
</code></pre>

<p>在这段代码中，闭包被用来保存内部的计数值 n。这样，每次调用next()函数时，都能够更新和返回上一个计数变量的值（感觉就是更新了一个全局变量，但是这个n实际上是一个局部变量）。</p>

<p>假设，语言不支持闭包，那么要实现上面同样的功能，可以这样(基本原则是在函数外定义一个变量，变量的生命周期不随函数调用而结束)：</p>

<pre><code class="python">
class Countdown(object): 

    def __init__(self,n):
        self.n = n 

    def next(self):
        r = self.n 
        self.n -= 1 
        return r

# Example use
c = Countdown(10) 

while True:
    v = c.next() # 获取下一个值
    if not v: 
        break
</code></pre>

<p>总结：</p>

<blockquote><p>闭包可以保存变量的状态，这个变量不随着闭包调用结束而丢失。重要的特性。
闭包可以捕获嵌套函数的环境的特性，在包装一个存在的函数来增加额外的功能的时候，非常有用（装饰器）。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序结构和控制]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow/"/>
    <updated>2014-09-06T21:56:14+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow</id>
    <content type="html"><![CDATA[<h1>程序结构和执行</h1>

<p>python程序被组织为一个语句序列。所有的语言特性，包括变量赋值、函数定义、类定义和模块导入等，都是语句，都是与其他语句具有相同状态。</p>

<p>因此所有语句都可以放置在程序的任何地方。</p>

<p>比如：</p>

<pre><code class="python">if debug:
    def square(x):
        if not isinstance(x,float):
            raise TypeError("Expected a float")
        return x * x
else:
    def square(x):
        return x * x
</code></pre>

<p>当加载文件时，python解释器顺序的执行每一条语句，知道不能执行为止。</p>

<p>这种执行方式对于简单的作为主程序执行，或者经过import进行导入是一致的。</p>

<!-- more -->


<h1>循环和迭代</h1>

<p>如果要迭代一个列表，可以使用常用的for in格式。如果迭代列表，还需要获取索引，可以使用enumerate函数，比如：</p>

<pre><code class="python">
for i,x in enumerate(s): 
    statements
</code></pre>

<p>enumerate()函数实际上创建了一个iterator，这个迭代器每次返回一个元组(index, s[index])</p>

<p>如果要迭代两个list，比如对两个list的每项元素相加。可以使用zip函数：</p>

<pre><code class="python"># s and t are two sequences 
for x,y in zip(s,t):
    statements
</code></pre>

<p>zip()函数联合了s和t的元素，生成了一个元组序列：s[0],t[0]), (s[1],t[1]), (s[2], t[2]),等，直到最短的list结束。</p>

<p>注意：
* python2中，zip函数全部消耗了序列元素，生成一个序列。如果s和t比较大，那会生成一个大的列表，进而消耗内存资源。
* python3中，zip改进了，一次生成一个元素，而不是一下子生成一个巨大的序列。
* python2中，可以使用itertools.izip()函数来优化，其方式与python3中的zip一致。</p>

<p>例子：</p>

<pre><code class="python">&gt;&gt;&gt; a = range(8)
&gt;&gt;&gt; b = range(9)
&gt;&gt;&gt; a
[0, 1, 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; b
[0, 1, 2, 3, 4, 5, 6, 7, 8]
&gt;&gt;&gt; for x,y in zip(a,b):
...     print x+y
...
0
2
4
6
8
10
12
14
&gt;&gt;&gt; import itertools
&gt;&gt;&gt; for x,y in itertools.izip(a,b):
...     print x+y
...
0
2
4
6
8
10
12
14
</code></pre>

<p>循环结构，还可以有一个else的语句,for-else或者while-else，比如：</p>

<pre><code class="python"># for-else
for line in open("foo.txt"):
    stripped = line.strip() 
    if not stripped:
        break
# process the stripped line ...
else:
    raise RuntimeError("Missing section separator")
</code></pre>

<p>有两种情况下能够执行到else分支：
* 立即执行，既循环条件不满足。
* 迭代执行完毕，这意味着，如果是break语句或异常语句中断了循环，则不会执行else分支。</p>

<p>一般需要用到for-else这种结构的情况是：迭代完数据，并且需要检查或者设置标记时，可以使用。</p>

<h1>异常</h1>

<p>记住几个点：</p>

<ol>
<li>在except语句中，既可以 except Exception as e，也可以except Exception, e，后面一个是老式用法，不推荐</li>
<li>可以一次except捕获多个异常：<em>except (IOError, TypeError, NameError) as e:</em></li>
</ol>


<pre><code class="python">try:
    do something
except (IOError, TypeError, NameError) as e: # Handle I/O, Type, or Name errors
    ...
</code></pre>

<ol>
<li>try也支持else语句，执行else的条件是try块中没有抛出异常：</li>
</ol>


<pre><code class="python">try:
    f = open('foo', 'r')
except IOError as e:
    error_log.write('Unable to open foo : %s\n' % e)
else:
    data = f.read() f.close()
</code></pre>

<h1>上下文管理和with语句</h1>

<p>在遇到异常的情况下，正确地管理系统资源（比如锁、文件、连接等）是比较棘手的。比如异常可能会绕过释放重要系统资源的代码。</p>

<p><em>with</em>语句允许代码在一个运行的上下文中执行代码，这个运行的上下文被一个作为上下文管理器的对象来控制。比如：</p>

<pre><code class="python"># 当控制离开with代码块时，with自动的将打开的文件关闭
with open("debuglog","a") as f: 
    f.write("Debugging\n") 
    statements 
    f.write("Done\n")

import threading
lock = threading.Lock() 
# 当控制进入和离开with代码块时，自动获取和释放锁。
with lock:
    # Critical section statements
    # End critical section
</code></pre>

<p>语法 <em>with obj</em> 允许让对象obj来控制当执行进入和离开代码块时的行为。</p>

<ul>
<li>进入：
当with obj执行时，它执行obj.<strong>enter</strong>()函数来标记正在进入一个新的上下文。</li>
<li>离开：

<blockquote><p>当控制离开上下文时，执行obj.<strong>exit</strong>(type,value,traceback)，此时，如果没有异常发生，<strong>exit</strong>()函数的三个参数都被设置为None，表示无异常。
否则type,value,traceback就会被赋值为与导致控制流离开with代码块的异常相关联的信息。
<strong>exit</strong>() 返回True和False来标记是否产生的异常被处理了。如果返回False，异常会继续向上传递。</p></blockquote></li>
</ul>


<p>with还可以跟着一个as标识符。<em>with obj as var:</em>如果设置了，则obj.<strong>enter</strong>()的返回值会被赋值给as指定的对象。注意，obj可以不等于var的值。</p>

<p>注意：</p>

<blockquote><p>with只能与支持上下文管理协议的对象（实现了<strong>enter</strong>()和<strong>exit</strong>）一块工作。</p></blockquote>

<p>用户可以实现这两个函数来使自己定义的对象支持上下文管理协议：</p>

<pre><code class="python">class ListTransaction(object): 
    def __init__(self,thelist):
        self.thelist = thelist 

    def __enter__(self):
        self.workingcopy = list(self.thelist)
        return self.workingcopy

    def __exit__(self,type,value,tb):
        if type is None:
            self.thelist[:] = self.workingcopy
        return False

# 使用
items = [1,2,3]
with ListTransaction(items) as working:
    working.append(4)
    working.append(5)
    print(items) # Produces [1,2,3,4,5]

try:
    with ListTransaction(items) as working:
        working.append(6) working.append(7)
        raise RuntimeError("We're hosed!")
except RuntimeError: pass
    print(items) # Produces [1,2,3,4,5]
</code></pre>

<p>可以使用contextlib模块来简化上下文对象的实现：</p>

<pre><code class="python">from contextlib import contextmanager 

@contextmanager
def ListTransaction(thelist):
    workingcopy = list(thelist)
    yield workingcopy
    # Modify the original list only if no errors 
    thelist[:] = workingcopy
</code></pre>

<p>yield生成的对象，就相当于<strong>enter</strong>函数返回的对象。
当执行到<strong>exit</strong>函数时，执行会从yield后继续执行。</p>

<p>如果在上下文中出现了异常，可异常可以在生成器函数中展现（函数内有yield的函数，调用后产生生成器）</p>

<h1>assert</h1>

<p>语法是这样：</p>

<pre><code class="python">assert test [, msg]

# test表达式生成True或者False，如果为False，assert会生成一个AssertionError异常，并附带msg信息
</code></pre>

<p>关于assert，需要知道以下几点：
* 不能使用assert用来为了使程序正确而必须执行的代码（比如检查用户输入是否合法，则不能使用assert），因为有可能不被执行（运行python使用-O参数）
* assert应该被用来事情总是是true的情况，否则就是个bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python杂记]]></title>
    <link href="http://baren.github.io/blog/2014/04/22/python-note/"/>
    <updated>2014-04-22T11:15:07+08:00</updated>
    <id>http://baren.github.io/blog/2014/04/22/python-note</id>
    <content type="html"><![CDATA[<ul>
<li><p>实际上，每一个python函数都有返回值，如果有return，则返回return指定的值；没有就返回None。</p></li>
<li><p>python的搜索路径是在sys.path中搜索，sys.path是一个list，可以修改这个list的值。</p></li>
<li><p>python中，所有都是对象（函数是对象，模块是对象等），意思是所有都可以赋值给变量，或者作为参数传递给函数。所有都是对象，有些可能不具有方法和属性，有些不能被继承，但是都可以赋值和传参。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型和对象(PER4 chapter 3)]]></title>
    <link href="http://baren.github.io/blog/2014/02/10/per4-chapter3-type-and-object/"/>
    <updated>2014-02-10T19:33:16+08:00</updated>
    <id>http://baren.github.io/blog/2014/02/10/per4-chapter3-type-and-object</id>
    <content type="html"><![CDATA[<h1>对象身份和类型</h1>

<p>内置函数 <em>id()</em> 以整数的方式返回对象的身份。这个整数通常指的是内存的位置，但并不保证，这依赖于实现。</p>

<p><em>is</em> 操作符用来比较两个对象的<em>身份</em>的。</p>

<p><em>type()</em> 返回对象的类型。</p>

<p>使用例子：</p>

<pre><code class="python">
# Compare two objects 
def compare(a,b):
    if a is b:
        # a和b是同样的对象，也就是身份相同 
        statements
    if a == b:
        # a和b具有同样的值，身份可以不一样，只要值一样 
        statements
    if type(a) is type(b):
        # a和b具有同样的类型 
        statements
</code></pre>

<!-- more -->


<p>对象的类型：</p>

<p>对象的类型本身就是一个对象。这个类型对象被称为对象的类。这个类型对象是被唯一定义的，并且给定类型的所有实例的类型都是一样的。因此类型对象之间进行比较，可以使用操作符 <em>is</em> 进行比较。</p>

<p>所有的类型对象都赋予一个名字，可以用来进行类型检查。大多数这种名字都是内置的，比如list、dict等。例如：</p>

<pre><code class="python">if type(s) is list: 
    s.append(item)
if type(d) is dict: 
    d.update(t)
</code></pre>

<p>一个比较好的判断类型的方式是使用内置的<code>isinstance(object, type)</code>函数，因为这个函数是可以识别继承的。比如：</p>

<pre><code class="python">if isinstance(s,list): 
    s.append(item)
if isinstance(d,dict): 
    d.update(t)
</code></pre>

<h1>引用计数和垃圾回收</h1>

<p>所有的对象都是引用计数的。</p>

<p>只要把对象赋给一个新名字，或者存放在容器中（list、dict等），都会使引用数增加。</p>

<pre><code class="python">a = 37 # Creates an object with value 37 
b = a # Increases reference count on 37 
c = []
c.append(b) # Increases reference count on 37
</code></pre>

<p>当a赋值给b的时候，值为37的对象的引用数加1；当b存放在容器c中，值为37的对象的引用数加1.</p>

<p>整个例子中，只有一个对象保存了37的值，其它的操作仅仅是创建了一个新的指向这个对象的引用。</p>

<p>这就是引用计数的概念。在考虑引用计数，一定要记住，所有都是对象。</p>

<p>还可以通过操作来减少引用，比如：</p>

<pre><code>del a # Decrease reference count of 37 
b = 42 # Decrease reference count of 37 
c[0] = 2.0 # Decrease reference count of 37
</code></pre>

<p>可以通过函数来查看对象的引用情况：</p>

<pre><code>&gt;&gt;&gt;
&gt;&gt;&gt; a = 37
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getrefcount(a)
7
&gt;&gt;&gt; sys.getrefcount(37)
9
</code></pre>

<p>当对象的引用计数到0的时候，就会被垃圾回收。</p>

<p>对于循环引用，其引用计数不为零，但是已经不被使用的对象，解释器会定期执行循环引用检查。发现就会回收。</p>

<h1>引用和拷贝</h1>

<p>拷贝分浅拷贝和深拷贝。</p>

<p>copy模块提供了浅拷贝和深拷贝操作</p>

<pre><code>copy.copy(x)
    Return a shallow copy of x.

copy.deepcopy(x)
    Return a deep copy of x.
</code></pre>

<p>浅拷贝和深拷贝的区别只与组合对象相关（包含其它对象的对象，比如list等）</p>

<ul>
<li>浅拷贝构建了一个新的组合对象，然后把从原对象中发现的引用插入到新组合对象中</li>
<li>深拷贝构建了一个新的组合对象，然后递归的把原对象的拷贝插入到新对象中</li>
</ul>


<p>浅拷贝创建一个引用，包含的元素是原对象包含的元素的引用。比如：</p>

<pre><code>&gt;&gt;&gt; a = [1,2,[3,4]]
&gt;&gt;&gt; b = list(a)
&gt;&gt;&gt; b is a
False
&gt;&gt;&gt; b.append(100)
&gt;&gt;&gt; b
[1, 2, [3, 4], 100]
&gt;&gt;&gt; a
[1, 2, [3, 4]]
&gt;&gt;&gt; b[2][0] = -100
&gt;&gt;&gt; b
[1, 2, [-100, 4], 100]
&gt;&gt;&gt; a
[1, 2, [-100, 4]]
</code></pre>

<p>对dict的浅拷贝，可以使用 dict.copy()，对于list的浅拷贝，可以使用<code>copied_list = original_list[:]</code></p>

<p>深拷贝可以使用copy模块下的deepcopy函数实现：</p>

<pre><code>&gt;&gt;&gt; import copy
&gt;&gt;&gt; a = [1, 2, [3, 4]]
&gt;&gt;&gt; b = copy.deepcopy(a)
&gt;&gt;&gt; b[2][0] = -100
&gt;&gt;&gt; b
[1, 2, [-100, 4]]
&gt;&gt;&gt; a # Notice that a is unchanged [1, 2, [3, 4]]
&gt;&gt;&gt;
</code></pre>

<p>如果一个类想定义自己的浅拷贝和深拷贝实现，可以实现特殊方法<code>__copy__() and __deepcopy__()</code>。前者是在浅拷贝的时候调用（copy.copy(x)）。后者是在深拷贝的时候调用(copy.deepcopy(x))。</p>

<h1>第一类对象</h1>

<p>第一类对象是指可以在执行期创造并作为参数传递给其他函数或存入一个变量的实体。一般第一类对象具有的特征是：</p>

<ul>
<li>可以被存入变量或其他结构</li>
<li>可以被作为参数传递给其他函数</li>
<li>可以被作为函数的返回值</li>
<li>以在执行期创造，而无需完全在设计期全部写出</li>
</ul>


<p>在python中，所有的对象都是第一类对象。</p>

<p>所有对象都是第一类对象的好处是可以写出很紧凑简洁的代码。</p>

<h1>表示数据的内置类型</h1>

<p>略</p>

<h1>表示程序结构的内置类型</h1>

<h2>可调用类型</h2>

<p>可调用类型表示对象支持函数调用操作。包括用户定义函数，内置函数、实例方法和<strong>类</strong>。</p>

<h3>用户定义函数</h3>

<p>在模块级别创建的，通过def或者lambda操作符创建的用户定义的函数，是可调用的对象。</p>

<p>比如：</p>

<pre><code>
def foo(x, y):
    return x + y

foo = lambda x,y: x + y
</code></pre>

<p>用户定义函数的属性包括：</p>

<table>
<thead>
<tr>
<th>描述        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>f.<em> </em>dict_ _ </td>
<td style="text-align:center;"> 包含函数属性的dict</td>
</tr>
<tr>
<td>f.<em> </em>defaults_ _ </td>
<td style="text-align:center;"> 包含默认参数的元组</td>
</tr>
</tbody>
</table>


<pre><code>&gt;&gt;&gt; def foo(x=1, y=1):
...     return x + y
...
&gt;&gt;&gt; foo.__defaults__
(1, 1)
</code></pre>

<p>用户定义的函数的类型是<code>types.FunctionType</code></p>

<p>比如：</p>

<pre><code>
&gt;&gt;&gt; def foo(x=1, y=1):
...     return x + y
...

&gt;&gt;&gt; import types
&gt;&gt;&gt; type(foo) is types.FunctionType
True
&gt;&gt;&gt; type(foo) is types.MethodType
False
</code></pre>

<h3>方法</h3>

<p>方法是定义在类内部的函数。有三种方法：</p>

<ul>
<li>实例方法——对对象实例上操作的函数</li>
<li>类方法——类本身作为一个对象，类方法是在类本身操作的函数</li>
<li>静态方法——仅仅是个函数，不接收类本身或类的实例作为参数</li>
</ul>


<p>比如：</p>

<pre><code>class Foo(object):
    # 实例方法，第一个参数self
    def instance_method(self, arg):
        statements 

    # 类方法， 第一个参数cls
    @classmethod
    def class_method(cls, arg): 
        statements

    # 静态方法，没有self或cls的参数
    @staticmethod
    def static_method(arg):
        statements
</code></pre>

<p>实例方法和类方法都由types.MethodType来表示。</p>

<p>详细了解对象查询属性操作（.）是如何工作的，对理解这种特殊类型是有好处的。</p>

<p>在一个对象上查询什么（.）与函数调用总是分开的，当调用方法时，两个操作都会发生，只是步骤差别。</p>

<ol>
<li>在实例上查询</li>
</ol>


<p>例子：</p>

<pre><code>f = Foo() # 创建一个实例

meth = f.instance_method # 查询方法，注意，后面没有括号"()"

meth(37) # 现在调用函数
</code></pre>

<p>上面例子中，meth被称为<strong>绑定方法</strong>。绑定函数是一个可调用对象，它包括了函数（method）和相关的实例。</p>

<p>当调用绑定函数时，相关实例会作为第一个参数传递给函数（self）。</p>

<ol>
<li>在类上查询</li>
</ol>


<p>接上面例子：</p>

<pre><code>umeth = Foo.instance_method # 在Foo上查询instance_method

umeth(f,37) # 明确提供self，并且调用
</code></pre>

<p>在这个例子中，umeth被称为未绑定方法。未绑定方法只包含了方法函数，但是需要明确传递正确类型的实例对象作为第一个参数。</p>

<p>在这个例子中，传了Foo的实例f作为第一个参数。</p>

<p>对用户定义的类，绑定方法和未绑定方法都是作为types.MethodType的对象。</p>

<p>下面是方法对象的属性</p>

<table>
<thead>
<tr>
<th>描述        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.<strong>class</strong> </td>
<td style="text-align:center;"> 函数定义的类</td>
</tr>
<tr>
<td>m.<strong>func</strong> </td>
<td style="text-align:center;"> 实现方法的函数对象</td>
</tr>
<tr>
<td>m.<strong>self</strong> </td>
<td style="text-align:center;"> 与方法相关的实例，如果没有，返回None</td>
</tr>
</tbody>
</table>


<h3>内置函数和方法</h3>

<p>对象types.BuiltinFunctionType用来描述用c或c++实现的函数和方法。属性和上面类似。</p>

<h3>类和实例作为可调用对象</h3>

<p>类对象和实例也可以作为可调用对象。一个类对象被<code>class</code>创建，可以作为一个函数来调用，用来创建类的实例。这种情况下，传递的参数会传递给<strong>init</strong>方法中，用来初始化实例对象。</p>

<p>如果一个实例实现了<strong>call</strong>方法，那么这个实例也可以模拟函数调用。如果对象x定义了<strong>call</strong>函数，那么x(args)会调用x.<strong>call</strong>(args)。</p>

<h2>类、类型和实例</h2>
]]></content>
  </entry>
  
</feed>
