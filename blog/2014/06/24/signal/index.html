
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>apue(信号) - Baren Blog</title>
  <meta name="author" content="enwu">

  
  <meta name="description" content="信号概念 信号是软中断，提供了一种处理异步事件的方法 关于信号： 每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中
产生信号的条件 用户按终端键， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://baren.github.io/blog/2014/06/24/signal/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Baren Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Baren Blog</a></h1>
  
    <h2>A blogging for baren.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:baren.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Apue(信号)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-24T20:00:20+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><h1>信号概念</h1>

<p>信号是软中断，提供了一种处理异步事件的方法</p>

<p>关于信号：</p>

<ul>
<li>每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中</li>
<li>产生信号的条件

<blockquote><ul>
<li>用户按终端键，印发终端产生信号</li>
<li>硬件异常产生信号，比如无效的内存引用，除数为0等</li>
<li>进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）</li>
<li>用户用kill命令给进程发送信号</li>
<li>当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。</li>
</ul>
</blockquote></li>
</ul>


<!-- more -->


<p>几种处理信号的方式</p>

<ul>
<li>忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的</li>
<li>捕捉信号——需要注册一个信号处理函数</li>
<li>执行默认操作——大多数的信号的默认动作是终止信号</li>
</ul>


<h1>signal函数</h1>

<p>unix系统提供了两个改变信号处理的方式：signal和signalaction函数</p>

<p>现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void (*signal(int sig, void (*func)(int)))(int)
</span><span class='line'>// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
</span><span class='line'>// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址</span></code></pre></td></tr></table></div></figure>


<p>signal函数太复杂，可以使用typedef类型定义简化一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void Sigfunc(int);
</span><span class='line'>
</span><span class='line'>Sigfunc *signal(int Sigfunc *func);
</span></code></pre></td></tr></table></div></figure>


<p>一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
</span><span class='line'>#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
</span><span class='line'>#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针
</span></code></pre></td></tr></table></div></figure>


<p>可以使用这几个预定义函数常量，来判断信号捕获程序。</p>

<p>关于信号处理程序，注意点：</p>

<ul>
<li>只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误</li>
<li>SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31</li>
<li>kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的</li>
</ul>


<h1>中断的系统调用</h1>

<h2>中断低速系统调用</h2>

<p>若进程调用了一个低速的系统调用，</p>

<p>并且这个系统调用正在阻塞</p>

<p>此时，</p>

<p>捕捉到一个信号。</p>

<p>结果是：该系统调用就被中断不被执行了。</p>

<p><em>注意</em>：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用</p>

<p>低速系统调用是可能是进程阻塞的系统调用，一般包括</p>

<ul>
<li>读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞</li>
<li>打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）</li>
<li>pause和wait，pause会使调用进程一直休眠，指导捕获一个信号</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数</li>
</ul>


<p>这个需要注意的是，磁盘IO操作并不是低速系统调用。</p>

<h2>低速系统调用被中断后的处理和重启</h2>

<p>一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。</p>

<p>这样我们就能够处理这种失败。有两种处理方式：</p>

<ul>
<li>系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作</li>
<li>某些中断的系统调用支持自动重启动</li>
</ul>


<h3>手动检查</h3>

<p>比如可以这样处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
</span><span class='line'>  continue;  // 啥也不做
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<p>如果经常使用这种检查，还可以定义一个宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NO_EINTR(stmt)   while((stmt) == -1 && errno == EINTR);
</span><span class='line'>
</span><span class='line'>// 然后
</span><span class='line'>
</span><span class='line'>NO_EINTR(cnt == read(fd, buf, BUF_SIZE));
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<h3>自动重启动</h3>

<p>为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wait waitpid read write ioctl readv writev
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。</p>

<h1>可重入函数</h1>

<p>在信号处理程序中，不能调用不可重入函数。</p>

<p>所谓不可重入函数是指：</p>

<ol>
<li>它们使用了静态数据结构或全局变量</li>
<li>调用malloc和free，因为malloc维护了一个全局链表</li>
<li>标准IO函数</li>
</ol>


<p>而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数</p>

<p>在标准C函数库中，不可重入函数比较普遍。</p>

<p>比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。</p>

<h1>可靠信号的术语和语义</h1>

<ul>
<li>递送（delivery）信号：当引发信号的事件<em>发生</em>时，为进程产生一个信号（或向进程产生一个信号）</li>
<li>未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的</li>
</ul>


<p>进程可以设置阻塞信号。</p>

<p>若信号被进程设置为阻塞，并且对该信号的动作是系统<strong>默认动作</strong>或<strong>捕捉该信号</strong>，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。</p>

<p>解除未决状态：
    * 对信号解除了阻塞
    * 或者将此信号的动作改为忽略。</p>

<p>注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>void sig_int(int sig);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t osig;
</span><span class='line'>  sigset_t newsig, o_set;
</span><span class='line'>
</span><span class='line'>  sigemptyset(&newsig);
</span><span class='line'>  sigaddset(&newsig, SIGINT);
</span><span class='line'>  // if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
</span><span class='line'>  if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  //pause();
</span><span class='line'>  sleep(4);
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_int) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf(" pause ...\n");
</span><span class='line'>  sigprocmask(0, NULL, &o_set);
</span><span class='line'>  if (sigismember(&o_set, SIGINT))
</span><span class='line'>  {
</span><span class='line'>      printf("is mask\n");
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>void sig_int(int sig)
</span><span class='line'>{
</span><span class='line'>  printf("int sig hand\n");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>执行结果是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果是默认处理，在sleep过程中，产生中断信号，结果是：
</span><span class='line'>$ ./test_pend
</span><span class='line'>^Cint sig hand
</span><span class='line'> pause ...
</span><span class='line'>
</span><span class='line'> 如果改成忽略，在sleep过程中，产生中断信号，结果是：
</span><span class='line'> ./test_pend
</span><span class='line'>^C pause ...</span></code></pre></td></tr></table></div></figure>


<p>注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。</p>

<h1>kill和raise函数</h1>

<p>kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int kill(pid_t pid, int signo);
</span><span class='line'>int raise(int signo);</span></code></pre></td></tr></table></div></figure>


<p>下面是等价的：</p>

<p>raise(signo) == kill(getpid(), signo)</p>

<p>kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid &lt; 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。</p>

<p>上面提到了，给其它进程发信号需要权限，具体是指：</p>

<ul>
<li>超级用户可以将信号发送给任一进程</li>
<li>非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID</li>
</ul>


<p>注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH</p>

<h1>alarm和pause函数</h1>

<p>alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>unsigned int alarm(unsigned int seconds);</span></code></pre></td></tr></table></div></figure>


<p>对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的</p>

<p>pause函数使调用进程挂起直到捕捉到一个信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int pause(void)</span></code></pre></td></tr></table></div></figure>


<p>条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR</p>

<h2>使用alarm实现sleep函数，并暴露问题</h2>

<p>使用信号时，需要精细而周到的考虑，下面代码列出几个问题：</p>

<ul>
<li>问题1：竞争条件</li>
</ul>


<p>看下面的sleep1的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int sleep1(unsigned int nsecs)
</span><span class='line'>{
</span><span class='line'>  if(signal(SIGABRT, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("can't signal alarm!\n");
</span><span class='line'>      return nsecs;
</span><span class='line'>  }
</span><span class='line'>  alarm(nsecs);
</span><span class='line'>  pause();
</span><span class='line'>  return (alarm(0)); // 返回未完成的时间
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  ;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。</p>

<ul>
<li>问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序</li>
</ul>


<p>使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。</p>

<p>第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>static jmp_buf env_alrm;
</span><span class='line'>int sleep2(int);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sleep2(2);
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int sleep2(int sec)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sigalarm err!\n");
</span><span class='line'>      return sec;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alrm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(sec);
</span><span class='line'>      pause();
</span><span class='line'>  }
</span><span class='line'>  return (alarm(0));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  longjmp(env_alrm, 1);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。</p>

<h2>除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限</h2>

<p>下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout);
</span><span class='line'>
</span><span class='line'>static jmp_buf env_alarm;
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char line[100];
</span><span class='line'>  int n;
</span><span class='line'>  n = read_timeout(STDIN_FILENO, line, 100, 3);
</span><span class='line'>  if(n &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("read timeout\n");
</span><span class='line'>  } else {
</span><span class='line'>      printf("read len %d.\n", n);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout)
</span><span class='line'>{
</span><span class='line'>  int n = 0;
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig alarm err\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alarm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(timeout);
</span><span class='line'>      if((n=read(fd, buf, size)) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("read err!\n");
</span><span class='line'>          return n;
</span><span class='line'>      }
</span><span class='line'>      alarm(0);
</span><span class='line'>      return n;
</span><span class='line'>  }
</span><span class='line'>  return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>      longjmp(env_alarm, 1);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>read timeout
</span><span class='line'>user@usertekiMacBook-Pro unix_test$
</span><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>dd
</span><span class='line'>read len 3.</span></code></pre></td></tr></table></div></figure>


<p>注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。</p>

<h1>信号集</h1>

<p>可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigempty(sigset_t *set);
</span><span class='line'>int sigfillset(sigset_t *set);
</span><span class='line'>int sigaddset(sigset_t *set, int signo);
</span><span class='line'>int sigdelset(sigset_t *set, int signo);
</span><span class='line'>  // 四个函数返回值：成功，返回0，失败返回-1
</span><span class='line'>int sigismember(const sigset_t *set, int signo);
</span><span class='line'>  // 若真，返回1，假，返回0，出错，返回-1
</span></code></pre></td></tr></table></div></figure>


<h1>sigpromask函数</h1>

<p>调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>oset非空，则进程当前信号屏蔽字通过oset返回</li>
<li>set非空，则根据第一个参数how指示如何修改当前信号屏蔽字</li>
<li>set为空，不改变</li>
</ul>


<p>how的值：</p>

<ul>
<li>SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集</li>
<li>SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集</li>
<li>SIT_SETMASK: 被set指向的值替代</li>
</ul>


<h1>sigpending函数</h1>

<p>sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigpending(sigset_t *set);</span></code></pre></td></tr></table></div></figure>


<p>注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_quit(int);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t oldset, newset, quitset;
</span><span class='line'>  sigemptyset(&quitset);
</span><span class='line'>  sigaddset(&quitset, SIGINT);
</span><span class='line'>
</span><span class='line'>  // ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  } 
</span><span class='line'>  // ************
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_BLOCK, &quitset, &oldset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  // sleep 5 seconds
</span><span class='line'>  sleep(5);
</span><span class='line'>  if (sigpending(&newset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("pending err \n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if (sigismember(&newset, SIGINT))
</span><span class='line'>      printf("sigquit is block\n");
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &oldset, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask ret sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  printf("sig int unblock\n");
</span><span class='line'>  sleep(5);
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_quit(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("sigquit catch\n");
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>sigaction函数</h1>

<p>sigaction函数的功能是<em>检查</em>或<em>修改</em>与指定信号相关联的处理动作（或同时执行）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
</span><span class='line'>// 成功，返回0，出错返回-1
</span></code></pre></td></tr></table></div></figure>


<p>对于参数：</p>

<ul>
<li>signo是信号</li>
<li>act非空，则修改信号动作</li>
<li>oact非空，则由oact返回上一个动作</li>
</ul>


<p>结构体struct sigaction的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct sigaction {
</span><span class='line'>  void (*sa_handler)(int); // 信号处理函数的地址，或者SIG_IGN或SIG_DFL
</span><span class='line'>  sigset_t sa_mask; // 额外需要阻塞的信号集
</span><span class='line'>  int sa_flags;  // 信号选项，可以设置这个选项来控制处理函数行为
</span><span class='line'>
</span><span class='line'>  /*替换的处理程序，当指定sa_flags为SA_SIGINFO时，采用这个处理函数，提供了额外的一些信息*/
</span><span class='line'>  void (*sa_sigaction)(int, siginfo_t *, void *);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>若更改信号处理函数，则：
* sa_handler指定处理函数的地址
* sa_mask则是信号集，在调用该信号处理函数之前，会先把这个信号集指定的信号加到进程的信号屏蔽字中。信号处理函数返回时，再复原。在信号处理程序被调用时，操作系统建立的新信号屏蔽字也包括正在被递送的信号，这会保证在当前信号处理时，这个信号再次发生，会一直阻塞，直到处理函数完成。
* sa_flags字段指定对信号处理的各个选项:</p>

<blockquote><ul>
<li>SA_RESTART:由此信号中断的系统调用自动重新启动</li>
<li>SA_INTERRUPT: 由此信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 有此选项对信号，会调用sa_sigaction函数，此函数会给额外提供了附加信息：1）指向siginfo结构的指针；2）指向进程上下文标识符的指针</li>
</ul>
</blockquote>

<p>注意：</p>

<blockquote><p>除了那些为了兼容而继续保留原始的signal函数的语义的系统外，大部分系统都是用sigaction来实现signal函数的。</p></blockquote>

<h1>sigsetjmp和siglongjmp函数</h1>

<p>在捕捉到一个信号时，会进入信号捕捉函数，此时会发生：</p>

<ul>
<li>进入信号处理函数时，当前信号会被自动加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序</li>
<li>当正常从信号处理函数中返回时，会自动恢复当前信号为非屏蔽</li>
</ul>


<p>但是，当在信号处理函数内，调用了longjmp函数，那么是否恢复这个被屏蔽的当前信号？</p>

<p>FreeBSD 5.2.1 和Mac OS X10.3中，setjmp和longjmp保持和恢复信号屏蔽字</p>

<p>Linux2.4.22和Solaris9 并不执行这种操作。FreeBSD 5.2.1 和Mac OS X10.3提供函数<em>setjmp和</em>longjmp，他们不保存和恢复信号屏蔽字</p>

<p>为了允许两种形式的行为存在， POSIX.1并没有说明setjmp和longjmp对屏蔽字的作用，而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部跳转是，使用这两个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt; // 与setjmp和longjmp一个头
</span><span class='line'>
</span><span class='line'>int sigsetjmp(sigjmp_buf env, int savemask); // 直接调用，返回0，若从siglongjmp调用返回，则返回非0值
</span><span class='line'>
</span><span class='line'>void siglongjmp(sigjmp_buf env, int val);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>若savemask非零，则env保存进程的当前屏蔽字。并在siglongjmp调用时，恢复由env保存进程的当前屏蔽字。</p>

<p>涉及到信号时，使用sigsetjmp和siglongjmp的典型使用模板是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static sigjmp_buf;
</span><span class='line'>static volatile sig_atomic_t canjump;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>// 在主函数中
</span><span class='line'>if (sigsetjmp(jmpbuf, 1)) {
</span><span class='line'>  ....
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>canjump = 1; // 调用sigsetjmp后才设置canjump为非零
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 然后，在信号处理程序中，这样：
</span><span class='line'>void sig_handler(int) {}
</span><span class='line'>
</span><span class='line'>if (canjmp == 0) // 只有非零时，才调用siglongjmp
</span><span class='line'>  return
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>siglongjmp(jmpbuf, 1);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<blockquote><p>原因：
之所以使用canjump，主要是保护机制，防止当jmpbuf还没有被sigsetjmp初始化时，就调用了信号处理程序。
在非信号环境下没有问题，但在信号环境下，信号是随时发生的，因此需要保护</p></blockquote>

<h1>sigsuspend函数</h1>

<p>屏蔽进程的信号，使用这种技术，可以保护不希望由信号中断的代码临界区。然后在临界区之后等待以前的信号发生。</p>

<p>但是下面的实现方式有问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sigprocmask(SIG_BLOCK, &newmask, &oldmask);
</span><span class='line'>
</span><span class='line'>// .....临界区代码
</span><span class='line'>
</span><span class='line'>1) sigprocmask(SIG_BLOCK, &oldmask, NULL);
</span><span class='line'>2) pause(); // 等待之前阻塞的信号发生
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，1）和2）代码出有问题，会有竞争条件，在sigprocmask和pause之间有可能信号会发生，这会导致pause无法返回，永远阻塞。</p>

<p>解决这个竞争条件的办法就是让这两个操作合并成一个原子操作。这就是sigsuspend函数的由来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigsuspend(const sigset_t * sigmask);
</span></code></pre></td></tr></table></div></figure>


<p>用sigsuspend实现临界区代码，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_int(int signo);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  sigset_t newsigset, oldsigset, waitsigset;
</span><span class='line'>  sigemptyset(&newsigset);
</span><span class='line'>  sigaddset(&waitsigset, SIGUSR1);
</span><span class='line'>  struct sigaction act;
</span><span class='line'>  act.sa_handler = sig_int;
</span><span class='line'>
</span><span class='line'>  if(sigaction(SIGINT, &act, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("siganction err.\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(sigprocmask(SIG_BLOCK, &newsigset, &oldsigset) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  // code procted
</span><span class='line'>  printf("this is procted code!\n");
</span><span class='line'>
</span><span class='line'>  if(sigsuspend(&waitsigset) != -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigsuspend err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf("after sigsuspend\n");
</span><span class='line'>  if(sigprocmask(SIG_SETMASK, &oldsigset, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("revert old sig mask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_int(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("catch signo %d\n", signo);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sigsuspend函数实现的巧妙之处：</p>

<ul>
<li>为了实现解除屏蔽（sigprocmask）和等待（pause），sigsuspend把进程的屏蔽信号设置为参数信号，并在返回后设置为调用sigsuspend之前的屏蔽信号值。</li>
</ul>


<p>sigsuspend函数还有两种经典应用：</p>

<ol>
<li>等待一个信号处理程序设置一个全局变量</li>
<li>父子进程实现同步</li>
</ol>


<p>注意：在实现父子进程通讯，可以使用kill给对象发信号，并使用sigsuspend等待某种条件</p>

<h1>abort函数</h1>

<p>abort函数使异常程序终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void abort(void);
</span></code></pre></td></tr></table></div></figure>


<p>这个函数将SIGABRT信号发送给调用进程。</p>

<p>ISO C规定 abort的实现须向主机环境递送一个成功的通知，一般是通过raise(SITABRT)或kill(gitpid(), SIGABRT)实现，这个规定，允许程序做清理工作。</p>

<p>一般系统的abort实现，都会冲洗输出流以及是否要删除临时文件。</p>

<p>可以看一下abort的函数实现示例，通过这个示例，学会：</p>

<ul>
<li>sigaction函数的使用</li>
<li>kill函数的使用：kill函数可以给其它进程发送信号。若发给本进程，并且此信号是不被阻塞的，那么kill返回之前，该信号（或某个未决、未阻塞的信号）就被传送给了该进程。这样，kill返回了，就知道该进程一定捕捉到该信号。</li>
</ul>


<h1>system函数</h1>

<p>ISO C定义了system函数，这个函数可以执行系统命令，这个函数的实现也牵扯到信号问题。若不处理，会有问题。</p>

<p>这里通过system的实现，注意信号程序开发的各种问题。</p>

<p>看下面调用过程：
<img src="/images/assets/Figure10-1.png" title="time-function" alt="alt text" /></p>

<p>若没有处理信号，问题有：</p>

<ul>
<li>若进程（a.out）捕获SIGCHID信号，当system创建的子进程结束，系统会向父进程（a.out）发送SIGCHID信号，父进程会捕捉。<em>但这阻止了system函数获取它自己创建子进程的状态</em></li>
<li>若system系统没有屏蔽中断和退出信号，则如果想给shell调用程序发送中断信号时，系统会同时向负责进程发送信号（因为都属于前台进程组）</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">enwu</span></span>

      








  


<time datetime="2014-06-24T20:00:20+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/linux/'>linux</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://baren.github.io/blog/2014/06/24/signal/" data-via="" data-counturl="http://baren.github.io/blog/2014/06/24/signal/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/05/04/process-relate/" title="Previous Post: apue(进程关系)">&laquo; apue(进程关系)</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/08/28/pthread/" title="Next Post: apue(线程)">apue(线程) &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow/">程序结构和控制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/06/octopress-syntax/">octopress syntax</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/06/linux-performance-observability-tools/">linux performance observability tools</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/28/pthread/">apue(线程)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/24/signal/">apue(信号)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/04/process-relate/">apue(进程关系)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/04/process-control/">apue(进程控制)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/22/python-note/">python杂记</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - enwu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a href="http://www.gehaxelt.in">Gehaxelt</a></span>
  <span class="credit">and <a href="http://www.it-solutions-neef.de">IT Solutions Neef</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
