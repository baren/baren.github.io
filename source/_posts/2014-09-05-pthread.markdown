---
layout: post
title: "apue(线程)"
date: 2014-08-28 20:00:53 +0800
comments: true
categories: linux
---


[system]: /images/assets/Figure10-1.png "time-function"

# 线程概念

主要是POSIX线程，也就是pthread。

正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。

判断系统是否支持pthread，可以使用宏_POSIX_THREADS进行测试，还可以把_SC_THREADS传递给sysconf函数来运行时判断。

线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：

* 进程之间共享数据非常困难
* 使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。

使用线程，解决这上面这些问题：

* 线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。
* 线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。

除了共享全局内存，线程还共享一些其他属性，包括

* 进程id和父进程id
* 进程组合session id
* 控制终端
* 进程凭证（用户和组id）
* 打开的文件描述符（比较重要）
* 信号处理
* 文件系统相关信息：umask、当前工作目录和根目录
* 等

下面是各个线程不同的属性：

* 线程id
* 信号mask
* 线程私有数据
* errno变量
* 等

<!-- more -->

## 线程和errno

进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。

这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。

注：
> 在线程中，使用函数的返回错误码更为清晰整洁。

## 线程ID

进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用```pid_t```来表示；线程的ID，使用```pthread_t```类型来表示。

为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。

下面是处理线程ID的函数：

```
#include <pthread.h>
// 比较两个线程ID
int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值

// 获取线程的ID
pthread_t pthread_self(void);

```

# 线程创建

使用pthread_create函数创建线程：

```
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start)(void *), void *arg);

// 成功返回0

```

这个函数的参数意义是：

* thread——线程创建成功后，将线程的ID写入这个指针指向的内存中
* attr——创建线程的属性
* start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数
* arg——无类型指针参数，作为线程执行函数的参数传入

# 线程终止

* 进程终止会导致线程终止：
	- 任一线程调用了exit，_Exit或_exit函数，整个进程终止
	- 若信号的默认动作是终止进程，则把信号发送到线程会终止进程

* 单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。
	- 线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）
	- 线程可以被同一进程中的其它线程取消（pthread_cancel）
	- 线程调用pthread_exit函数退出

```
#include <pthread.h>
void pthread_exit(void *retval);

```

pthread_exit接收的参数，就是线程的返回值。

其它线程可以通过pthread_join获取这个值。

注意：
> pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
> pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。


## pthread_join函数

pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。

```
include <pthread.h>
int pthread_join(pthread_t thread, void **retval); // 成功，返回0

```

如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。

注意：
> 如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。

如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程

还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &status, options)); 等待任意进程，线程没有这个操作。

## pthread_detach函数

默认情况下，线程是可*结合的（joinable）*，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。

某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是*分离的（detached）*。

```
#include <pthread.h>
int pthread_detach(pthread_t thread);
// 成功返回0

```

注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。

# 线程参数传递和返回值

在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。

* 在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数
* 当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：
> * 在线程执行函数返回一个指针
> * 调用pthread_exit()，把返回值指针作为pthread_exit的参数

例子：

```
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
#include <string.h>

/* **************************************************************************/
/*  our macro for errors checking                                           */
/* **************************************************************************/
#define COND_CHECK(func, cond, retv, errv) \
if ( (cond) ) \
 { \
    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
	              __FILE__,__LINE__,func,retv,strerror(errv)); \
				     exit(EXIT_FAILURE); \
 }

#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)




void *th_func1(void *arg);
void *th_func2(void *arg);
void test_thread_ret();

int main(int argc, char *argv[])
{
	test_thread_ret();
	return 0;
}

void test_thread_ret()
{
	int t_ret;
	// pthread ret
	pthread_t t1, t2;
	void *tret;
	t_ret = pthread_create(&t1, NULL, th_func1, NULL);
	PthreadCheck("pthread_create", t_ret);
	t_ret = pthread_create(&t2, NULL, th_func2, (void *)2);
	PthreadCheck("pthread_create", t_ret);

	printf("join t1\n");
	t_ret = pthread_join(t1, &tret);
	PthreadCheck("pthread_join", t_ret);
	printf("ret of thread 1 is %d.\n", (int) tret);

	printf("join t2\n");
	t_ret = pthread_join(t2, &tret);
	PthreadCheck("pthread_join", t_ret);
	printf("ret of thread 2 is %d.\n", (int) tret);

}
void *th_func1(void *arg)
{
	printf("thread 1 runing\n");
	return (void *)1;
}

void *th_func2(void *arg)
{
	int * a;
	a = (int *)arg;
	printf("thread 2 arg is %d.\n", (int) a);
	pthread_exit((void *) 2);
}
```


# 取消线程

线程可以调用pthread_cancel函数*请求*取消同一进程中的其它线程。

```
#include <pthread.h>

int pthread_cancel(pthread_t tid);

```

pthread_cancel并不等待线程终止仅仅提出请求。

线程在取消请求发出后还继续运行，直到线程打到某个*取消点*。取消点是线程检查是否被取消并按照请求进行动作的一个位置。

# 线程同步

有三种同步方式：互斥量、读写锁以及条件变量

## 互斥量

互斥量用pthread_mutex_t数据类型表示，使用互斥量之前必须对其进行初始化
* 初始化为常量PTHREAD_MUTEX_INITIALIZER，前提是pthread_mutex_t为静态分配的
* 调用pthread_mutex_init函数初始化动态分配的pthread_mutex_t变量。

注意： 
* 如果pthread_mutex_t是动态分配的（比如通过malloc），则须用pthread_mutex_destory函数来师傅内存。

```c

int pthread_mutex_init(pthread_mutex_t *restrict mutex, pthread_mutexattr_t *attr);
int pthread_mutex_destory(pthread_mutex_t *mutex)

```

对互斥量加锁解锁函数


```

#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

```

对互斥量要找到平衡点，既不使锁得粒度太粗导致线程阻塞，又不能因为锁得粒度太细导致代码复杂性和过多锁导致性能下降。

## 读写锁

与互斥量类似，但是读写锁具有更高的并行性。读写锁有三种状态：
* 读模式下的锁状态
* 写模式下的加锁状态
* 不加锁状态

对于读写锁，有几个特征：

* 一次只能有一个线程可以占有写锁，但是多个线程可以同时占用读锁。
* 当处于写锁状态时，所有试图对其进行加读锁的线程，都会被阻塞
* 当处于读锁状态时，所有试图对齐进行加读锁的线程，都可以立即获得
* 如果在读锁状态下，线程希望以写锁对此锁进行加锁，必须阻塞直到线程释放获的的读锁才可以加上写锁。
* 为了防止一直处于读锁中而使写锁一直阻塞，一旦进行加写锁阻塞，会阻塞后续对其进行的增加读锁行为。

读写锁也叫共享-独占锁。

对读写锁也需要初始化和销毁操作。

```c

#include <pthread.h>

int pthread_rwlock_init(pthread_rwlock_t rwlock, pthread_rwlockattr_t * attr);
int pthread_rwlock_destory(pthread_rwlock_t *rwlock);


```

读写锁加锁操作

```
#include <pthread.h>
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

// 实现读写锁的时候，可能会对共享模式下可获取的锁进行数量限制，因此要检查pthread_rwlock_rdlock()的返回值。

```

## 条件变量


mutex阻止了多个线程同时访问共享的变量。
条件变量允许一个线程在共享的变量状态改变的时候通知其他线程这个改变，并允许其它线程等待（block）这个通知。

下面代码，没有使用条件变量，只是使用互斥量来实现，来证明在特定情况下，条件变量的用处。

```c
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; 
static int avail = 0;  // 表示可消费的数目

// 在生产线程中的代码

s = pthread_mutex_lock(&mtx);
if (s != 0)
	errExitEN(s, "pthread_mutex_lock");

avail++; /* 仅仅表示有可用资源，其它步骤省略*/

s = pthread_mutex_unlock(&mtx); 

if (s != 0)
	errExitEN(s, "pthread_mutex_unlock");

// 在主线程中，主要用来消费生产线程生产的数据

for (;;) {
	s = pthread_mutex_lock(&mtx);
    if (s != 0)
		errExitEN(s, "pthread_mutex_lock");

	while (avail > 0) { /* 消耗生产的数据 */ 
		/* 用生产的数据做一些其它时期 */
		avail--;
	}
	s = pthread_mutex_unlock(&mtx); 
	if (s != 0)
		errExitEN(s, "pthread_mutex_unlock");
}


```

上面用互斥量实现的生产者消费者同步代码，问题有：

1. 空耗CPU，会一直持续循环来检查avail的状态

条件变量解决了这个问题，允许消费进程在没有数据的时候挂起（wait），当有数据的时候通知线程。

条件变量通常与互斥量联合使用：

* 互斥量保护共享变量的修改
* 条件变量则用来通知状态的修改

条件变量在使用前必须初始化，跟互斥量一样，既可以静态初始化，也可以动态初始化。

```c
// 静态
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// 动态，pthread_cond_t变量是动态分配的。需要调用下面函数

#include <pthread.h>
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

int pthread_cond_destroy(pthread_cond_t *cond);
```

## 基于条件变量的通知和等待

条件变量的主要操作就是signal（通知）和wait（等待），通知可以一次给一个线程通知，也可以广播给所有等待线程。
wait操作是等待，直到有通知到来。

```c

#include <pthread.h>
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
const struct timespec *abstime);

```

下面代码是使用条件变量的典型代码：

```c 消耗线程代码

pthread_mutex_lock(&mutex);         /* 锁住互斥量          */
while (!predicate) {                    /* 检查 predicate      */
	pthread_cond_wait(&condvar,&mutex);   /* go to sleep - recheck pred on awakening    */

}
pthread_mutex_unlock(&mutex); 

```

pthread_cond_wait() 做了以下事情：

* 释放互斥量的锁
* 让线程进入休眠状态（sleep）

当某个线程进入休眠状态，需要有其它线程唤醒它，这就是生产线程：

```c 生产线程

pthread_mutex_lock(&mutex);         		/* 锁住互斥量       */
predicate=1;                            	/* 设置 predicate    */
pthread_cond_broadcast(&condvar);   		/* 唤醒每一个等待条件变量的线程     */
pthread_mutex_unlock(&mutex);               /* 解锁互斥量     */
```

这里，重要的调用是pthread_cond_broadcast()，他会唤醒每一个等待条件变量的线程。第一个被唤醒的线程还是处于pthread_cond_wait函数调用中。然后，pthread_cond_wait完成了下面操作：

* 重新获得互斥量锁。

然后执行就再次检查predicate。

### 条件变量实际例子（join任何终止的线程）

使用pthread_join仅仅可以等待一个指定的线程，并没办法join任何终止的线程。使用条件变量可以实现。














