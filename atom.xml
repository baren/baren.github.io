<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Baren Blog]]></title>
  <link href="http://baren.github.io/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2016-03-04T16:11:12+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python 函数知识]]></title>
    <link href="http://baren.github.io/blog/2016/03/02/python-function/"/>
    <updated>2016-03-02T19:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2016/03/02/python-function</id>
    <content type="html"><![CDATA[<h1>函数命名空间</h1>

<p>每次函数执行，都会创建一个 local namespace。用来存放在函数内定义的变量。</p>

<p>在函数内引用一个变量，python查找这个变量的顺序是：</p>

<ul>
<li>局部空间</li>
<li>全局空间（函数定义所在的模块定义的变量）</li>
<li>built-in namespace</li>
</ul>


<p>如果找不到，则抛出NameError。</p>

<p>如果想要在函数内修改全局变量值，则需要用global关键字声明，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="mi">37</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="k">global</span> <span class="n">a</span>   <span class="c"># &#39;a&#39; is in global namespace</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'>  <span class="n">b</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="c"># a is now 13. b is still 37.</span>
</span></code></pre></td></tr></table></div></figure>


<h2>内嵌函数的命名空间</h2>

<p>函数内也可以定义函数，这叫nested function。内嵌函数的包围函数被称作外围函数（outer function）。在内嵌函数内绑定的变量是定义在词法空间（lexical scoping），在内嵌函数内，引用变量的顺序是：</p>

<ul>
<li>lexical scoping</li>
<li>局部空间</li>
<li>全局空间（函数定义所在的模块定义的变量）</li>
<li>built-in namespace</li>
</ul>


<p>在内嵌函数内，可以访问包围其函数内定义的变量（对内嵌函数来说，外围函数定义的变量被称作自由变量 free variables），但是不能再内嵌函数中重新绑定其外围函数定义的变量。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
</span><span class='line'>        <span class="n">b</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">inner</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">test</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="err">结果是：</span>
</span><span class='line'><span class="ne">UnboundLocalError</span><span class="p">:</span> <span class="n">local</span> <span class="n">variable</span> <span class="s">&#39;b&#39;</span> <span class="n">referenced</span> <span class="n">before</span> <span class="n">assignment</span>
</span></code></pre></td></tr></table></div></figure>


<p>只能在内嵌函数的最外层函数和全局空间内更改变量（python3用nonlocal关键字解决这个问题）。</p>

<h2>闭包</h2>

<p>函数是first-class对象，因此，函数可以：</p>

<ul>
<li>赋值给变量</li>
<li>作为参数传递给函数</li>
<li>作为函数结果返回</li>
<li>存放在数据结构中</li>
</ul>


<p>当把函数作为数据处理时，函数会隐含的带着一些额外的相关信息，这些相关信息就是函数定义处的一些数据。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># foo.py</span>
</span><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="k">def</span> <span class="nf">callf</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>观察行为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">foo</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">37</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">helloworld</span><span class="p">():</span>
</span><span class='line'><span class="o">...</span>        <span class="k">return</span> <span class="s">&quot;Hello World. x is </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">callf</span><span class="p">(</span><span class="n">helloworld</span><span class="p">)</span>  <span class="c"># Pass a function as an argument &#39;Hello World. x is 37&#39;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里结果是helloworld定义位置的x的值，而不是执行位置的x的值。</p>

<p>闭包定义：</p>

<p>闭包是在其词法上下文（内嵌函数内部）中引用了自由变量（外围函数定义的变量）的函数。主要用途是当有需要延迟计算的情况，用闭包更简洁。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">urlopen</span>
</span><span class='line'><span class="c"># from urllib.request import urlopen (Python 3) </span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">page</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>  <span class="c"># 引用了自由变量url，这个值取自定义函数的时候</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">get</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用闭包例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.python.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x95d5f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.jython.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x9735f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">pydata</span> <span class="o">=</span> <span class="n">python</span><span class="p">()</span> <span class="c"># Fetches http://www.python.org</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jydata</span> <span class="o">=</span> <span class="n">jython</span><span class="p">()</span>     <span class="c"># Fetches http://www.jython.org</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>看上面的例子，当调用page函数时，返回的是内嵌函数，并没有立即执行，但是打开的url是固定的了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 模块知识]]></title>
    <link href="http://baren.github.io/blog/2016/02/26/python-model/"/>
    <updated>2016-02-26T19:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2016/02/26/python-model</id>
    <content type="html"><![CDATA[<h1>模块对象</h1>

<p>每一个源文件就是对应一个model。
模块与模块之间的依赖通过import和from语句进行关联。
在其它语言中，有全局变量可供模块之间共享，python中，全局变量在模块间不共享，只属于一个模块。</p>

<p>模块名与模块的文件名是一样的。</p>

<p>模块也是一个对象，因此可以将模块作为参数传递，赋值给变量或存数容器，作为函数结果返回等。是<em>first-class</em>对象。</p>

<p>import语句的语法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">modname</span> <span class="p">[</span><span class="k">as</span> <span class="n">varname</span><span class="p">][,</span><span class="o">...</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>这行语句执行完成，会把变量modname绑定到模块对象上。</p>

<p>模块内的语句，在第一次被import时执行。模块对象先于语句执行而创建，并存放在<code>sys.modules</code>中。</p>

<h2>模块属性</h2>

<p>import语句会为模块内的所有属性创建一个模块的命名空间（只有第一次import才会执行模块内语句）。模块体内的语句就是在这个命名空间内创建和绑定模块的属性，def创建函数属性，class创建类属性等等。</p>

<p>除了模块体明确定义的属性，在执行模块内语句之前，import还会额外给模块创建一些属性：</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p">[</span><span class="s">&#39;__all__&#39;</span><span class="p">,</span> <span class="s">&#39;__builtins__&#39;</span><span class="p">,</span> <span class="s">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s">&#39;__file__&#39;</span><span class="p">,</span> <span class="s">&#39;__get_builtin_constructor&#39;</span><span class="p">,</span> <span class="s">&#39;__name__&#39;</span><span class="p">,</span> <span class="s">&#39;__package__&#39;</span><span class="p">,</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>dict</strong> : 用这个字典对象作为模块属性的命名空间。<strong>dict</strong>在模块内不能直接使用，其它（比如<strong>file</strong>，因为是在执行语句之前就创建好了）可以。对于模块M来说，M.S=x 实际上恒等于M.<strong>dict</strong>[&rsquo;S&#8217;]=x.</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">print</span> <span class="n">__file__</span>
</span><span class='line'><span class="k">print</span> <span class="n">__dict__</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">work</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">auto_deploy</span><span class="o">/</span><span class="n">tst</span><span class="o">.</span><span class="n">py</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;/Users/user/work/project/auto_deploy/tst.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">__dict__</span>
</span><span class='line'><span class="ne">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s">&#39;__dict__&#39;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>name</strong>：模块名</li>
<li><strong>file</strong>：模块文件</li>
<li><strong>doc</strong>：注释</li>
</ul>


<h2>模块私有化属性</h2>

<p>python模块没有真正的私有化属性，按照惯例，只要在模块内定义的属性是以单下划线开头，就认为是私有的，比如_secret.</p>

<h2>模块加载</h2>

<p>实际上，python加载模块是靠内置的<code>__import__</code>函数进行的。我们也可以直接调用这个函数。import M，<code>__import__</code>会先用key M去查sys.modules，如果在里面，直接返回值；如果不在，<code>__import__</code>会创建一个空模块对象，并增加<code>__name__</code>属性，其值是M，并把这个模块赋值给 sys.modules[M] ，然后按照正确方式加载模块对象（后面有）。因此只有第一次import一个对象时是慢的，以后直接从sys.modules对象中返回。</p>

<h3>在磁盘系统搜索模块</h3>

<p>当加载一个模块，先检查是否是内置对象（在sys.builtin_module_names 中列出），如果不在，则从磁盘中搜索。</p>

<p><em><strong>import</strong></em>会按照sys.path列表中存的路径顺序一个个搜索模块。sys.path中既可以是目录，也可以是zip格式的归档文件。python启动时，会用PYTHONPATH来初始会sys.path。sys.path的第一个字符串总是程序启动的当前目录。</p>

<p>因此，可以通过修改sys.path来操纵搜索逻辑。</p>

<h3>重新加载模块</h3>

<p>可以通过调用reload.reload(M)函数重新加载模块，reload函数的参数是M对象，而不是字符串。通过重新加载模块，影响的是通过import M这种方式，并通过M.A进行访问的代码。那种通过from M import 引入的则不受影响。</p>

<h3>循环引用</h3>

<p>python允许循环引用，比如a.py中import b，而b.py中import a。</p>

<p>已import a为例说明循环引用的加载逻辑</p>

<p>循环引用的执行过程：</p>

<p>import a语句会创建一个空模块对象，并赋值给sys.models[&lsquo;a&rsquo;] ,
然后开始执行a模块语句，如果遇到import b，则开始加载模块b，同样创建模块对象，并赋值给sys.models[&lsquo;b&rsquo;].
执行模块b的语句。这是a模块的语句执行是阻塞的，直到b执行完成。</p>

<p>这样，执行模块b的body时，遇到import a，则由于之前已经通过赋值sys.models[&lsquo;a&rsquo;]有数据，因此直接返回这个未初始化完成的a模块对象。这样，有可能a中的属性还没有被初始化。</p>

<h1>包</h1>

<p>python中，一个目录下需要定义<code>__init__</code>.py文件，才能标记这个目录是个包。包的体就是<code>__init__.py</code>文件内容。</p>

<p>导入包的时候，会首先执行<code>__init__.py</code>内容。</p>

<h2>包的特殊属性</h2>

<p>包P的<code>__file__</code>的值实际上是包P体的内容，也就是<code>P/__init__.py</code>的路径。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">view</span>
</span><span class='line'><span class="k">print</span> <span class="n">view</span><span class="o">.</span><span class="n">__file__</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">work</span><span class="o">/</span><span class="n">project</span><span class="o">/</span><span class="n">m</span><span class="o">-</span><span class="n">api</span><span class="o">/</span><span class="n">view</span><span class="o">/</span><span class="n">__init__</span><span class="o">.</span><span class="n">pyc</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以在<em>P/<strong>init</strong>.py</em>中设置<em><strong>all</strong></em>全局变量，用来控制其他模块执行<code>from P import *</code>语句时的行为。如果没有设置这个属性，则<code>from P import *</code>不会导入任何P的模块。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[man bash 解释]]></title>
    <link href="http://baren.github.io/blog/2016/01/20/man-bash/"/>
    <updated>2016-01-20T15:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2016/01/20/man-bash</id>
    <content type="html"><![CDATA[<h3>bash -c string 用法</h3>

<p>如果指定-c，表示命令从string中读取，如果string后面带着参数，则将参数赋值给位置参数（posi-tional parameters），从$0开始。</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sh -c 'echo $0' a</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计系统设计]]></title>
    <link href="http://baren.github.io/blog/2015/03/22/statis-udp/"/>
    <updated>2015-03-22T15:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2015/03/22/statis-udp</id>
    <content type="html"><![CDATA[<h1>需求</h1>

<p>主要用来实时统计线上所依赖服务的运行情况。</p>

<p>以分钟为最小统计维度，可以按照多个维度进行统计，比如一分钟实时状况，5分钟实时状况，10分钟实时状况。</p>

<p>所统计的数据包括依赖服务的实时错误数、成功数。</p>

<h1>设计思路</h1>

<p>由于统计需求比较明确，并需要短时间内需要上线，因此暂时不能适用storm这种对机器资源需求量比较大的场合。</p>

<p>为了保证后续可以顺利使用storm等分布式实时计算系统，其数据格式使用与storm容易处理的的nginx日志格式。</p>

<p>数据传输协议采用UDP方式。</p>

<h1>各子系统</h1>

<p>分为三个部分：</p>

<ul>
<li>发送日志模块。采用嵌入到工程代码中的方式使用。</li>
<li>数据接收系统。单独部署一个udp系统，负责接收数据，并把数据写入memcached。</li>
<li>数据展示系统。负责将memcached的数据整理后写入数据库，并以图表方式展示。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yield（generator和coroutine）]]></title>
    <link href="http://baren.github.io/blog/2015/03/22/python-yield/"/>
    <updated>2015-03-22T15:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2015/03/22/python-yield</id>
    <content type="html"><![CDATA[<p>主要介绍python中yield的用法。在python中，与yield关键字相关的语法有generator和coroutine，这里会分别介绍这两种语法。</p>

<!-- more -->


<h1>generator</h1>

<p>一个函数，正常情况下，会返回一个值，但是generator，返回的是值的序列，而不是一个值。在python中，用yield来实现，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Counting down from </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>        <span class="k">yield</span> <span class="n">n</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&#39;after yield&#39;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数内使用yield关键字的函数，跟普通函数不一样，函数的调用并不会执行函数体，而是返回一个generator对象，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># 没有执行第一行的print语句</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">countdown</span> <span class="n">at</span> <span class="mh">0x10695ba00</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>要想执行函数体，可以使用</p>

<ul>
<li>generator的next()函数或者</li>
<li>for语句，sum()或者其它消费集合的操作。</li>
</ul>


<h2>next()函数</h2>

<p>generator的调用过程：</p>

<ol>
<li>当在generator上调用next()函数，会执行函数体，直到遇到yield关键字。然后</li>
<li>yield生成一个值，</li>
<li>并且在这点，函数被挂起，直到下一个next()函数调用。然后，</li>
<li>函数继续从yield语句后面执行。</li>
</ol>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">countdown</span> <span class="n">at</span> <span class="mh">0x10695ba00</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<p>当generator返回时（return），迭代停止，这时候，再调用next()函数，抛出StopIteration异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'><span class="ne">StopIteration</span>
</span></code></pre></td></tr></table></div></figure>


<h2>迭代generator</h2>

<p>还可以使用for语句迭代generator，比如：</p>

<p>for n in countdown(10):
    print n</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">n</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">9</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>停止generator</h2>

<p>停止一个generator，通过：</p>

<ul>
<li>return语句返回</li>
<li>抛出一个StopIteration异常</li>
</ul>


<p>如果generator停止了，继续调用next()函数，会抛出StopIteration异常。</p>

<h2>close()函数</h2>

<p>为了防止一个generator没有停止，提供了close()函数来主动停止generator，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span><span class='line'>        <span class="k">break</span>
</span><span class='line'>    <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面程序中，for循环在生成2的时候停止了，这时候countdown并没有完全执行完成，当生成器不再调用时，调用close关闭它。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'><span class="ne">StopIteration</span>
</span></code></pre></td></tr></table></div></figure>


<p>在generator内部，close函数调用会导致在yield语句上抛出GeneratorExit异常，因此可以在generator内部可选择的捕获这个异常（不捕获也不会抛出异常，就像上面例子中c.close()并没有出错），来做一些清理工作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Counting down from </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>            <span class="k">yield</span> <span class="n">n</span>
</span><span class='line'>            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Only made it to </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>协程和yield表达式</h1>

<p>yield关键字还可以作为表达式，出现在赋值表达式右边。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">receiver</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Ready to receive&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>以这样的方式使用yield的函数，被称作协程。</p>

<p>与generator一样，执行这种协程函数时，调用函数并不会执行，必须先调用next()函数或者send(None)才可以执行函数，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Ready</span> <span class="n">to</span> <span class="n">receive</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">Got</span> <span class="mi">1</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">Got</span> <span class="mi">2</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#39;Hello&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">Got</span> <span class="n">Hello</span>
</span></code></pre></td></tr></table></div></figure>


<p>协程函数执行步骤是：</p>

<ol>
<li>先调用next()，执行协程函数，函数执行到yield表达式后挂起，等待接收send函数发给它的数据</li>
<li>调用send函数，传递给send函数的值会被协程函数内的&#8221;(yield)&ldquo;表达式返回</li>
<li>协程接收到数据，恢复执行，直到遇到下一个yield表达式</li>
</ol>


<blockquote><p>注意：
对协程函数来说，在接收数据之前，需要先执行函数体，可以使用next()和send(None)来执行。
如果调用send(非None值)，则会抛出TypeError错误：
c.send(1)
Traceback (most recent call last):
 File &ldquo;<stdin>&rdquo;, line 1, in <module>
ypeError: can&rsquo;t send non-None value to a just-started generator
.</p></blockquote>

<p>与generator一样，关闭一个协程，有两种方式：</p>

<ul>
<li>调用close函数</li>
<li>自己返回</li>
</ul>


<p>一个关闭的协程函数，如果再发送数据给它，则会抛出StopIteration异常，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'><span class="ne">StopIteration</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用close()函数，会在协程函数内部生成GeneratorExit异常。因此，可以捕获这个异常来做一些清理工作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">receiver</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Ready to receive&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Receiver done&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>throw函数</h1>

<p>generator和协程函数，都有throw函数。原型是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">throw</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Ready</span> <span class="n">to</span> <span class="n">receive</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">Got</span> <span class="mi">1</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">countdown</span>
</span><span class='line'><span class="ne">RuntimeError</span><span class="p">:</span> <span class="mi">3</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">4</span><span class="p">,</span> <span class="ow">in</span> <span class="n">receiver</span>
</span><span class='line'><span class="ne">RuntimeError</span><span class="p">:</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>g.throw(type, value, traceback)会抛出特定的异常（参数传的异常类型），抛出异常点是函数的挂起地点，也就是yield表达式地方，或者是当还没有调用next()函数时的函数的起始点。</p>

<p>如果：</p>

<ul>
<li>函数捕获了throw抛出的异常，并用yield生成了另一个值，那么这个值就是throw的返回值，比如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">receiver</span><span class="p">():</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">&quot;Ready to receive&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>     <span class="k">try</span><span class="p">:</span>
</span><span class='line'><span class="o">...</span>             <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'><span class="o">...</span>                     <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>                     <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>     <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
</span><span class='line'><span class="o">...</span>             <span class="k">print</span><span class="p">(</span><span class="s">&quot;Receiver done&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>             <span class="k">yield</span> <span class="s">&#39;here&#39;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">receiver</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Ready</span> <span class="n">to</span> <span class="n">receive</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">Got</span> <span class="n">a</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="s">&#39;exc&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">Receiver</span> <span class="n">done</span>
</span><span class='line'><span class="s">&#39;here&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>throw函数与next和send一样，只是throw会抛出参数指定的异常。</p>

<h1>使用yield既生成值，又接收值</h1>

<p>函数内，可以使用yield同时接收和生成值，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">line_splitter</span><span class="p">(</span><span class="n">delimiter</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">&quot;Ready to split&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class='line'><span class="o">...</span>     <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'><span class="o">...</span>             <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">result</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>             <span class="n">result</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">line_splitter</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Ready</span> <span class="n">to</span> <span class="n">split</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;a,b&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>其执行步骤：
1、第一个next()调用，使函数开始执行
2、到yield语句后，返回None语句，也就是result的初始值。
3、调用send函数，接收到的值赋值给line，并继续执行语句，send()的返回值是下一个yield生成的结果。</p>

<h1>使用generator和coroutine</h1>

<p>开发一个例子，tail -f的例子，把开头为#号的过滤掉，其它原样打印。</p>

<h2>generator使用例子：</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">g_tail</span><span class="p">(</span><span class="n">the_file</span><span class="p">):</span>
</span><span class='line'>    <span class="n">the_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="n">line</span> <span class="o">=</span> <span class="n">the_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
</span><span class='line'>            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span>
</span><span class='line'>        <span class="k">yield</span> <span class="n">line</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">g_filter_line</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">):</span>
</span><span class='line'>            <span class="k">yield</span> <span class="n">line</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">g_print_line</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">line</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;/tmp/thefile&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">g_print_line</span><span class="p">(</span><span class="n">g_filter_line</span><span class="p">(</span><span class="n">g_tail</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用generator，每个函数，都需要接收一个iterator或者叫generator数据，来驱动整个进程执行。</p>

<h2>coroutine例子</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">functools</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">crontine</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
</span><span class='line'>    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class='line'>        <span class="n">a</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span class='line'>        <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">a</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">c_tail</span><span class="p">(</span><span class="n">the_file</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
</span><span class='line'>    <span class="n">the_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="n">line</span> <span class="o">=</span> <span class="n">the_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
</span><span class='line'>            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span>
</span><span class='line'>        <span class="n">target</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@crontine</span>
</span><span class='line'><span class="k">def</span> <span class="nf">c_filter_line</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;#&quot;</span><span class="p">):</span>
</span><span class='line'>            <span class="n">target</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@crontine</span>
</span><span class='line'><span class="k">def</span> <span class="nf">c_print_line</span><span class="p">():</span>
</span><span class='line'>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>        <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">line</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用coroutine，不需要每个函数都加参数，流程驱动是通过send函数来实现。</p>

<h1>参考资料</h1>

<ol>
<li><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">http://www.dabeaz.com/coroutines/Coroutines.pdf</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0342/">https://www.python.org/dev/peps/pep-0342/</a></li>
<li><a href="http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/">http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/</a></li>
<li>python essential reference chapter 5</li>
<li><a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python/231855#231855">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python/231855#231855</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tornado源代码研究笔记]]></title>
    <link href="http://baren.github.io/blog/2015/03/22/python-tornado-source/"/>
    <updated>2015-03-22T15:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2015/03/22/python-tornado-source</id>
    <content type="html"><![CDATA[<p>主要记录研究tornado源代码的心得笔记。</p>

<!-- more -->


<h1>命令行参数解析</h1>

<p>使用tornado，通常需要解析命令行参数，来指定运行行为，比如是否开启调试模式，端口号是多少，日志文件位置等等。</p>

<p>tornado的命令行使用方式一般是这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">tornado.options</span> <span class="kn">import</span> <span class="n">define</span><span class="p">,</span> <span class="n">options</span>
</span><span class='line'><span class="n">define</span><span class="p">(</span><span class="s">&quot;port&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">8888</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;run on the given port&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</span><span class='line'><span class="n">define</span><span class="p">(</span><span class="s">&quot;mysql_host&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&quot;127.0.0.1:3306&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;Main user DB&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">define</span><span class="p">(</span><span class="s">&quot;memcache_hosts&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&quot;127.0.0.1:11011&quot;</span><span class="p">,</span> <span class="n">multiple</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
</span><span class='line'>       <span class="n">help</span><span class="o">=</span><span class="s">&quot;Main user memcache servers&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">connect</span><span class="p">():</span>
</span><span class='line'>    <span class="n">db</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">mysql_host</span><span class="p">)</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 后面会跟着下面语句，一般在启动函数内</span>
</span><span class='line'>
</span><span class='line'><span class="n">tornado</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parse_command_line</span><span class="p">()</span>  <span class="c"># 解析命令行传入参数</span>
</span><span class='line'><span class="c"># or</span>
</span><span class='line'><span class="n">tornado</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parse_config_file</span><span class="p">(</span><span class="s">&quot;/etc/server.conf&quot;</span><span class="p">)</span>  <span class="c"># 解析文件传入参数</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有的定义的参数，不管是在文件内定义的，还是通过命令行传入的，都保存到全局变量options里面。</p>

<p>甚至在模块内，也可以有自己的参数定义。其条件是比如在调用parse_command_line函数时，import这个模块。</p>

<p>这样通过define函数定义的参数和通过命令行传入的参数，都会存在options变量下面。这样使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">http_server</span> <span class="o">=</span> <span class="n">tornado</span><span class="o">.</span><span class="n">httpserver</span><span class="o">.</span><span class="n">HTTPServer</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
</span><span class='line'><span class="n">http_server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>问题是，python自带了解析命令行参数的模块<em>getopt</em>，tornado为啥不用这个，又自己写了这样的解析模块呢？</p>

<p>先了解下sys.argv和getopt模块。</p>

<h2>sys.argv介绍</h2>

<p>启动参数，会放在sys.argv下面，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># argecho.py</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">arg</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="err">$</span> <span class="n">python</span> <span class="n">argecho</span><span class="o">.</span><span class="n">py</span> <span class="n">abc</span> <span class="k">def</span>
</span><span class='line'><span class="nf">argecho</span><span class="o">.</span><span class="n">py</span>
</span><span class='line'><span class="n">abc</span>
</span><span class='line'><span class="k">def</span>
</span><span class='line'><span class="err">$ </span><span class="nf">python</span> <span class="n">argecho</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">help</span>
</span><span class='line'><span class="n">argecho</span><span class="o">.</span><span class="n">py</span>
</span><span class='line'><span class="o">--</span><span class="n">help</span>
</span><span class='line'><span class="err">$</span> <span class="n">python</span> <span class="n">argecho</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">m</span> <span class="n">kant</span><span class="o">.</span><span class="n">xml</span>
</span><span class='line'><span class="n">argecho</span><span class="o">.</span><span class="n">py</span>
</span><span class='line'><span class="o">-</span><span class="n">m</span>
</span><span class='line'><span class="n">kant</span><span class="o">.</span><span class="n">xml</span>
</span></code></pre></td></tr></table></div></figure>


<p>sya.argv仅仅已空格区分，然后依次记录启动，其中argv[0]是启动脚本名称。</p>

<p>python提供了getopt来方便解析argv的参数。</p>

<h2>getopt模块</h2>

<p>getopt函数支持下面几种参数定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">-</span><span class="n">a</span>
</span><span class='line'><span class="o">-</span><span class="n">bval</span>
</span><span class='line'><span class="o">-</span><span class="n">b</span> <span class="n">val</span>
</span><span class='line'><span class="o">--</span><span class="n">noarg</span>
</span><span class='line'><span class="o">--</span><span class="n">witharg</span><span class="o">=</span><span class="n">val</span>
</span><span class='line'><span class="o">--</span><span class="n">witharg</span> <span class="n">val</span>
</span></code></pre></td></tr></table></div></figure>


<p>getopt有三个参数：</p>

<ul>
<li>第一个参数是需要解析的参数列表，一般是从argv[1]开始：sys.argv[1:]。</li>
<li>第二个参数是短的选项定义，单个字符的。如果需要接收参数则后面跟着冒号“:”，比如：&#8217;ab:c:&lsquo;，表示-a不接收参数，-b和-c后面都要跟着参数。</li>
<li>第三个参数提供长选项名字的列表。如果有参数，后面跟着“=”，比如：&#8217;noarg&#8217;, &lsquo;witharg=&rsquo;, &lsquo;witharg2=&rsquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared libraries简介]]></title>
    <link href="http://baren.github.io/blog/2014/12/08/process-ipc/"/>
    <updated>2014-12-08T19:55:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/12/08/process-ipc</id>
    <content type="html"><![CDATA[<p>本篇主要说明进程间通信，也就是IPC（interProcess Communication）。UNIX系统IPC是各种进程通信方式的统称。这里主要讲PIPE和FIFO两种进程间通信的方式。</p>

<h1>PIPE</h1>

<p>PIPE是UNIX一开始就支持的进程间通信的方式，有以下限制：</p>

<ul>
<li>半双工的，通道的一端，要么写，要么读，不能支持读和写两个操作（虽然现代系统有的支持全双工，但是不可移植）</li>
<li>管道是字节流，这意味着没有消息块或者消息边界的概念。可以读或者写任意大小的数据。</li>
<li>使用PIPE进行进程通信的条件是“只能在具有公共祖先的进程之间使用”</li>
<li>PIPE的容量是有限的。PIPE的实现实际上就是内核在内核空间开辟了一块内存，因此是有容量限制的。一旦空间满了，后续写入的就会被阻塞。</li>
</ul>


<h2>创建和使用管道</h2>

<p>使用这个函数创建一个pipe。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数会通过参数filedes返回两个文件描述符。一个filedes[0]用来读，一个filedes[1]用来写。</p>

<p>因为是文件描述符，因此可以使用read()和write()系统调用来完成正常的I/O操作。</p>

<p>为了实现进程间通信，需要在调用pipe函数之前，调用fork来创建子进程，图示：</p>

<p><img src="http://baren.github.io/images/assets/pipe-1.png" title="linux" alt="alt text" /></p>

<p>典型例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">filedes</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;pipe&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
</span><span class='line'>    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fork&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">case</span> <span class="mi">0</span><span class="o">:</span>  <span class="cm">/* Child */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* Child now reads from pipe */</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span> <span class="cm">/* Parent */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* Parent now writes to pipe */</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>管道在不使用的时候需要关掉，这对正确使用管道来说是非常必要的。</p>

<p>当管道的一端关闭后，下列两条规则起作用：</p>

<ul>
<li>当读一个写端已被关闭的管道时，在所有数据被读取后，read返回0，表示到达文件末尾。</li>
<li>如果写一个读端已关闭的管道，则产生信号SIGPIPE，如果忽略或者捕捉改信号并从其处理程序返回，则write返回-1，errno设置为EPIPE。</li>
</ul>


<h2>与shell打交道的popen()函数</h2>

<p>常见的操作是创建一个管道连接到另一个进程，然后读其输出或向其输入端发送数据，为此，标准IO库提供了两个函数popen和pclose</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="n">FIFE</span> <span class="o">*</span><span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdstring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="n">FIFE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>FIFO</h1>

<p>FIFO被称为命名管道，PIPE只能是具有共同祖先的进程之间的通信。通过FIFO，不相关进程也可以通信。</p>

<p>FIFO是一种文件类型，可以通过stat结构成员st_mode来指示是否是FIFO类型，可以用宏S_ISFIFO对此进行测试。</p>

<p>创建一个FIFO：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;sys/stat.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数mode与open函数的mode相同。</p>

<p>一旦创建了FIFO文件，就可以用open打开，一般的文件I/O函数（close、write、read、unlink）都可用。</p>

<p>当打开一个FIFO时，非阻塞标志（O_NONBLOCK）产生下列影响：</p>

<ul>
<li>如果没有指定O_NONBLOCK，只读open要阻塞到某个其它进程为写而打开此FIFO。类似，只写open要阻塞到某个其他进程为读而打开。</li>
<li>如果指定了O_NONBLOCK，则只读open立即返回。但是如果没有进程已经为读而打开一个FIFO，则open将出错并返回-1，error是ENXIO。</li>
</ul>


<p>FIFO有两种用途：</p>

<ul>
<li>FIFO由shell命令使用，以便将数据从一条管道线传送到另一条，为此无需创建中间临时文件</li>
<li>FIFO用于客户进程-服务器进程应用程序中。</li>
</ul>


<p>FIFO可以被用于复制串行管道命令之间的输出流，于是也就不需要写数据到中间磁盘文件。管道只能用于进程间的<em>线性连接</em>。因为FIFO具有名字，因此可以用于非线性连接。</p>

<p>比如：</p>

<pre><code>            |-------------&gt;prog3
            |
</code></pre>

<p>输入文件&mdash;&ndash;> prog1
                |
                |&mdash;&mdash;&mdash;&mdash;->prog2</p>

<p>实现这种过程，而不需要使用临时文件，可以使用FIFO以及tee命令（tee程序将其标准输入同时复制到其标准暑促以及其命令行中包含的文件名中）。</p>

<p>mkfifo  fifo1
prog3 &lt; fifo1 &amp;
prog1 &lt; infile | tee fifo1 | prog2</p>

<h1>XSI IPC</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared libraries简介]]></title>
    <link href="http://baren.github.io/blog/2014/11/19/shared-libraries/"/>
    <updated>2014-11-19T21:09:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/11/19/shared-libraries</id>
    <content type="html"><![CDATA[<p>共享库是把库函数放到一个单元里，在运行时供多个进程共享的一种技术。可以节省磁盘空间和内存。</p>

<p>主要讲静态链接和动态链接。</p>

<!-- more -->


<h1>目标库（Object Libraries）</h1>

<p>平常，编译一个程序，就是用gcc，后面罗列这所有用到的单个文件来生成一个可执行程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -c prog.c mod1.c mod2.c mod3.c
</span><span class='line'>$ cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o</span></code></pre></td></tr></table></div></figure>


<p>缺点：
* 需要在后面指定大量文件，在生产环境不适用</p>

<p>为了避免这个问题，可以把一些共用对象文件归到一个单一单元中，叫做目标库（object library）。</p>

<p>目标库（object library）有两种类型：静态（static）的和共享（shared）的。相对来说，共享的更现代，也更具有优点。</p>

<h1>静态库（static library）</h1>

<p>静态库也叫archive，是unix最开始的库类型。优点：</p>

<ul>
<li>可以把预先编译好的文件放到一个单元中，避免了每次编译</li>
<li>简化了链接命令</li>
</ul>


<h2>创建静态库</h2>

<p>使用ar命令来生成静态库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ar options archive object-file...</span></code></pre></td></tr></table></div></figure>


<h2>使用静态库</h2>

<p>两种使用静态库的方式：</p>

<ol>
<li>直接放到link的命令行里：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -c prog.c
</span><span class='line'>$ cc -g -o prog prog.o libdemo.a
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>静态库放到标准目录（比如/usr/lib）中，在命令行中使用“–l”选项：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -o prog prog.o -ldemo
</span></code></pre></td></tr></table></div></figure>


<p>如果静态库没有在标准目录中，可以指定目录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -o prog prog.o -Lmylibdir -ldemo</span></code></pre></td></tr></table></div></figure>


<h2>缺点</h2>

<ul>
<li>浪费内存，每个进程都会存有一份静态库的副本。</li>
<li>如果静态库中的某个文件变动了，所有依赖这个静态库的程序，都需要重新编译。</li>
</ul>


<h1>共享库（Shared Libraries）</h1>

<p>共享库解决了静态库的缺点，核心是所有依赖这个库的进程都共享同一份程序内存。当第一个依赖这个库程序运行时，会把这个库加载到内存；其它依赖这个库的程序运行时，它就已经加载到内存了。</p>

<p>优点：</p>

<ul>
<li>由于程序小了，因此加载程序时快了</li>
<li>库不是拷贝到每个进程，因此节省了内存</li>
</ul>


<p>不利点：</p>

<ul>
<li>比静态库复杂</li>
<li>共享库必须被编译成位置无关代码（position-independent code）</li>
<li>Symbol relocation必须在运行时定位，因此要稍微慢一点比静态库</li>
</ul>


<h1>创建和使用共享库</h1>

<p>只考虑ELF类型的共享库</p>

<h2>创建共享库</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
</span><span class='line'>$ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o
</span><span class='line'>
</span><span class='line'># 或者一条命令
</span><span class='line'>
</span><span class='line'>$ gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so
</span></code></pre></td></tr></table></div></figure>


<p>–fPIC 知道位置无关代码；</p>

<p>-shared指定创建共享库。</p>

<p>注意：
* 按照惯例，共享库前缀是lib，后缀是.so</p>

<h3>位置无关代码（Position-Independent Code ）</h3>

<p>gcc -fPIC 指示编译器生成位置无关代码（<em>position-independent code</em>）。</p>

<p>这对某些操作来说会改变编译器生成代码的方式。这些操作包括：访问全局、静态或者外部变量；访问字符串常量；获取函数地址等。</p>

<p>这些改变允许可以在运行时在任意虚拟地址定位代码。这对于共享库来说是必要的，因为在链接时刻，是不知道共享库代码在内存的具体地址的。</p>

<h2>使用共享库</h2>

<p>要使用共享库，比起静态库来，额外需要两个步骤：</p>

<ul>
<li>由于最后的可执行文件，没有包含锁依赖的目标文件的拷贝，必须有个机制来在运行时标记它所依赖的共享库。这通过在链接阶段，把共享库的名字嵌入到可执行文件中。这个依赖的共享库列表叫做：dynamic dependency list。</li>
</ul>


<p>嵌入共享库名字到可执行文件，在链接阶段是自动的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -Wall -o prog prog.c libfoo.so</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在运行时，必须有个机制来解决嵌入的共享库名字，也就是根据名字找到共享库的文件，然后加载到内存。</li>
</ul>


<p>根据可执行文件中嵌入的共享库名字，来寻找共享库文件，需要动态链接（dynamic linking）步骤，这是通过动态链接器（dynamic linker）来实现。动态链接器本身就是一个共享库，名字是/lib/ld-linux.so.2，这个链接器也会被嵌入到使用共享库的执行文件中。</p>

<p>动态链接器的任务是：根据一定预先定义的规则在文件系统中寻找共享库文件。这些规则指定了一些存放共享库的标准目录，比如，一般放在/lib和/usr/lib目录下。</p>

<h3>LD_LIBRARY_PATH 环境变量</h3>

<p>除了标准目录，还可以使用环境变量LD_LIBRARY_PATH指定其它目录来通知动态链接器去这些目录寻找共享库文件。如果指定了这个共享库，则动态链接器会先从这几个目录寻找，然后再去标准目录去寻找。</p>

<h2>共享库的Soname</h2>

<p>实际上，一般不会直接让共享库的实际名字嵌入到可执行文件中，而是，在创建一个共享库的时候，会创建一个共享库的soname（在ELF中的DT_SONAME标签）。</p>

<p>一旦一个共享库创建了一个别名soname，那么在链接阶段，共享库的soname会被嵌入到可执行文件中。随后动态链接器会根据这个soname在运行时来寻找共享库的实际文件。</p>

<p>soname的目的是：</p>

<ol>
<li>允许在运行时，可以使用一个与编译时不同的共享库版本</li>
</ol>


<h3>创建一个具有soname的共享库：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
</span><span class='line'>$ gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o
</span><span class='line'>
</span><span class='line'># 共享库的soname是libbar.so</span></code></pre></td></tr></table></div></figure>


<p>一旦共享库有了soname，那么使用共享库时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -Wall -o prog prog.c libfoo.so</span></code></pre></td></tr></table></div></figure>


<p>即使使用的是共享库的真实文件名，链接器也会发现，这个共享库实际上有soname，因此，会使用soname来替代。</p>

<p>一旦创建了一个soname的共享库，还有一个重要步骤是创建一个soname到实际共享库的软链：</p>

<blockquote><p>注意：
这个软链必须创建在动态链接器的查找目录中</p></blockquote>

<p>编译步骤图示：
<img src="http://baren.github.io/images/assets/gcc-dl.png" title="linux" alt="alt text" /></p>

<p>使用步骤图示：
<img src="http://baren.github.io/images/assets/gcc-dl-u.png" title="linux" alt="alt text" /></p>

<h1>共享库相关的工具</h1>

<h2>ldd</h2>

<p>ldd命令展示一个程序需要依赖的共享库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ldd prog
</span><span class='line'>libdemo.so.1 =&gt; /usr/lib/libdemo.so.1 (0x40019000) libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4017b000) /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span></code></pre></td></tr></table></div></figure>


<h1>共享库版本和命名规范</h1>

<ul>
<li><p>minor versions：一般来说，如果如果随后的共享库的版本与上一个共享库的版本是兼容的，比如函数签名没有变，这种版本不一样但是兼容的情况，叫做共享库的 * minor versions *。</p></li>
<li><p>如果共享库的两个版本是不兼容的，则是 * major version*。</p></li>
</ul>


<p>为了处理这两种差异，为共享库命名定义了一些规范。</p>

<ul>
<li>共享库的每一个不兼容版本，用唯一的major version 标识符标记，这是共享库实际名字的一部分。按照约定，使用数字累加来当做major version。</li>
<li>共享库的兼容版本，使用minor version标识符来标记，minor version可以是任意字符串，但是，约定也是数字，也可以是两个数字，用句点隔开的。</li>
</ul>


<p>根据上面约定，一个共享库的名字组成是：</p>

<p>libname.so.major-id.minor-id.</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libdemo.so.1.0.1
</span><span class='line'>libdemo.so.1.0.2  # Minor version, compatible with version 1.0.1 
</span><span class='line'>libdemo.so.2.0.0  # New major version, incompatible with version 1.* libreadline.so.5.0</span></code></pre></td></tr></table></div></figure>


<h2>soname命名规范</h2>

<p>共享库的soname的命名规范，包括它对应的共享库实际文件的major version标识符，而不包括minor version标识符，因此soname的名字组成是：</p>

<p>libname.so.major-id</p>

<p>soname在共享库实际文件同一个目录下创建一个软链。</p>

<p>一般情况下，因为共享库的minor version标记这是兼容版本，因此soname一般指向最新的最小版本文件。假如libdemo.so.1这个版本下的小版本最新的是0.2，那么：</p>

<p>libdemo.so.1  -> libdemo.so.1.0.2</p>

<h2>linker name</h2>

<p>除了这两个外，还有个linker name，这个名字只包括主要名字，不包括版本，比如：</p>

<p>libdemo.so -> libdemo.so.2</p>

<p>libreadline.so -> libreadline.so.5</p>

<p>linker name 既可以指向一个实际的共享库，也可以指向soname的软链。一般是指向soname</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[daemon简介]]></title>
    <link href="http://baren.github.io/blog/2014/10/20/daemon/"/>
    <updated>2014-10-20T21:09:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/10/20/daemon</id>
    <content type="html"><![CDATA[<p>要理解daemon，需要了解</p>

<ul>
<li>进程组</li>
<li>会话</li>
<li>控制终端</li>
<li>SIGHUP信号（kill -HUP）</li>
<li>fg和bg命令</li>
<li>使用nohup使进程变为后台进程</li>
<li>一个命令后采用“&amp;”使之在后台执行</li>
</ul>


<p>等这些相关知识。</p>

<!-- more -->


<h1>外围知识</h1>

<h2>进程组</h2>

<p>进程组是一个或多个具有共同进程组ID的进程集。
进程组的特点是：</p>

<ul>
<li>进程组的首进程是创建了进程组的进程，并且进程组的进程ID与进程组ID相等</li>
<li>子进程会继承父进程的进程组ID</li>
<li>进程组有生命周期，从进程创建进程组开始，到最后一个进程离开进程组结束</li>
</ul>


<h2>会话</h2>

<p>一个会话是进程组的集合。</p>

<p>一个进程是否属于一个会话是靠进程的进程会话ID，</p>

<ul>
<li>一个会话头进程是创建会话的进程，会话ID与进程的进程ID一样</li>
<li>子进程继承父进程的会话ID</li>
</ul>


<h2>进程组、会话与控制终端</h2>

<ul>
<li>所有的会话中的进程共享一个控制终端。</li>
<li>控制终端的建立是当会话的首进程第一次打开控制终端时。</li>
<li>如果一个会话有控制终端，那么在一个时刻，一个会话中，只有一个进程组是前台进程。其它进程组都是后台进程组</li>
<li>只有前台进程组中的进程可以从控制终端中读取输入。</li>
<li>当在控制终端输入终端字符（Control-C）生成SIGINT信号，并发送给前台进程组中的所有进程</li>
<li>会话首进程对于控制终端来说是控制进程，如果与控制终端断开，内核会给控制进程发送SIGHUP信号。</li>
</ul>


<p>会话进程组控制终端之间关系的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $$
</span><span class='line'>400
</span><span class='line'>$ find / 2&gt; /dev/null | wc -l & 
</span><span class='line'>[1] 659
</span><span class='line'>$ sort &lt; longlist | uniq -c</span></code></pre></td></tr></table></div></figure>


<p>图示：
<img src="http://baren.github.io/images/assets/session_crt.png" title="linux" alt="alt text" /></p>

<h2>SIGHUP信号</h2>

<p>当控制进程与控制终端连接断开时，内核会发送SIGHUP信号给控制进程。SIGHUP的默认动作是终止进程。</p>

<p>会发生以下事情：</p>

<ul>
<li>如果控制进程是shell，他会建立处理SIGHUP信号的函数，在终止之前，会发送SIGHUP信号给它自己创建的每一个作业。</li>
<li>控制终端的控制进程停止时，内核断开会话内的所有进程与控制终端的连接。</li>
</ul>


<h1>daemon进程</h1>

<p>一个daemon是一个进程，具有以下特征：</p>

<ul>
<li>长时间运行的</li>
<li>在后台运行，并没有控制终端。没有控制终端，保证了内核不会为daemon进程生成任何作业控制或者终端相关信号（SIGINT, SIGTSTP, 和 SIGHUP）</li>
</ul>


<p>系统的一些daemon进程：</p>

<ul>
<li>cron：在指定时间执行任务的后台进程</li>
<li>sshd: secure shell进程</li>
<li>inetd：后台进程，监听在特定TCP/IP端口进来的网络连接，并启动相应的程序处理连接</li>
</ul>


<h2>创建一个daemon</h2>

<p>创建一个daemon有一些固定的步骤和流程。</p>

<ol>
<li>fork，然后父进程退出。

<blockquote><p>这样的好处是：</p></blockquote></li>
</ol>


<blockquote><p>1 fork后的子进程的父进程的父进程就成了init。</p>

<p>2 如果该守护进程是从shell启动，父进程退出，会让shell认为这条命令执行完成</p>

<p>3 保证子进程不是组长进程</p></blockquote>

<ol>
<li>进程独立，调用setsid函数</li>
</ol>


<blockquote><p>因为所有会话中的进程会共享同一个控制终端，（控制进程的子进程，都会继承这个控制终端），具有控制终端的进程都会收到控制终端发出的信号，因此，必须让daemon与控制终端分离。</p>

<p>调用setsid()函数使daemon独立，这会让进程处在一个新的会话和进程组中，并与控制终端分离</p></blockquote>

<ol>
<li>关闭不需要的文件描述符。

<blockquote><p>根据函数确认进程可拥有的最大进程描述符的值，一个个关闭，比如：</p></blockquote></li>
</ol>


<blockquote><p>for (i=getdtablesize();i>=0;&ndash;i) close(i); /<em> close all descriptors </em>/</p>

<p>有些标准库程序会读或者写入标准IO，可能会发生在终端或者文件中，因此最好也重定向标准IO无害设备上，比如/dev/null。</p>

<p>i=open(&ldquo;/dev/null&rdquo;,O_RDWR); /<em> open stdin </em>/</p>

<p>dup(i); /<em> stdout </em>/</p>

<p>dup(i); /<em> stderr </em>/</p></blockquote>

<ol>
<li>修改创建文件屏蔽字</li>
</ol>


<blockquote><p>有时候daemon会保护他创建的文件，因此会回收组写和其它写功能，</p>

<p>umask(027)</p></blockquote>

<ol>
<li>将当前工作目录改成根目录</li>
</ol>


<blockquote><p>好处方便查到程序的一些配置文件等</p>

<p>如果进程的工作目录是“/”，那么将不能使用unmount来卸载文件系统，因为unmount两种条件下出错：有打开的文件和在有执行的后台进程，其工作目录处于文件系统中</p>

<p>比如：chdir(&ldquo;/servers/&rdquo;);</p></blockquote>

<ol>
<li>设置排他性，只有一个进程运行</li>
</ol>


<blockquote><p>比如cron进程，肯定只需要一个就够了。</p>

<p>文件锁方法对于排他性执行是个好方法。</p></blockquote>

<ol>
<li>捕获信号</li>
</ol>


<blockquote><p>进程可以从用户和进程收到信号，最好是捕获信号并做处理。</p>

<p>子进程终止时，会给父进程发送SIGCHLD信号，daemon要么忽略要么处理这个信号</p>

<p>许多服务进程使用hang-up信号来重启服务。用这个信号来重启是哥不错的主意。</p></blockquote>

<ol>
<li>记录日志

<blockquote><p>可以指定一个日志文件</p></blockquote></li>
</ol>


<blockquote><p>使用log服务（syslogd守护进程提供）</p></blockquote>

<p>参考：<a href="http://www.enderunix.org/docs/eng/daemon.php">http://www.enderunix.org/docs/eng/daemon.php</a></p>

<h2>使用SIGHUP重新初始化daemon进程</h2>

<p>大部分daemon都是一直执行直到系统关闭。
但是，如果想重新初始化进程而又不想停止进程再重启（重新读取配置文件）。可以使用SIGHUP信号来实现。通过捕获这个信号来完成相应初始化逻辑。</p>

<p>SIGHUP信号是当控制进程与控制终端断开时，发送给控制进程的。由于daemon没有控制终端，因此内核不会给daemon进程发送SIGHUP信号。因此daemon可以使用这个信号来完成这个处理功能。</p>

<h2>daemon的日志</h2>

<p>只需要记住这个图就可以。</p>

<p><img src="http://baren.github.io/images/assets/daemon-log.png" title="linux" alt="alt text" /></p>

<p>/etc/syslog.conf文件控制的syslogd的日志控制。格式是：</p>

<hr />

<p>facility.level  action</p>

<hr />

<p>其中facility和level是选择器，action决定的消息被发送到的地方。</p>

<p>facility可以是：</p>

<table>
<thead>
<tr>
<th> facility        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_AUTH     </td>
</tr>
<tr>
<td> LOG_AUTHPRIV     </td>
</tr>
<tr>
<td> LOG_CRON     </td>
</tr>
<tr>
<td> LOG_DAEMON     </td>
</tr>
<tr>
<td> LOG_FTP     </td>
</tr>
<tr>
<td> LOG_MAIL     </td>
</tr>
<tr>
<td> LOG_NEWS     </td>
</tr>
<tr>
<td> LOG_SYSLOG     </td>
</tr>
<tr>
<td> LOG_USER     </td>
</tr>
<tr>
<td> LOG_KERN     </td>
</tr>
<tr>
<td> 等     </td>
</tr>
</tbody>
</table>


<p>level可以是：</p>

<table>
<thead>
<tr>
<th> level        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_EMERG     </td>
</tr>
<tr>
<td> LOG_ALERT     </td>
</tr>
<tr>
<td> LOG_CRIT     </td>
</tr>
<tr>
<td> LOG_ERR     </td>
</tr>
<tr>
<td> LOG_WARNING     </td>
</tr>
<tr>
<td> LOG_NOTICE     </td>
</tr>
<tr>
<td> LOG_INFO     </td>
</tr>
<tr>
<td> LOG_DEBUG     </td>
</tr>
</tbody>
</table>


<p>比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*.LOG_ERR                        /dev/tty10 所有的错误发到控制终端
</span><span class='line'>auth.notice                   root # 发送到root登陆的控制台或终端
</span><span class='line'>*.debug;mail.none;news.none   -/var/log/messages</span></code></pre></td></tr></table></div></figure>


<p>一行可以包含多个选择器，用分号分割。*.debug;mail.none;news.</p>

<p>none表示所有的debug信息，但是拍出mail和news的信息。-/var/log/messages前面有个“-”表示不需要每次写入都同步到磁盘，这使的写入速度快。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread 进一步细节]]></title>
    <link href="http://baren.github.io/blog/2014/09/28/pthread-further-details/"/>
    <updated>2014-09-28T20:43:21+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/28/pthread-further-details</id>
    <content type="html"><![CDATA[<h1>线程和信号</h1>

<p>信号的设计实现早于线程，导致线程与信号之间有许多冲突。冲突的地方主要在于：</p>

<ul>
<li>既要维护传统的在单线程进程环境下的信号语义</li>
<li>同时又要开发符合多线程进程环境下的信号程序</li>
</ul>


<!-- more -->


<h2>信号模式怎样映射到线程</h2>

<p>需要弄清楚信号的哪些方面是进程级别的，哪些方面是针对特定线程的。说明：</p>

<ul>
<li>信号动作是<em>进程</em>级别的。这意味着一个默认动作是终止进程的信号被内核递送到进程的任意线程，所有的进程内的线程都会终止。</li>
<li>信号处理是<em>进程</em>级别的。进程内的所有线程都共享同一个信号处理器。如果一个线程使用sigaction()建立的信号处理器，进程内的任意线程如果收到这个信号，都会调用这个处理器；如果一个线程设置了忽略某个信号，其它线程也自动忽略</li>
<li>如果信号递送给一个多线程的进程时，内核会随机选取一个线程，用来递送信号和执行信号处理程序。</li>
<li>屏蔽信号是基于线程的。线程可以使用pthread_sigmask()来屏蔽某些信号。</li>
<li>内核维护了针对进程的一个全局的阻塞（pending）的信号集；也维护了针对每个线程的阻塞的信号集。sigpending()函数会返回进程的全局阻塞的信号集和调用这个函数的线程的阻塞信号集的并集。一个新创建的线程，阻塞的信号集是空。如果一个线程阻塞了一个信号，这个信号一直被阻塞，直到线程取消阻塞或者线程停止。</li>
<li>如果一个信号处理中断了pthread_mutex_lock()调用，这个调用总是会自动启动。如果中断了pthread_cond_wait()，也会自动重启。</li>
</ul>


<p>以下几种情况，信号会递送给特定线程：</p>

<ul>
<li>在某个线程上下文中，执行了一个特定的硬件指令的直接结果，生成信号</li>
<li>线程试图写入到一个终端的pipe文件时，生成一个SIGPIPE</li>
<li>使用pthread_kill() 或 pthread_sigqueue()可以允许同一进程的线程给另一个线程发信号</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;signal.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_kill</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_sigmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">oldset</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>线程和进程控制</h1>

<p>就像信号一样exec(), fork(), and exit()也是早于线程。</p>

<h5>线程和exec()</h5>

<p>当任意线程调用exec()函数时，调用的程序会被完全取代。所有的线程，除了调用线程外，都会被终止。不会去执行线程的终止处理函数，属于进程的锁和条件变量都会消失。</p>

<h5>线程和fork()</h5>

<p>多线程环境的进程调用fork()函数，只有调用进程在子进程中复制。其它线程在子进程中会消失，线程特定的析构或者清理函数都不会执行。这会导致严重问题：</p>

<ul>
<li><p>虽然只有调用线程被复制了，但是进程全局状态，还有pthread对象（比如锁和条件变量）等全局对象，都会被复制到子进程。这会导致，如果在fork的同时，有个线程锁住了mutex，并且部分更新了全局数据结构，这种情况下，子进程中的线程将不能够解锁这个mutex。更进一步，子进程中的全局状态可能处于不一致状态。</p></li>
<li><p>由于线程的析构或者清理函数没有被调用，有可能导致子进程的内存泄露。</p></li>
</ul>


<p>由于在多线程环境下调用fork有这么多严重问题，通常的建议是：</p>

<ul>
<li>只有在后续立即调用exec函数的情况下，才会调用fork函数。否则不要调用。</li>
</ul>


<p>如果必须调用fork函数，但是后面不跟着调用exec函数，linux提供了一个这种情况下的解决办法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_atfork</span><span class="p">(</span><span class="n">prepare_func</span><span class="p">,</span> <span class="n">parent_func</span><span class="p">,</span> <span class="n">child_func</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>线程实现模式</h1>

<p>有许多线程实现方式，主要的区别是线程和内核的调度实体（kernel scheduling entities）之间映射的不同。</p>

<p>内核调度实体（kernel scheduling entities）是内核分配CPU和其他资源的单元。在传统的UNIX系统下，内核调用实体与进程是同义的。</p>

<h2>Many-to-one (M:1) 实现，用户级别线程</h2>

<p>在M:1线程实现模式下，所有的线程创建、调度和同步细节都在用户空间下的线程lib包实现。内核不知道关于线程的任何细节。</p>

<p>这种实现有以下几种好处：</p>

<ul>
<li>最大的好处是线程操作非常快速，因为这些全部在用户空间实现，不用切换到内核空间。</li>
<li>移植性好，由于是在用户空间实现的，可以很容易从一个系统移植到另一个系统</li>
</ul>


<p>不好处是：</p>

<ul>
<li>当一个线程调用了一个系统调用（比如read()），控制从用户空间的线程包转到内核，这意味着read()被阻塞了，那么其它线程就全部被阻塞了。</li>
<li>内核不能够调度线程。由于内核不知道线程的存在，因此内核不能调度线程到其它cpu上。</li>
</ul>


<h2>One-to-one (1:1)实现方式</h2>

<p>在1:1实现方式下，一个线程对应一个内核的调度实体。内核单独的处理每个线程的调度。这样，就解决了M:1的重大调度问题。</p>

<p>但是这种实现方式下，也有其它问题：</p>

<ul>
<li>线程的创建同步等操作就比较慢，因为需要切换到内核空间下。</li>
<li>一对一的关系，内核需要为每一个线程维护一个内核调度实体，如果有大量的线程，会降低整体性能。</li>
</ul>


<p>尽管如此，1:1的方式是大多数pthread线程实现的方式。两个linux的pthread实现都是采用1:1的方式</p>

<h2>linux的pthread实现方式</h2>

<p>linux有两种pthread的实现：</p>

<ul>
<li>LinuxThreads: 这是linux的最初实现。Xavier Leroy开发</li>
<li>NPTL (Native POSIX Threads Library): 新的linux下的pthread实现。Ulrich Dreppe（gun c也叫libc的管理者） 和 Ingo Molnar实现。性能比LinuxThreads好，也更符合pthread的规范。</li>
</ul>


<p>在glibc 2.4及其后续版本，不再支持LinuxThreads了。</p>

<h3>LinuxThreads实现细节</h3>

<ul>
<li>使用clone() 系统调用创建一个线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>

<p>这意味着LinuxThreads线程共享虚拟内存、文件描述符、文件相关信息（umask, root directory, and current working directory）和信号处理。</p>

<ul>
<li><p>除了由应用创建的线程，LinuxThreads还创建了额外的管理线程，来处理线程的创建的销毁。</p></li>
<li><p>实现采用了信号来进行内部的操作。</p></li>
</ul>


<p>当内核支持实时信号（Linux 2.2及其以后），前三个实时信号被使用；如果是老的内核，使用 SIGUSR1 and SIGUSR2，这样，应用不能够使用这几个信号。</p>

<p>关于实时信号，参考：
<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7">http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7</a></p>

<h3>NPTL</h3>

<ul>
<li>使用clone() 创建线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>

<ul>
<li><p>使用了前两个实时信号</p></li>
<li><p>不像LinuxThreads，NPTL没有实现管理线程</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[取消线程]]></title>
    <link href="http://baren.github.io/blog/2014/09/25/pthread-cancel/"/>
    <updated>2014-09-25T20:56:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/25/pthread-cancel</id>
    <content type="html"><![CDATA[<p>主要描述POSIX线程的取消机制和更进一步的线程细节，包括线程和信号，线程栈等。</p>

<!-- more -->


<h1>取消一个线程</h1>

<p>使用pthread_cancel函数取消特定的线程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 返回0表示成功</span>
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cancel只是发送取消请求，然后立即返回。这意味着调用线程不用等待线程停止。目标线程什么时候停止，取决于目标线程的状态和类型。</p>

<h1>取消状态和类型</h1>

<p>使用pthread_setcancelstate()设置线程的取消状态；使用pthread_setcanceltype()设置线程的取消类型。这两个状态设置线程如何响应取消操作的。</p>

<p>pthread_setcancelstate()函数可设置的状态是：</p>

<ul>
<li>PTHREAD_CANCEL_DISABLE。 线程是不可取消的。这种线程如果接收到一个取消请求，会保持未决（pending）状态直到成为可取消状态</li>
<li>PTHREAD_CANCEL_ENABLE。线程是可取消的，这个状态也是默认的状态。</li>
</ul>


<p>线程在执行一段必须执行完的代码时，设置为不可取消状态，是非常有用的。</p>

<p>pthread_setcanceltype()函数可以设置两种类型：</p>

<ul>
<li>PTHREAD_CANCEL_DEFERRED。线程一直执行直到遇到取消点（特殊函数）。默认类型。</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS。线程可以在任意时间点取消，一般不大永。</li>
</ul>


<h1>取消点</h1>

<p>当一个线程是可取消的并且是延迟的（PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DEFERRED）。取消操作会在线程执行到下一个取消点时起作用。</p>

<p>SUSv3 定义了一组必须是取消点的函数，还定义了一组是可选取消点的函数。</p>

<p>可取消函数列表（略）</p>

<p>对于一个不是分离的线程，必须由其它函数调用pthread_join函数等待这个线程结束。如果这个线程接收了取消请求，并到达了一个取消点，则pthread_join返回的值是PTHREAD_CANCELED.</p>

<p>取消线程的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="nf">threadFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New thread started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Loop %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* NOTREACHED */</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">thr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_create&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>      <span class="cm">/* Allow new thread to run a while */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cancel&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_join&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">PTHREAD_CANCELED</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread was canceled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread was not canceled (should not happen!)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>测试取消点</h1>

<p>如果线程没有调用这些取消点函数（纯计算线程），为了也能够响应取消请求，可以使用pthread_testcancel()来当取消点。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_testcancel</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>清理处理器</h1>

<p>如果一个线程接收到取消请求，执行到一个取消点，则会停止。有可能会导致共享的变量和pthread对象（比如锁）处在不一致状态，可能会导致剩下的线程死锁等异常状态。</p>

<p>为了避免这个问题，需要定义线程结束的清理函数。</p>

<p>每一个线程都有一个线程处理函数栈。当线程被取消时，从上到下依次开始执行清理处理程序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_cleanup_push</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">routine</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_cleanup_pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">execute</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
当线程正常执行完成，不会触发清理处理函数。</p></blockquote>

<p>一般来说，一个清理操作只有在执行一段特殊的代码时被取消时，才会用到。</p>

<p>下面例子在主main函数中创建了一个线程，他分配了一块内存，并锁住了一个互斥锁mtx。因为线程有可能被取消，因此使用pthread_cleanup_push()来安装清理处理函数，这个清理函数主要作用是释放分配的内存，并对互斥锁解锁。</p>

<p>安装完清理处理器后，线程进入所谓的特殊代码段（如果取消，需要走清理处理函数的）。</p>

<p>如果特殊代码段正常执行完成，则调用pthread_cleanup_pop()去掉处理函数。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="n">mtx</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">glob</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Predicate variable */</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>        <span class="cm">/* Free memory pointed to by &#39;arg&#39; and unlock mutex */</span> <span class="n">cleanupHandler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cleanup: freeing block at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cleanup: unlocking mutex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="n">threadFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Buffer allocated by thread */</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread: allocated memory at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>  <span class="cm">/* Not a cancellation point */</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanupHandler</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">glob</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>   <span class="cm">/* A cancellation point */</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>      
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cond_wait&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread: condition wait loop completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">thr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_create&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>      <span class="cm">/* Give thread a chance to get started */</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>      <span class="cm">/* Cancel thread */</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: about to cancel thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cancel&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>       <span class="cm">/* Signal condition variable */</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: about to signal condition variable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">glob</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cond_signal&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span><span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_join&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">PTHREAD_CANCELED</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: thread was canceled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="nf">printf</span><span class="p">(</span><span class="s">&quot;main: thread terminated normally</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>  
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
注意上面例子对pthread_cleanup_push()函数的的典型使用</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread control]]></title>
    <link href="http://baren.github.io/blog/2014/09/17/pthread-control/"/>
    <updated>2014-09-17T21:19:03+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/17/pthread-control</id>
    <content type="html"><![CDATA[<h1>线程属性</h1>

<p>在使用pthread_create函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建线程时，第三个参数attr是线程属性。可以使用pthread_attr_t结构来修改线程默认属性。</p>

<p>pthread_attr_t变量需要初始化，需要使用pthread_attr_init函数进行初始化。调用初始化函数后，pthread_attr_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p>

<!-- more -->


<p>pthread_attr_t属性的初始化和销毁接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_init</span><span class="p">(</span><span class="kt">ptread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_destory</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>POSIX.1支持的线程属性包括：</p>

<ul>
<li>线程的分离状态属性</li>
<li>线程栈末尾的警戒缓冲区大小</li>
<li>线程栈的最低地址</li>
<li>线程栈的大小</li>
</ul>


<p>如果创建的线程不需要知道线程的终止状态，可以在创建的时候，以分离状态启动。通过设置pthread_attr_t的值为分离状态。设置pthread_attr_t的函数是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_getdetachstate</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">detachstate</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_setdetachstate</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">detachstate</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>设置分离状态的属性值是：PTHREAD_CREATE_DETACHED</p>

<h1>同步属性</h1>

<p>互斥量、读写锁和条件变量的属性</p>

<h2>互斥量属性</h2>

<p>主要讲互斥量属性的类型属性。类型属性有以下几种：</p>

<ul>
<li>PTHREAD_MUTEX_NORMAL——不检查死锁错误，如果一个线程试图去lock一个他已经锁住的互斥量，则发生死锁。</li>
<li>PTHREAD_MUTEX_ERRORCHECK——提供错误检查</li>
<li>PTHREAD_MUTEX_RECURSIVE——允许同一个线程多同一个互斥量多次加锁。会维持一个加锁计数量。</li>
</ul>


<p>对互斥量，属性初始化和销毁函数是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以通过下面函数设置互斥量属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutexattr_gettype</span><span class="p">(</span><span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutexattr_settype</span><span class="p">(</span><span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>读写锁属性</h2>

<p>支持进程共享属性</p>

<h2>条件变量属性</h2>

<p>支持进程共享属性</p>

<h1>重入</h1>

<p>在信号处理时，可重入的函数是指函数没有访问静态数据结构，或者没有调用malloc和free等。在线程处理时，函数同样也有重用的概念。</p>

<p>在多线程环境下，一个函数是可重入的，意思是：一个函数在同一时刻可以被多个线程安全调用。</p>

<p>注意与信号的区别
* 一个函数对多线程来说是可重入的，意思是这个函数是线程安全的。
* 但并不意味着对信号处理程序来说该函数是可重入的（比如标准io函数，是线程安全的，会对流加锁保证，但是对信号处理是不可重入的，因为会修改全局数据结构）。</p>

<p>有一个列表，列出了posix.1中不能保证线程安全的函数：</p>

<p><img src="http://baren.github.io/images/assets/pthread-1.png" title="linux" alt="alt text" /></p>

<p>如果操作系统实现线程安全这一特性时，会同时提供一个对应的线程安全版本。</p>

<p>比如asctime，对应的就是asctime_r，后缀是_r表示可重入。</p>

<p>posix.1还提供了以线程按方式管理FILE对象的方法。</p>

<p>标准IO流的实现，会对流加锁解锁操作，如果频繁调用getc函数，会有性能下降，因为会有频繁的加锁解锁。</p>

<p>为了解决这个问题，posix1.c引入非可重入版本的流函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">getchar_unlocked</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">getc_unlocked</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">putchar_unlocked</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">putc_unlocked</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时提供了线程安全的方式管理FILE对象的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">ftrylockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">flockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">funlockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用非线程安全的流函数版本时，需要用flockfile和funlockfile包围，否则会出现不可预测的问题（因为是非线程安全的）。</p>

<p>好处：</p>

<ul>
<li>一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次数据读写上分摊总的加解锁开销。</li>
</ul>


<h1>线程私有数据</h1>

<p>让一个函数是线程安全的最有效的方式就是让函数是可重入的。新的函数最好这么实现。尽管如此，
一些老的函数，不是线程安全的，如果要将其改造成线程安全函数，需要满足：</p>

<ul>
<li>实现线程安全的</li>
<li>不能改变函数的签名，也就是不需要调用这个函数的程序去修改</li>
</ul>


<p>使用线程私有（thread-specific）数据可以实现。</p>

<blockquote><p>注意：
要理解线程私有数据，以函数的角度考虑问题。</p></blockquote>

<p>线程私有数据允许函数为每一个线程维持一个单独的数据拷贝。如图所示：</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd.png" title="linux" alt="alt text" /></p>

<p>线程A调用函数myfunc时，myfunc函数为线程A维持一个单独数据，线程B调用myfunc函数时，myfunc为线程B维持一个线程B单独的数据。</p>

<p>线程私有数据有个特点：</p>

<ul>
<li>存储的数据是持久化的，每一份数据会一直存在，这允许函数间共享数据（虽然不推荐）。</li>
</ul>


<h2>从函数角度考虑线程私有数据</h2>

<p>为了更好的理解线程私有数据，需要从函数角度（实现角度）考虑如何使用线程私有数据</p>

<ul>
<li>在线程第一次调用函数时，函数为线程分配独立的存储块。存储块只分配一次，就是在线程第一次调用此函数时。</li>
<li>同一个线程对这个函数的随后的调用，函数能够获取这个第一次调用而分配存储块。因此不能用局部变量存储指向存储块的key；也不能用static变量存储，因为在进程内，只有一个static的实例。</li>
<li>不同的函数可能都需要线程私有数据，因此每个函数都得需要自己的线程私有数据key</li>
<li>当线程停止时，函数不需要控制私有数据，因为停止时，代码有可能已经执行到函数外了。因此需要有个地方来执行清理操作。</li>
</ul>


<h2>线程私有数据 API</h2>

<h3>创建私有数据key</h3>

<p>创建一个key，两个用处：</p>

<ul>
<li>用来获取函数分配的存储块</li>
<li>用来区分其它函数的线程私有数据对应的key</li>
</ul>


<p>使用pthread_key_create函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_key_create</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>destructor指向一个清理函数，用来释放函数内分配的存储块。</p>

<p>其签名是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">dest</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="cm">/* Release storage pointed to by &#39;value&#39; */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>线程停止时，并且这个key关联的数据不是NULL时，就会自动调用这个函数来清理。</p>

<p>一般，线程私有数据的实现，使用一个全局数组来存储这个key，这个key有两个状态：</p>

<ul>
<li>是否使用的标记</li>
<li>清理函数指针</li>
</ul>


<p>如图：</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd-key.png" title="linux" alt="alt text" /></p>

<p>根据图，pthread_key_create()返回的一般是全局数组的索引，数组元素包含两个字段，是否使用字段和清理函数地址字段。</p>

<h3>关联函数分配内存与key</h3>

<p>使用函数pthread_setspecific函数来关联函数分配的存储和pthread_key_create创建的key。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_setspecific</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="c1">// value参数是一个分配的内存的指针</span>
</span><span class='line'><span class="c1">// 当线程停止时，这个值会传给create函数指定的清理函数。</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">pthread_getspecific</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="n">key</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了维护线程私有数据，Pthreads API 为每一个线程维护了一个指针数组，数据元素是函数分配的存储的指针。</p>

<p>如下图，假设pthread_keys[1]是函数myfunc分配的key，对于每一个线程，pthread api维护了一个指针数组，
数组元素指向函数内分配的内存，</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd-key-2.png" title="linux" alt="alt text" /></p>

<h2>例子</h2>

<h3>非线程安全的</h3>

<p>下面是一个非线程安全的strerror()的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define _GNU_SOURCE  </span><span class="cm">/* Get &#39;_sys_nerr&#39; and &#39;_sys_errlist&#39; declarations from &lt;stdio.h&gt; */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;   </span><span class="cm">/* Get declaration of strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#define MAX_ERROR_LEN 256  </span><span class="cm">/* Maximum length of string returned by strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span><span class="p">];</span>  <span class="cm">/* Statically allocated return buffer */</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="nf">strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="n">_sys_nerr</span> <span class="o">||</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAX_ERROR_LEN</span><span class="p">,</span> <span class="s">&quot;Unknown error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">],</span> <span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* Ensure null termination */</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>线程安全例子</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define _GNU_SOURCE        </span><span class="cm">/* Get &#39;_sys_nerr&#39; and &#39;_sys_errlist&#39; declarations from &lt;stdio.h&gt; */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;        </span><span class="cm">/* Get declaration of strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_once_t</span> <span class="n">once</span> <span class="o">=</span> <span class="n">PTHREAD_ONCE_INIT</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_key_t</span> <span class="n">strerrorKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#define MAX_ERROR_LEN 256        </span><span class="cm">/* Maximum length of string in per-thread buffer returned by strerror() */</span><span class="cp"></span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">destructor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>     <span class="cm">/* Free thread-specific data buffer */</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">createKey</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="cm">/* One-time key creation function */</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* Allocate a unique thread-specific data key and save the address of the destructor for thread-specific data buffers */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strerrorKey</span><span class="p">,</span> <span class="n">destructor</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_key_create&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="nf">strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Make first caller allocate key for thread-specific data */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once</span><span class="p">,</span> <span class="n">createKey</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_once&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">buf</span> <span class="o">=</span> <span class="n">pthread_getspecific</span><span class="p">(</span><span class="n">strerrorKey</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* If first call from this thread, allocate buffer for thread, and save its location */</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MAX_ERROR_LEN</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>            <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;malloc&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">strerrorKey</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_setspecific&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="n">_sys_nerr</span> <span class="o">||</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAX_ERROR_LEN</span><span class="p">,</span> <span class="s">&quot;Unknown error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">],</span> <span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* Ensure null termination */</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python decorator 深入理解]]></title>
    <link href="http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator/"/>
    <updated>2014-09-14T11:38:09+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator</id>
    <content type="html"><![CDATA[<h1>装饰器介绍</h1>

<p>装饰器是一个函数，其主要目的是包装另一个函数或类，来透明的修改或者增强被包装对象的功能。语法上，装饰器用<em>@</em>表示，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nd">@trace</span>
</span><span class='line'><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面装饰器，类似于这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class='line'>
</span><span class='line'><span class="n">square</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<h1>不带参数的装饰器</h1>

<p>装饰器不带参数，被装饰的函数可以带参数，也可以不带，</p>

<h2>被装饰函数不带参数</h2>

<p>不带参数的装饰器，比较简单，只需要接收一个函数作为参数即可。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">timing_function</span><span class="p">(</span><span class="n">some_function</span><span class="p">):</span>  <span class="c"># 装饰器，接收一个函数作为参数</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    Outputs the time a function takes</span>
</span><span class='line'><span class="sd">    to execute.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class='line'>        <span class="n">some_function</span><span class="p">()</span>
</span><span class='line'>        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;Time it took to run the function: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@timing_function</span>
</span><span class='line'><span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
</span><span class='line'>    <span class="n">num_list</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">num_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Sum of all the numbers: &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">num_list</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">my_function</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>被装饰函数带参数</h2>

<p>如果被装饰的函数带参数，让包装函数带着参数就可以。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># It’s not black magic, you just have to let the wrapper </span>
</span><span class='line'><span class="c"># pass the argument:</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">a_decorator_passing_arguments</span><span class="p">(</span><span class="n">function_to_decorate</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">a_wrapper_accepting_arguments</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;I got args! Look:&quot;</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span>
</span><span class='line'>        <span class="n">function_to_decorate</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a_wrapper_accepting_arguments</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Since when you are calling the function returned by the decorator, you are</span>
</span><span class='line'><span class="c"># calling the wrapper, passing arguments to the wrapper will let it pass them to </span>
</span><span class='line'><span class="c"># the decorated function</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@a_decorator_passing_arguments</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_full_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;My name is&quot;</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span>
</span><span class='line'>
</span><span class='line'><span class="n">print_full_name</span><span class="p">(</span><span class="s">&quot;Peter&quot;</span><span class="p">,</span> <span class="s">&quot;Venkman&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c"># outputs:</span>
</span><span class='line'><span class="c">#I got args! Look: Peter Venkman</span>
</span><span class='line'><span class="c">#My name is Peter Venkman</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了函数通用，可以让包装器接收参数设置为(*args, **kwargs)的形式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">common_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    Limits how fast the function is</span>
</span><span class='line'><span class="sd">    called.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># 处理代码</span>
</span><span class='line'>        <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 处理代码</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@common_decorator</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_number</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">num</span>
</span></code></pre></td></tr></table></div></figure>


<h1>装饰器需要参数</h1>

<p>有时候为了装饰器的功能性，需要装饰器本身也需要接收参数，但是装饰器应该接收一个函数作为参数，为了达到让装饰器也能接收参数，需要：</p>

<ul>
<li>多套一层函数，最外层函数接收装饰器用到的参数</li>
<li>在打装饰器时，把参数传给装饰器，也就是在<em>@</em>后面是一个函数调用，而不是仅仅是装饰器的名字。</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">decorator_maker_with_arguments</span><span class="p">(</span><span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;I make decorators! And I accept arguments:&quot;</span><span class="p">,</span> <span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># The ability to pass arguments here is a gift from closures.</span>
</span><span class='line'>        <span class="c"># If you are not comfortable with closures, you can assume it’s ok,</span>
</span><span class='line'>        <span class="c"># or read: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;I am the decorator. Somehow you passed me arguments:&quot;</span><span class="p">,</span> <span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Don&#39;t confuse decorator arguments and function arguments!</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">)</span> <span class="p">:</span>
</span><span class='line'>            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;I am the wrapper around the decorated function.</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;I can access all the variables</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;</span><span class="se">\t</span><span class="s">- from the decorator: {0} {1}</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;</span><span class="se">\t</span><span class="s">- from the function call: {2} {3}</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;Then I can pass them to the decorated function&quot;</span>
</span><span class='line'>                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">))</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">wrapped</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">my_decorator</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decorator_maker_with_arguments</span><span class="p">(</span><span class="s">&quot;Leonard&quot;</span><span class="p">,</span> <span class="s">&quot;Sheldon&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">decorated_function_with_arguments</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;I am the decorated function and only knows about my arguments: {0}&quot;</span>
</span><span class='line'>           <span class="s">&quot; {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">decorated_function_with_arguments</span><span class="p">(</span><span class="s">&quot;Rajesh&quot;</span><span class="p">,</span> <span class="s">&quot;Howard&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c">#outputs:</span>
</span><span class='line'><span class="c">#I make decorators! And I accept arguments: Leonard Sheldon</span>
</span><span class='line'><span class="c">#I am the decorator. Somehow you passed me arguments: Leonard Sheldon</span>
</span><span class='line'><span class="c">#I am the wrapper around the decorated function. </span>
</span><span class='line'><span class="c">#I can access all the variables </span>
</span><span class='line'><span class="c">#   - from the decorator: Leonard Sheldon </span>
</span><span class='line'><span class="c">#   - from the function call: Rajesh Howard </span>
</span><span class='line'><span class="c">#Then I can pass them to the decorated function</span>
</span><span class='line'><span class="c">#I am the decorated function and only knows about my arguments: Rajesh Howard</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意上面的例子：
1、打装饰器的时候，其实是一个函数调用：@decorator_maker_with_arguments(&ldquo;Leonard&rdquo;, &ldquo;Sheldon&rdquo;)。
2、装饰器返回的包装函数，实际上是一个闭包，它引用了装饰器的参数（decorator_arg1和decorator_arg2）。</p>

<h1>functools模块用于装饰器</h1>

<p>functools在python2.5引入的，他包含了函数functools.wraps()，这个函数的作用是拷贝被包装的函数的名字、模块和docstring到它的包装器上。
functools。wraps()实际上也是个装饰器。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># For debugging, the stacktrace prints you the function __name__</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: foo</span>
</span><span class='line'>
</span><span class='line'><span class="c"># With a decorator, it gets messy    </span>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;bar&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@bar</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: wrapper</span>
</span><span class='line'><span class="c"># 输出的信息是包装器的信息，而不是原始函数的信息。</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用&quot;functools&quot; 来解决上面问题</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">functools</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># We say that &quot;wrapper&quot;, is wrapping &quot;func&quot;</span>
</span><span class='line'>    <span class="c"># and the magic begins</span>
</span><span class='line'>    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;bar&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@bar</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: foo</span>
</span><span class='line'><span class="c"># 输出的信息是实际的foo函数的信息</span>
</span></code></pre></td></tr></table></div></figure>


<h1>类作为装饰器</h1>

<p>装饰器除了使用函数的方式外（大部分都是用函数来实现装饰器），还可以使用类的形式。</p>

<p>对于装饰器来说，唯一的约束是：<em>装饰器返回的对象必须可以被当成函数使用，也就是它可以被调用</em>。</p>

<p>如果类被当成装饰器，那么，类必须实现<strong>call</strong>函数。</p>

<p>需要注意的点：</p>

<ul>
<li>类的初始化函数（<strong>init</strong>）需要接受一个函数作为参赛</li>
<li>在给函数打装饰器时，<strong>init</strong>会执行</li>
<li>在调用被装饰的函数时，类的<strong>call</strong>被调用</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">myDecorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>             <span class="k">print</span> <span class="s">&quot;inside myDecorator.__init__()&quot;</span>
</span><span class='line'><span class="o">...</span>             <span class="n">f</span><span class="p">()</span>
</span><span class='line'><span class="o">...</span>     <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>             <span class="k">print</span> <span class="s">&quot;inside myDecorator.__call__()&quot;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="nd">@myDecorator</span>
</span><span class='line'><span class="o">...</span> <span class="k">def</span> <span class="nf">aFunction</span><span class="p">():</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="s">&quot;inside aFunction()&quot;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">inside</span> <span class="n">myDecorator</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
</span><span class='line'><span class="n">inside</span> <span class="n">aFunction</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">aFunction</span><span class="p">()</span>
</span><span class='line'><span class="n">inside</span> <span class="n">myDecorator</span><span class="o">.</span><span class="n">__call__</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>被装饰函数带参数</h2>

<p>如果使用类来作为装饰器，如果被装饰函数需要参数，则定义在<strong>call</strong>函数上。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">decoratorWithoutArguments</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are no decorator arguments, the function</span>
</span><span class='line'><span class="sd">        to be decorated is passed to the constructor.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __init__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c"># 传给被装饰器的参数，传递给__call__()</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        The __call__ method is not called until the</span>
</span><span class='line'><span class="sd">        decorated function is called.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __call__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;After self.f(*args)&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decoratorWithoutArguments</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;sayHello arguments:&#39;</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After decoration&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Preparing to call sayHello()&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;say&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;argument&quot;</span><span class="p">,</span> <span class="s">&quot;list&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After first sayHello() call&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;different&quot;</span><span class="p">,</span> <span class="s">&quot;set of&quot;</span><span class="p">,</span> <span class="s">&quot;arguments&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After second sayHello() call&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># 函数定义的执行结果
</span><span class='line'>Inside __init__()
</span><span class='line'>After decoration
</span><span class='line'>
</span><span class='line'>Preparing to call sayHello()
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside __call__()
</span><span class='line'>sayHello arguments: say hello argument list
</span><span class='line'>After self.f(*args)
</span><span class='line'>
</span><span class='line'>After first sayHello() call
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside __call__()
</span><span class='line'>sayHello arguments: a different set of arguments
</span><span class='line'>After self.f(*args)
</span><span class='line'>
</span><span class='line'>After second sayHello() call
</span></code></pre></td></tr></table></div></figure>


<h2>装饰器带参数</h2>

<p>如果类作为装饰器，装饰器如果带参数，则需要注意的比较多：</p>

<ul>
<li>参数传递给<strong>init</strong>函数。</li>
<li><strong>call</strong>函数需要返回一个包装函数（因为装饰器有参数，所有打装饰器的地方，实际上是个函数调用，这会导致class的<strong>call</strong>调用）。</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">decoratorWithArguments</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are decorator arguments, the function</span>
</span><span class='line'><span class="sd">        to be decorated is not passed to the constructor!</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __init__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">arg1</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">arg2</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg3</span> <span class="o">=</span> <span class="n">arg3</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are decorator arguments, __call__() is only called</span>
</span><span class='line'><span class="sd">        once, as part of the decoration process! You can only give</span>
</span><span class='line'><span class="sd">        it a single argument, which is the function object.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __call__()&quot;</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">wrapped_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Inside wrapped_f()&quot;</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Decorator arguments:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg3</span>
</span><span class='line'>            <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;After f(*args)&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">wrapped_f</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decoratorWithArguments</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;sayHello arguments:&#39;</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After decoration&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Preparing to call sayHello()&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;say&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;argument&quot;</span><span class="p">,</span> <span class="s">&quot;list&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;after first sayHello() call&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;different&quot;</span><span class="p">,</span> <span class="s">&quot;set of&quot;</span><span class="p">,</span> <span class="s">&quot;arguments&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;after second sayHello() call&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>定义输出
</span><span class='line'>Inside __init__()
</span><span class='line'>Inside __call__()  # 因此装饰器是函数调用，因此走到__call__调用
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>After decoration
</span><span class='line'>
</span><span class='line'>Preparing to call sayHello()
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用装饰器调用
</span><span class='line'>Inside wrapped_f()
</span><span class='line'>Decorator arguments: hello world 42
</span><span class='line'>sayHello arguments: say hello argument list
</span><span class='line'>After f(*args)
</span><span class='line'>
</span><span class='line'>after first sayHello() call
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside wrapped_f()
</span><span class='line'>Decorator arguments: hello world 42
</span><span class='line'>sayHello arguments: a different set of arguments
</span><span class='line'>After f(*args)
</span><span class='line'>
</span><span class='line'>after second sayHello() call
</span></code></pre></td></tr></table></div></figure>


<h1>总结</h1>

<p>装饰器可以由函数实现，也可以由类实现，由类实现需要类实现<strong>call</strong>函数。
不管用哪种方式，装饰器返回的必须是一个接受一个函数参数的可调用对象。</p>

<h1>实际例子</h1>

<p>关于装饰器的实际例子，可以参考</p>

<p><a href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a></p>

<h1>参考</h1>

<p><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484</a></p>

<p><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845">http://www.artima.com/weblogs/viewpost.jsp?thread=240845</a>
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 作用域规则]]></title>
    <link href="http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming/"/>
    <updated>2014-09-13T17:07:23+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming</id>
    <content type="html"><![CDATA[<h1>作用域规则</h1>

<p>每当一个函数执行，都会创建一个局部命名空间（local namespace）。这个命名空间代表了一个局部环境，这个环境包含了凡是参数的名字、在函数内定义的局部变量等。当解析一个名字时，解析器会：</p>

<ul>
<li>首先检查局部环境变量</li>
<li>如果在局部命名空间中找不到，然后再往上寻找全局命名空间（global namespace），全局命名空间是函数定义所在的模块。</li>
<li>如果在全局命名空间不存在，解释器会查找内置的命名空间，如果还找不到，则NameError异常抛出</li>
</ul>


<p>python的命名空间的一个特点就是：在函数内处理全局变量。</p>

<p>比如：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="c"># a 还是 42</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，虽然在函数foo内给a赋值为13，但是：<em>当一个变量在函数内赋值时，结果总是把这个变量绑定到局部命名空间中</em>，因此在foo内，a与全局变量的a是不一样的。</p>

<p>如果要在函数内修改全局变量，必须使用<em>global</em>关键字来修饰变量。表示的意思是简单的生命这个名字属于全局命名空间。这只在这个变量需要被修改的情况下。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="mi">37</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="k">global</span> <span class="n">a</span>  <span class="c"># &#39;a&#39; 此时在全局命名空间中</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'>  <span class="n">b</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="c"># a 是 13. b 仍然是 37.</span>
</span></code></pre></td></tr></table></div></figure>


<h2>嵌套函数中的变量作用域</h2>

<p>python支持嵌套函数定义，也就是在函数内定义函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span> <span class="c"># Nested function definition </span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>当作用域涉及到嵌套函数时，变量的搜寻是按照<em>词法范围（lexical scoping）</em>来查找的。意思是：</p>

<ul>
<li>变量名字受限检查局部范围</li>
<li>然后是函数定义处外围范围，依次往外查找，从最内层到最外层范围</li>
<li>然后就是全局命名空间</li>
<li>最后是内置的命名空间</li>
</ul>


<p>在给变量赋值时，牵扯到嵌套函数，python2有个限制是：</p>

<ul>
<li>只允许在最内层范围的和全局范围的（使用global）的变量可以被赋值。</li>
</ul>


<p>这意味着：</p>

<ul>
<li>内部函数不能够给一个局部变量赋值，这个局部变量是定义在内部函数的外围函数内。</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">decrement</span><span class="p">():</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c"># 在Python 2是错误的，这里不能修改这个值。</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">decrement</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在python3中，可以使用<em>nonlocal</em>关键字来修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">decrement</span><span class="p">():</span>
</span><span class='line'>      <span class="n">nonlocal</span> <span class="n">n</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c"># 绑定到外围的 n (Python 3)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">decrement</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个局部变量在赋值前被使用，则会抛出UnboundLocalError的错误，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">i</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># 导致UnboundLocalError 异常 </span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，变量<em>i</em>被定义为局部变量（在函数内被赋值，并且没有global关键字声明），这样，在执行 i = i +1 语句时，会试图读取变量“i”的值，会导致错误。</p>

<h1>函数作为对象和闭包（closure）</h1>

<h2>函数作为对象</h2>

<p>python中，函数是一级对象（first-class），意思是</p>

<ul>
<li>函数可以作为参数传递给其它函数</li>
<li>放在数据结构中</li>
<li>以及作为结果从函数中返回。</li>
</ul>


<p>注意：</p>

<blockquote><p>当函数作为数据被处理时，需要注意的是：函数隐含的携带了在函数定义处的外围环境信息。这会影响到自由的变量在函数内怎么被绑定。</p></blockquote>

<p>比如下面例子：</p>

<figure class='code'><figcaption><span>foo_test.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">33</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_x</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在foo.py文件中导入foo_test：</p>

<figure class='code'><figcaption><span>foo.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="n">func</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">(</span><span class="n">foo_test</span><span class="o">.</span><span class="n">print_x</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">//</span> <span class="err">输出结果是</span><span class="mi">33</span><span class="err">，而不是此处定义的</span><span class="mi">42</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，需要注意的是print_x使用的x是他所定义处的x的值，而不是在执行处的值，虽然在执行的地方，也定义了同样的变量。</p>

<h2>闭包</h2>

<p>闭包的定义：
组成函数的语句，与执行的环境绑定在一起，产生的对象，被称为闭包。可以简单的认为闭包是一个函数，它在词法上下文中引用了自由变量，所谓自由变量就是除局部变量以外的变量。</p>

<p>闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例</p>

<p>一般有闭包特征的语言有下面这样的特性：</p>

<ul>
<li>函数是第一级对象（first-class）</li>
<li>函数可以嵌套定义。</li>
</ul>


<p>当嵌套函数被使用时，闭包会捕获嵌套函数执行所需要的整个环境。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">foo</span>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">helloworld</span><span class="p">():</span>
</span><span class='line'>  <span class="k">return</span> <span class="s">&quot;Hello World. x is </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span>
</span><span class='line'>  <span class="n">foo</span><span class="o">.</span><span class="n">callf</span><span class="p">(</span><span class="n">helloworld</span><span class="p">)</span>     <span class="c"># returns &#39;Hello World, x is 13&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>闭包和嵌套函数在你想延迟计算时，比较有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">urlopen</span>
</span><span class='line'><span class="c"># from urllib.request import urlopen (Python 3) </span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">page</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">get</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python_url</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.python.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython_url</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.jython.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python_url</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x95d5f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x9735f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">pydata</span> <span class="o">=</span> <span class="n">python</span><span class="p">()</span>  <span class="c"># 读取url内容</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jydata</span> <span class="o">=</span> <span class="n">jython</span><span class="p">()</span>  <span class="c"># 读取url内容</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于上面这个闭包例子，解释如下：</p>

<ul>
<li>两个变量python_url和jython_url实际上是两个不同的get函数的版本（语句与外围环境的绑定）</li>
<li>即使创建这两个变量的函数page不再运行，get函数暗中的携带了get函数使用的外围get函数定义处的变量。</li>
<li>当get调用时，绑定了代码和外围的变量。</li>
</ul>


<p>闭包一个非常有用的方式是：<em>可以用来保存跨越一系列函数调用的状态（函数式编程所用到的状态的保存）</em>，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">next</span><span class="p">():</span>
</span><span class='line'>      <span class="n">nonlocal</span> <span class="n">n</span>  <span class="c"># python3</span>
</span><span class='line'>      <span class="n">r</span><span class="o">=</span><span class="n">n</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">r</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">next</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Example use</span>
</span><span class='line'><span class="nb">next</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>  <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>  <span class="c"># 获取下一个值</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，闭包被用来保存内部的计数值 n。这样，每次调用next()函数时，都能够更新和返回上一个计数变量的值（感觉就是更新了一个全局变量，但是这个n实际上是一个局部变量）。</p>

<p>假设，语言不支持闭包，那么要实现上面同样的功能，可以这样(基本原则是在函数外定义一个变量，变量的生命周期不随函数调用而结束)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Countdown</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>      <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Example use</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="n">Countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>  <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c"># 获取下一个值</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：</p>

<blockquote><p>闭包可以保存变量的状态，这个变量不随着闭包调用结束而丢失。重要的特性。
闭包可以捕获嵌套函数的环境的特性，在包装一个存在的函数来增加额外的功能的时候，非常有用（装饰器）。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序结构和控制]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow/"/>
    <updated>2014-09-06T21:56:14+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow</id>
    <content type="html"><![CDATA[<h1>程序结构和执行</h1>

<p>python程序被组织为一个语句序列。所有的语言特性，包括变量赋值、函数定义、类定义和模块导入等，都是语句，都是与其他语句具有相同状态。</p>

<p>因此所有语句都可以放置在程序的任何地方。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
</span><span class='line'>          <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected a float&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当加载文件时，python解释器顺序的执行每一条语句，知道不能执行为止。</p>

<p>这种执行方式对于简单的作为主程序执行，或者经过import进行导入是一致的。</p>

<!-- more -->


<h1>循环和迭代</h1>

<p>如果要迭代一个列表，可以使用常用的for in格式。如果迭代列表，还需要获取索引，可以使用enumerate函数，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>enumerate()函数实际上创建了一个iterator，这个迭代器每次返回一个元组(index, s[index])</p>

<p>如果要迭代两个list，比如对两个list的每项元素相加。可以使用zip函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># s and t are two sequences </span>
</span><span class='line'><span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>zip()函数联合了s和t的元素，生成了一个元组序列：s[0],t[0]), (s[1],t[1]), (s[2], t[2]),等，直到最短的list结束。</p>

<p>注意：
* python2中，zip函数全部消耗了序列元素，生成一个序列。如果s和t比较大，那会生成一个大的列表，进而消耗内存资源。
* python3中，zip改进了，一次生成一个元素，而不是一下子生成一个巨大的序列。
* python2中，可以使用itertools.izip()函数来优化，其方式与python3中的zip一致。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">itertools</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>循环结构，还可以有一个else的语句,for-else或者while-else，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># for-else</span>
</span><span class='line'><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">):</span>
</span><span class='line'>  <span class="n">stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">stripped</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span><span class='line'><span class="c"># process the stripped line ...</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Missing section separator&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>有两种情况下能够执行到else分支：
* 立即执行，既循环条件不满足。
* 迭代执行完毕，这意味着，如果是break语句或异常语句中断了循环，则不会执行else分支。</p>

<p>一般需要用到for-else这种结构的情况是：迭代完数据，并且需要检查或者设置标记时，可以使用。</p>

<h1>异常</h1>

<p>记住几个点：</p>

<ol>
<li>在except语句中，既可以 except Exception as e，也可以except Exception, e，后面一个是老式用法，不推荐</li>
<li>可以一次except捕获多个异常：<em>except (IOError, TypeError, NameError) as e:</em></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">do</span> <span class="n">something</span>
</span><span class='line'><span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c"># Handle I/O, Type, or Name errors</span>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ol>
<li>try也支持else语句，执行else的条件是try块中没有抛出异常：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>  <span class="n">error_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Unable to open foo : </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>上下文管理和with语句</h1>

<p>在遇到异常的情况下，正确地管理系统资源（比如锁、文件、连接等）是比较棘手的。比如异常可能会绕过释放重要系统资源的代码。</p>

<p><em>with</em>语句允许代码在一个运行的上下文中执行代码，这个运行的上下文被一个作为上下文管理器的对象来控制。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># 当控制离开with代码块时，with自动的将打开的文件关闭</span>
</span><span class='line'><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;debuglog&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Debugging</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">threading</span>
</span><span class='line'><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
</span><span class='line'><span class="c"># 当控制进入和离开with代码块时，自动获取和释放锁。</span>
</span><span class='line'><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
</span><span class='line'>  <span class="c"># Critical section statements</span>
</span><span class='line'>  <span class="c"># End critical section</span>
</span></code></pre></td></tr></table></div></figure>


<p>语法 <em>with obj</em> 允许让对象obj来控制当执行进入和离开代码块时的行为。</p>

<ul>
<li>进入：
当with obj执行时，它执行obj.<strong>enter</strong>()函数来标记正在进入一个新的上下文。</li>
<li>离开：

<blockquote><p>当控制离开上下文时，执行obj.<strong>exit</strong>(type,value,traceback)，此时，如果没有异常发生，<strong>exit</strong>()函数的三个参数都被设置为None，表示无异常。
否则type,value,traceback就会被赋值为与导致控制流离开with代码块的异常相关联的信息。
<strong>exit</strong>() 返回True和False来标记是否产生的异常被处理了。如果返回False，异常会继续向上传递。</p></blockquote></li>
</ul>


<p>with还可以跟着一个as标识符。<em>with obj as var:</em>如果设置了，则obj.<strong>enter</strong>()的返回值会被赋值给as指定的对象。注意，obj可以不等于var的值。</p>

<p>注意：</p>

<blockquote><p>with只能与支持上下文管理协议的对象（实现了<strong>enter</strong>()和<strong>exit</strong>）一块工作。</p></blockquote>

<p>用户可以实现这两个函数来使自己定义的对象支持上下文管理协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">ListTransaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span> <span class="o">=</span> <span class="n">thelist</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">type</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">tb</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class='line'>          <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">False</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用</span>
</span><span class='line'><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>      <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</span><span class='line'>      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;We&#39;re hosed!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span> <span class="k">pass</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以使用contextlib模块来简化上下文对象的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@contextmanager</span>
</span><span class='line'><span class="k">def</span> <span class="nf">ListTransaction</span><span class="p">(</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>  <span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">workingcopy</span>
</span><span class='line'>  <span class="c"># Modify the original list only if no errors </span>
</span><span class='line'>  <span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">workingcopy</span>
</span></code></pre></td></tr></table></div></figure>


<p>yield生成的对象，就相当于<strong>enter</strong>函数返回的对象。
当执行到<strong>exit</strong>函数时，执行会从yield后继续执行。</p>

<p>如果在上下文中出现了异常，可异常可以在生成器函数中展现（函数内有yield的函数，调用后产生生成器）</p>

<h1>assert</h1>

<p>语法是这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">assert</span> <span class="n">test</span> <span class="p">[,</span> <span class="n">msg</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># test表达式生成True或者False，如果为False，assert会生成一个AssertionError异常，并附带msg信息</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于assert，需要知道以下几点：
* 不能使用assert用来为了使程序正确而必须执行的代码（比如检查用户输入是否合法，则不能使用assert），因为有可能不被执行（运行python使用-O参数）
* assert应该被用来事情总是是true的情况，否则就是个bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress syntax]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/octopress-syntax/"/>
    <updated>2014-09-06T10:53:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/octopress-syntax</id>
    <content type="html"><![CDATA[<h1>代码高亮语法</h1>

<blockquote><p>{ % codeblock [lang:language] [title] [url] [link text] % }
code snippet
{ % endcodeblock % }</p></blockquote>

<p>例子：</p>

<figure class='code'><figcaption><span>Javascript Array Syntax</span><a href='http://j.mp/pPUUmW'>MDN Documentation </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arrayLength</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">element0</span><span class="p">,</span> <span class="nx">element1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">elementN</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>图片语法</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img [class names] /path/to/image [width] [height] [title text [alt text]] %}</span></code></pre></td></tr></table></div></figure>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img /images/assets/linux.png %}
</span><span class='line'>{ % img left /images/assets/linux.png Place Kitten #2 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 Place Kitten #3 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 'Place Kitten #4' 'An image of a very cute kitten' %}</span></code></pre></td></tr></table></div></figure>


<h1>多个分类</h1>

<p>例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>categories:
</span><span class='line'>- CSS3
</span><span class='line'>- Sass
</span><span class='line'>- Media Queries
</span></code></pre></td></tr></table></div></figure>


<h1>显示部分内容</h1>

<p>插入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- more --&gt;</span></code></pre></td></tr></table></div></figure>


<p>会让文章下面的部分不显示，并会提示一个按钮，来查看未显示的内容。</p>

<h1>命令</h1>

<p>生成内容
rake generate</p>

<p>预览
rake preview</p>

<p>提交：
git add .
git commit -m &ldquo;new&rdquo;
git push origin source</p>

<p>发布：
rake deploy</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux performance observability tools]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools/"/>
    <updated>2014-09-06T10:42:48+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools</id>
    <content type="html"><![CDATA[<p><img src="http://baren.github.io/images/assets/linux.png" title="linux" alt="alt text" /></p>

<p>链接：<a href="http://www.brendangregg.com/linuxperf.html">http://www.brendangregg.com/linuxperf.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(线程)]]></title>
    <link href="http://baren.github.io/blog/2014/08/28/pthread/"/>
    <updated>2014-08-28T20:00:53+08:00</updated>
    <id>http://baren.github.io/blog/2014/08/28/pthread</id>
    <content type="html"><![CDATA[<h1>线程概念</h1>

<p>主要是POSIX线程，也就是pthread。</p>

<p>正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。</p>

<p>判断系统是否支持pthread，可以使用宏<em>POSIX_THREADS进行测试，还可以把</em>SC_THREADS传递给sysconf函数来运行时判断。</p>

<p>线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：</p>

<ul>
<li>进程之间共享数据非常困难</li>
<li>使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。</li>
</ul>


<p>使用线程，解决这上面这些问题：</p>

<ul>
<li>线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。</li>
<li>线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。</li>
</ul>


<p>除了共享全局内存，线程还共享一些其他属性，包括</p>

<ul>
<li>进程id和父进程id</li>
<li>进程组合session id</li>
<li>控制终端</li>
<li>进程凭证（用户和组id）</li>
<li>打开的文件描述符（比较重要）</li>
<li>信号处理</li>
<li>文件系统相关信息：umask、当前工作目录和根目录</li>
<li>等</li>
</ul>


<p>下面是各个线程不同的属性：</p>

<ul>
<li>线程id</li>
<li>信号mask</li>
<li>线程私有数据</li>
<li>errno变量</li>
<li>等</li>
</ul>


<!-- more -->


<h2>线程和errno</h2>

<p>进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。</p>

<p>这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。</p>

<p>注：</p>

<blockquote><p>在线程中，使用函数的返回错误码更为清晰整洁。</p></blockquote>

<h2>线程ID</h2>

<p>进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用<code>pid_t</code>来表示；线程的ID，使用<code>pthread_t</code>类型来表示。</p>

<p>为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。</p>

<p>下面是处理线程ID的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>// 比较两个线程ID
</span><span class='line'>int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值
</span><span class='line'>
</span><span class='line'>// 获取线程的ID
</span><span class='line'>pthread_t pthread_self(void);
</span></code></pre></td></tr></table></div></figure>


<h1>线程创建</h1>

<p>使用pthread_create函数创建线程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
</span><span class='line'>void *(*start)(void *), void *arg);
</span><span class='line'>
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的参数意义是：</p>

<ul>
<li>thread——线程创建成功后，将线程的ID写入这个指针指向的内存中</li>
<li>attr——创建线程的属性</li>
<li>start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数</li>
<li>arg——无类型指针参数，作为线程执行函数的参数传入</li>
</ul>


<h1>线程终止</h1>

<ul>
<li><p>进程终止会导致线程终止：</p>

<ul>
<li>任一线程调用了exit，<em>Exit或</em>exit函数，整个进程终止</li>
<li>若信号的默认动作是终止进程，则把信号发送到线程会终止进程</li>
</ul>
</li>
<li><p>单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。</p>

<ul>
<li>线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）</li>
<li>线程可以被同一进程中的其它线程取消（pthread_cancel）</li>
<li>线程调用pthread_exit函数退出</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>void pthread_exit(void *retval);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_exit接收的参数，就是线程的返回值。</p>

<p>其它线程可以通过pthread_join获取这个值。</p>

<p>注意：</p>

<blockquote><p>pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。</p></blockquote>

<h2>pthread_join函数</h2>

<p>pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;pthread.h&gt;
</span><span class='line'>int pthread_join(pthread_t thread, void **retval); // 成功，返回0
</span></code></pre></td></tr></table></div></figure>


<p>如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。</p>

<p>注意：</p>

<blockquote><p>如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。</p></blockquote>

<p>如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程</p>

<p>还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &amp;status, options)); 等待任意进程，线程没有这个操作。</p>

<h2>pthread_detach函数</h2>

<p>默认情况下，线程是可<em>结合的（joinable）</em>，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。</p>

<p>某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是<em>分离的（detached）</em>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>int pthread_detach(pthread_t thread);
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。</p>

<h1>线程参数传递和返回值</h1>

<p>在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。</p>

<ul>
<li>在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数</li>
<li>当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：

<blockquote><ul>
<li>在线程执行函数返回一个指针</li>
<li>调用pthread_exit()，把返回值指针作为pthread_exit的参数</li>
</ul>
</blockquote></li>
</ul>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>/*  our macro for errors checking                                           */
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>#define COND_CHECK(func, cond, retv, errv) \
</span><span class='line'>if ( (cond) ) \
</span><span class='line'> { \
</span><span class='line'>    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
</span><span class='line'>                __FILE__,__LINE__,func,retv,strerror(errv)); \
</span><span class='line'>                   exit(EXIT_FAILURE); \
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'>#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
</span><span class='line'>#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>void *th_func1(void *arg);
</span><span class='line'>void *th_func2(void *arg);
</span><span class='line'>void test_thread_ret();
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  test_thread_ret();
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void test_thread_ret()
</span><span class='line'>{
</span><span class='line'>  int t_ret;
</span><span class='line'>  // pthread ret
</span><span class='line'>  pthread_t t1, t2;
</span><span class='line'>  void *tret;
</span><span class='line'>  t_ret = pthread_create(&t1, NULL, th_func1, NULL);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>  t_ret = pthread_create(&t2, NULL, th_func2, (void *)2);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>
</span><span class='line'>  printf("join t1\n");
</span><span class='line'>  t_ret = pthread_join(t1, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 1 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>  printf("join t2\n");
</span><span class='line'>  t_ret = pthread_join(t2, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 2 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>void *th_func1(void *arg)
</span><span class='line'>{
</span><span class='line'>  printf("thread 1 runing\n");
</span><span class='line'>  return (void *)1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void *th_func2(void *arg)
</span><span class='line'>{
</span><span class='line'>  int * a;
</span><span class='line'>  a = (int *)arg;
</span><span class='line'>  printf("thread 2 arg is %d.\n", (int) a);
</span><span class='line'>  pthread_exit((void *) 2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>取消线程</h1>

<p>线程可以调用pthread_cancel函数<em>请求</em>取消同一进程中的其它线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_cancel(pthread_t tid);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cancel并不等待线程终止仅仅提出请求。</p>

<p>线程在取消请求发出后还继续运行，直到线程打到某个<em>取消点</em>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>

<h1>线程同步</h1>

<p>有三种同步方式：互斥量、读写锁以及条件变量</p>

<h2>互斥量</h2>

<p>互斥量用pthread_mutex_t数据类型表示，使用互斥量之前必须对其进行初始化
* 初始化为常量PTHREAD_MUTEX_INITIALIZER，前提是pthread_mutex_t为静态分配的
* 调用pthread_mutex_init函数初始化动态分配的pthread_mutex_t变量。</p>

<p>注意：
* 如果pthread_mutex_t是动态分配的（比如通过malloc），则须用pthread_mutex_destory函数来师傅内存。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">mutex</span><span class="p">,</span> <span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">pthread_mutex_destory</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对互斥量加锁解锁函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对互斥量要找到平衡点，既不使锁得粒度太粗导致线程阻塞，又不能因为锁得粒度太细导致代码复杂性和过多锁导致性能下降。</p>

<h2>读写锁</h2>

<p>与互斥量类似，但是读写锁具有更高的并行性。读写锁有三种状态：
* 读模式下的锁状态
* 写模式下的加锁状态
* 不加锁状态</p>

<p>对于读写锁，有几个特征：</p>

<ul>
<li>一次只能有一个线程可以占有写锁，但是多个线程可以同时占用读锁。</li>
<li>当处于写锁状态时，所有试图对其进行加读锁的线程，都会被阻塞</li>
<li>当处于读锁状态时，所有试图对齐进行加读锁的线程，都可以立即获得</li>
<li>如果在读锁状态下，线程希望以写锁对此锁进行加锁，必须阻塞直到线程释放获的的读锁才可以加上写锁。</li>
<li>为了防止一直处于读锁中而使写锁一直阻塞，一旦进行加写锁阻塞，会阻塞后续对其进行的增加读锁行为。</li>
</ul>


<p>读写锁也叫共享-独占锁。</p>

<p>对读写锁也需要初始化和销毁操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_init</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">,</span> <span class="kt">pthread_rwlockattr_t</span> <span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_destory</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>读写锁加锁操作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_rdlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_wrlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_unlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 实现读写锁的时候，可能会对共享模式下可获取的锁进行数量限制，因此要检查pthread_rwlock_rdlock()的返回值。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>条件变量</h2>

<p>mutex阻止了多个线程同时访问共享的变量。
条件变量允许一个线程在共享的变量状态改变的时候通知其他线程这个改变，并允许其它线程等待（block）这个通知。</p>

<p>下面代码，没有使用条件变量，只是使用互斥量来实现，来证明在特定情况下，条件变量的用处。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="n">mtx</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 表示可消费的数目</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在生产线程中的代码</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">avail</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* 仅仅表示有可用资源，其它步骤省略*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在主线程中，主要用来消费生产线程生产的数据</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 消耗生产的数据 */</span>
</span><span class='line'>      <span class="cm">/* 用生产的数据做一些其它时期 */</span>
</span><span class='line'>      <span class="n">avail</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面用互斥量实现的生产者消费者同步代码，问题有：</p>

<ol>
<li>空耗CPU，会一直持续循环来检查avail的状态</li>
</ol>


<p>条件变量解决了这个问题，允许消费进程在没有数据的时候挂起（wait），当有数据的时候通知线程。</p>

<p>条件变量通常与互斥量联合使用：</p>

<ul>
<li>互斥量保护共享变量的修改</li>
<li>条件变量则用来通知状态的修改</li>
</ul>


<p>条件变量在使用前必须初始化，跟互斥量一样，既可以静态初始化，也可以动态初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 静态</span>
</span><span class='line'><span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 动态，pthread_cond_t变量是动态分配的。需要调用下面函数</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_destroy</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>基于条件变量的通知和等待</h2>

<p>条件变量的主要操作就是signal（通知）和wait（等待），通知可以一次给一个线程通知，也可以广播给所有等待线程。
wait操作是等待，直到有通知到来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
</span><span class='line'><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abstime</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面代码是使用条件变量的典型代码：</p>

<figure class='code'><figcaption><span>消耗线程代码</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>         <span class="cm">/* 锁住互斥量          */</span>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">predicate</span><span class="p">)</span> <span class="p">{</span>                    <span class="cm">/* 检查 predicate      */</span>
</span><span class='line'>  <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condvar</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>   <span class="cm">/* go to sleep - recheck pred on awakening    */</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cond_wait() 做了以下事情：</p>

<ul>
<li>释放互斥量的锁</li>
<li>让线程进入休眠状态（sleep）</li>
</ul>


<p>当某个线程进入休眠状态，需要有其它线程唤醒它，这就是生产线程：</p>

<figure class='code'><figcaption><span>生产线程</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>              <span class="cm">/* 锁住互斥量       */</span>
</span><span class='line'><span class="n">predicate</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>                             <span class="cm">/* 设置 predicate    */</span>
</span><span class='line'><span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condvar</span><span class="p">);</span>          <span class="cm">/* 唤醒每一个等待条件变量的线程     */</span>
</span><span class='line'><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>               <span class="cm">/* 解锁互斥量     */</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，重要的调用是pthread_cond_broadcast()，他会唤醒每一个等待条件变量的线程。第一个被唤醒的线程还是处于pthread_cond_wait函数调用中。然后，pthread_cond_wait完成了下面操作：</p>

<ul>
<li>重新获得互斥量锁。</li>
</ul>


<p>然后执行就再次检查predicate。</p>

<h3>条件变量实际例子（join任何终止的线程）</h3>

<p>使用pthread_join仅仅可以等待一个指定的线程，并没办法join任何终止的线程。使用条件变量可以实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(信号)]]></title>
    <link href="http://baren.github.io/blog/2014/06/24/signal/"/>
    <updated>2014-06-24T20:00:20+08:00</updated>
    <id>http://baren.github.io/blog/2014/06/24/signal</id>
    <content type="html"><![CDATA[<h1>信号概念</h1>

<p>信号是软中断，提供了一种处理异步事件的方法</p>

<p>关于信号：</p>

<ul>
<li>每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中</li>
<li>产生信号的条件

<blockquote><ul>
<li>用户按终端键，印发终端产生信号</li>
<li>硬件异常产生信号，比如无效的内存引用，除数为0等</li>
<li>进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）</li>
<li>用户用kill命令给进程发送信号</li>
<li>当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。</li>
</ul>
</blockquote></li>
</ul>


<!-- more -->


<p>几种处理信号的方式</p>

<ul>
<li>忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的</li>
<li>捕捉信号——需要注册一个信号处理函数</li>
<li>执行默认操作——大多数的信号的默认动作是终止信号</li>
</ul>


<h1>signal函数</h1>

<p>unix系统提供了两个改变信号处理的方式：signal和signalaction函数</p>

<p>现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void (*signal(int sig, void (*func)(int)))(int)
</span><span class='line'>// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
</span><span class='line'>// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址</span></code></pre></td></tr></table></div></figure>


<p>signal函数太复杂，可以使用typedef类型定义简化一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void Sigfunc(int);
</span><span class='line'>
</span><span class='line'>Sigfunc *signal(int Sigfunc *func);
</span></code></pre></td></tr></table></div></figure>


<p>一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
</span><span class='line'>#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
</span><span class='line'>#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针
</span></code></pre></td></tr></table></div></figure>


<p>可以使用这几个预定义函数常量，来判断信号捕获程序。</p>

<p>关于信号处理程序，注意点：</p>

<ul>
<li>只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误</li>
<li>SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31</li>
<li>kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的</li>
</ul>


<h1>中断的系统调用</h1>

<h2>中断低速系统调用</h2>

<p>若进程调用了一个低速的系统调用，</p>

<p>并且这个系统调用正在阻塞</p>

<p>此时，</p>

<p>捕捉到一个信号。</p>

<p>结果是：该系统调用就被中断不被执行了。</p>

<p><em>注意</em>：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用</p>

<p>低速系统调用是可能是进程阻塞的系统调用，一般包括</p>

<ul>
<li>读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞</li>
<li>打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）</li>
<li>pause和wait，pause会使调用进程一直休眠，指导捕获一个信号</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数</li>
</ul>


<p>这个需要注意的是，磁盘IO操作并不是低速系统调用。</p>

<h2>低速系统调用被中断后的处理和重启</h2>

<p>一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。</p>

<p>这样我们就能够处理这种失败。有两种处理方式：</p>

<ul>
<li>系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作</li>
<li>某些中断的系统调用支持自动重启动</li>
</ul>


<h3>手动检查</h3>

<p>比如可以这样处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
</span><span class='line'>  continue;  // 啥也不做
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<p>如果经常使用这种检查，还可以定义一个宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NO_EINTR(stmt)   while((stmt) == -1 && errno == EINTR);
</span><span class='line'>
</span><span class='line'>// 然后
</span><span class='line'>
</span><span class='line'>NO_EINTR(cnt == read(fd, buf, BUF_SIZE));
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<h3>自动重启动</h3>

<p>为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wait waitpid read write ioctl readv writev
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。</p>

<h1>可重入函数</h1>

<p>在信号处理程序中，不能调用不可重入函数。</p>

<p>所谓不可重入函数是指：</p>

<ol>
<li>它们使用了静态数据结构或全局变量</li>
<li>调用malloc和free，因为malloc维护了一个全局链表</li>
<li>标准IO函数</li>
</ol>


<p>而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数</p>

<p>在标准C函数库中，不可重入函数比较普遍。</p>

<p>比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。</p>

<h1>可靠信号的术语和语义</h1>

<ul>
<li>递送（delivery）信号：当引发信号的事件<em>发生</em>时，为进程产生一个信号（或向进程产生一个信号）</li>
<li>未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的</li>
</ul>


<p>进程可以设置阻塞信号。</p>

<p>若信号被进程设置为阻塞，并且对该信号的动作是系统<strong>默认动作</strong>或<strong>捕捉该信号</strong>，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。</p>

<p>解除未决状态：
    * 对信号解除了阻塞
    * 或者将此信号的动作改为忽略。</p>

<p>注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>void sig_int(int sig);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t osig;
</span><span class='line'>  sigset_t newsig, o_set;
</span><span class='line'>
</span><span class='line'>  sigemptyset(&newsig);
</span><span class='line'>  sigaddset(&newsig, SIGINT);
</span><span class='line'>  // if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
</span><span class='line'>  if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  //pause();
</span><span class='line'>  sleep(4);
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_int) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf(" pause ...\n");
</span><span class='line'>  sigprocmask(0, NULL, &o_set);
</span><span class='line'>  if (sigismember(&o_set, SIGINT))
</span><span class='line'>  {
</span><span class='line'>      printf("is mask\n");
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>void sig_int(int sig)
</span><span class='line'>{
</span><span class='line'>  printf("int sig hand\n");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>执行结果是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果是默认处理，在sleep过程中，产生中断信号，结果是：
</span><span class='line'>$ ./test_pend
</span><span class='line'>^Cint sig hand
</span><span class='line'> pause ...
</span><span class='line'>
</span><span class='line'> 如果改成忽略，在sleep过程中，产生中断信号，结果是：
</span><span class='line'> ./test_pend
</span><span class='line'>^C pause ...</span></code></pre></td></tr></table></div></figure>


<p>注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。</p>

<h1>kill和raise函数</h1>

<p>kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int kill(pid_t pid, int signo);
</span><span class='line'>int raise(int signo);</span></code></pre></td></tr></table></div></figure>


<p>下面是等价的：</p>

<p>raise(signo) == kill(getpid(), signo)</p>

<p>kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid &lt; 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。</p>

<p>上面提到了，给其它进程发信号需要权限，具体是指：</p>

<ul>
<li>超级用户可以将信号发送给任一进程</li>
<li>非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID</li>
</ul>


<p>注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH</p>

<h1>alarm和pause函数</h1>

<p>alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>unsigned int alarm(unsigned int seconds);</span></code></pre></td></tr></table></div></figure>


<p>对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的</p>

<p>pause函数使调用进程挂起直到捕捉到一个信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int pause(void)</span></code></pre></td></tr></table></div></figure>


<p>条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR</p>

<h2>使用alarm实现sleep函数，并暴露问题</h2>

<p>使用信号时，需要精细而周到的考虑，下面代码列出几个问题：</p>

<ul>
<li>问题1：竞争条件</li>
</ul>


<p>看下面的sleep1的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int sleep1(unsigned int nsecs)
</span><span class='line'>{
</span><span class='line'>  if(signal(SIGABRT, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("can't signal alarm!\n");
</span><span class='line'>      return nsecs;
</span><span class='line'>  }
</span><span class='line'>  alarm(nsecs);
</span><span class='line'>  pause();
</span><span class='line'>  return (alarm(0)); // 返回未完成的时间
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  ;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。</p>

<ul>
<li>问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序</li>
</ul>


<p>使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。</p>

<p>第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>static jmp_buf env_alrm;
</span><span class='line'>int sleep2(int);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sleep2(2);
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int sleep2(int sec)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sigalarm err!\n");
</span><span class='line'>      return sec;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alrm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(sec);
</span><span class='line'>      pause();
</span><span class='line'>  }
</span><span class='line'>  return (alarm(0));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  longjmp(env_alrm, 1);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。</p>

<h2>除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限</h2>

<p>下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout);
</span><span class='line'>
</span><span class='line'>static jmp_buf env_alarm;
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char line[100];
</span><span class='line'>  int n;
</span><span class='line'>  n = read_timeout(STDIN_FILENO, line, 100, 3);
</span><span class='line'>  if(n &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("read timeout\n");
</span><span class='line'>  } else {
</span><span class='line'>      printf("read len %d.\n", n);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout)
</span><span class='line'>{
</span><span class='line'>  int n = 0;
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig alarm err\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alarm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(timeout);
</span><span class='line'>      if((n=read(fd, buf, size)) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("read err!\n");
</span><span class='line'>          return n;
</span><span class='line'>      }
</span><span class='line'>      alarm(0);
</span><span class='line'>      return n;
</span><span class='line'>  }
</span><span class='line'>  return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>      longjmp(env_alarm, 1);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>read timeout
</span><span class='line'>user@usertekiMacBook-Pro unix_test$
</span><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>dd
</span><span class='line'>read len 3.</span></code></pre></td></tr></table></div></figure>


<p>注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。</p>

<h1>信号集</h1>

<p>可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigempty(sigset_t *set);
</span><span class='line'>int sigfillset(sigset_t *set);
</span><span class='line'>int sigaddset(sigset_t *set, int signo);
</span><span class='line'>int sigdelset(sigset_t *set, int signo);
</span><span class='line'>  // 四个函数返回值：成功，返回0，失败返回-1
</span><span class='line'>int sigismember(const sigset_t *set, int signo);
</span><span class='line'>  // 若真，返回1，假，返回0，出错，返回-1
</span></code></pre></td></tr></table></div></figure>


<h1>sigpromask函数</h1>

<p>调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>oset非空，则进程当前信号屏蔽字通过oset返回</li>
<li>set非空，则根据第一个参数how指示如何修改当前信号屏蔽字</li>
<li>set为空，不改变</li>
</ul>


<p>how的值：</p>

<ul>
<li>SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集</li>
<li>SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集</li>
<li>SIT_SETMASK: 被set指向的值替代</li>
</ul>


<h1>sigpending函数</h1>

<p>sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigpending(sigset_t *set);</span></code></pre></td></tr></table></div></figure>


<p>注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_quit(int);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t oldset, newset, quitset;
</span><span class='line'>  sigemptyset(&quitset);
</span><span class='line'>  sigaddset(&quitset, SIGINT);
</span><span class='line'>
</span><span class='line'>  // ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  } 
</span><span class='line'>  // ************
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_BLOCK, &quitset, &oldset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  // sleep 5 seconds
</span><span class='line'>  sleep(5);
</span><span class='line'>  if (sigpending(&newset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("pending err \n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if (sigismember(&newset, SIGINT))
</span><span class='line'>      printf("sigquit is block\n");
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &oldset, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask ret sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  printf("sig int unblock\n");
</span><span class='line'>  sleep(5);
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_quit(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("sigquit catch\n");
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>sigaction函数</h1>

<p>sigaction函数的功能是<em>检查</em>或<em>修改</em>与指定信号相关联的处理动作（或同时执行）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
</span><span class='line'>// 成功，返回0，出错返回-1
</span></code></pre></td></tr></table></div></figure>


<p>对于参数：</p>

<ul>
<li>signo是信号</li>
<li>act非空，则修改信号动作</li>
<li>oact非空，则由oact返回上一个动作</li>
</ul>


<p>结构体struct sigaction的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct sigaction {
</span><span class='line'>  void (*sa_handler)(int); // 信号处理函数的地址，或者SIG_IGN或SIG_DFL
</span><span class='line'>  sigset_t sa_mask; // 额外需要阻塞的信号集
</span><span class='line'>  int sa_flags;  // 信号选项，可以设置这个选项来控制处理函数行为
</span><span class='line'>
</span><span class='line'>  /*替换的处理程序，当指定sa_flags为SA_SIGINFO时，采用这个处理函数，提供了额外的一些信息*/
</span><span class='line'>  void (*sa_sigaction)(int, siginfo_t *, void *);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>若更改信号处理函数，则：
* sa_handler指定处理函数的地址
* sa_mask则是信号集，在调用该信号处理函数之前，会先把这个信号集指定的信号加到进程的信号屏蔽字中。信号处理函数返回时，再复原。在信号处理程序被调用时，操作系统建立的新信号屏蔽字也包括正在被递送的信号，这会保证在当前信号处理时，这个信号再次发生，会一直阻塞，直到处理函数完成。
* sa_flags字段指定对信号处理的各个选项:</p>

<blockquote><ul>
<li>SA_RESTART:由此信号中断的系统调用自动重新启动</li>
<li>SA_INTERRUPT: 由此信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 有此选项对信号，会调用sa_sigaction函数，此函数会给额外提供了附加信息：1）指向siginfo结构的指针；2）指向进程上下文标识符的指针</li>
</ul>
</blockquote>

<p>注意：</p>

<blockquote><p>除了那些为了兼容而继续保留原始的signal函数的语义的系统外，大部分系统都是用sigaction来实现signal函数的。</p></blockquote>

<h1>sigsetjmp和siglongjmp函数</h1>

<p>在捕捉到一个信号时，会进入信号捕捉函数，此时会发生：</p>

<ul>
<li>进入信号处理函数时，当前信号会被自动加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序</li>
<li>当正常从信号处理函数中返回时，会自动恢复当前信号为非屏蔽</li>
</ul>


<p>但是，当在信号处理函数内，调用了longjmp函数，那么是否恢复这个被屏蔽的当前信号？</p>

<p>FreeBSD 5.2.1 和Mac OS X10.3中，setjmp和longjmp保持和恢复信号屏蔽字</p>

<p>Linux2.4.22和Solaris9 并不执行这种操作。FreeBSD 5.2.1 和Mac OS X10.3提供函数<em>setjmp和</em>longjmp，他们不保存和恢复信号屏蔽字</p>

<p>为了允许两种形式的行为存在， POSIX.1并没有说明setjmp和longjmp对屏蔽字的作用，而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部跳转是，使用这两个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt; // 与setjmp和longjmp一个头
</span><span class='line'>
</span><span class='line'>int sigsetjmp(sigjmp_buf env, int savemask); // 直接调用，返回0，若从siglongjmp调用返回，则返回非0值
</span><span class='line'>
</span><span class='line'>void siglongjmp(sigjmp_buf env, int val);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>若savemask非零，则env保存进程的当前屏蔽字。并在siglongjmp调用时，恢复由env保存进程的当前屏蔽字。</p>

<p>涉及到信号时，使用sigsetjmp和siglongjmp的典型使用模板是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static sigjmp_buf;
</span><span class='line'>static volatile sig_atomic_t canjump;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>// 在主函数中
</span><span class='line'>if (sigsetjmp(jmpbuf, 1)) {
</span><span class='line'>  ....
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>canjump = 1; // 调用sigsetjmp后才设置canjump为非零
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 然后，在信号处理程序中，这样：
</span><span class='line'>void sig_handler(int) {}
</span><span class='line'>
</span><span class='line'>if (canjmp == 0) // 只有非零时，才调用siglongjmp
</span><span class='line'>  return
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>siglongjmp(jmpbuf, 1);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<blockquote><p>原因：
之所以使用canjump，主要是保护机制，防止当jmpbuf还没有被sigsetjmp初始化时，就调用了信号处理程序。
在非信号环境下没有问题，但在信号环境下，信号是随时发生的，因此需要保护</p></blockquote>

<h1>sigsuspend函数</h1>

<p>屏蔽进程的信号，使用这种技术，可以保护不希望由信号中断的代码临界区。然后在临界区之后等待以前的信号发生。</p>

<p>但是下面的实现方式有问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sigprocmask(SIG_BLOCK, &newmask, &oldmask);
</span><span class='line'>
</span><span class='line'>// .....临界区代码
</span><span class='line'>
</span><span class='line'>1) sigprocmask(SIG_BLOCK, &oldmask, NULL);
</span><span class='line'>2) pause(); // 等待之前阻塞的信号发生
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，1）和2）代码出有问题，会有竞争条件，在sigprocmask和pause之间有可能信号会发生，这会导致pause无法返回，永远阻塞。</p>

<p>解决这个竞争条件的办法就是让这两个操作合并成一个原子操作。这就是sigsuspend函数的由来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigsuspend(const sigset_t * sigmask);
</span></code></pre></td></tr></table></div></figure>


<p>用sigsuspend实现临界区代码，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_int(int signo);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  sigset_t newsigset, oldsigset, waitsigset;
</span><span class='line'>  sigemptyset(&newsigset);
</span><span class='line'>  sigaddset(&waitsigset, SIGUSR1);
</span><span class='line'>  struct sigaction act;
</span><span class='line'>  act.sa_handler = sig_int;
</span><span class='line'>
</span><span class='line'>  if(sigaction(SIGINT, &act, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("siganction err.\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(sigprocmask(SIG_BLOCK, &newsigset, &oldsigset) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  // code procted
</span><span class='line'>  printf("this is procted code!\n");
</span><span class='line'>
</span><span class='line'>  if(sigsuspend(&waitsigset) != -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigsuspend err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf("after sigsuspend\n");
</span><span class='line'>  if(sigprocmask(SIG_SETMASK, &oldsigset, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("revert old sig mask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_int(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("catch signo %d\n", signo);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sigsuspend函数实现的巧妙之处：</p>

<ul>
<li>为了实现解除屏蔽（sigprocmask）和等待（pause），sigsuspend把进程的屏蔽信号设置为参数信号，并在返回后设置为调用sigsuspend之前的屏蔽信号值。</li>
</ul>


<p>sigsuspend函数还有两种经典应用：</p>

<ol>
<li>等待一个信号处理程序设置一个全局变量</li>
<li>父子进程实现同步</li>
</ol>


<p>注意：在实现父子进程通讯，可以使用kill给对象发信号，并使用sigsuspend等待某种条件</p>

<h1>abort函数</h1>

<p>abort函数使异常程序终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void abort(void);
</span></code></pre></td></tr></table></div></figure>


<p>这个函数将SIGABRT信号发送给调用进程。</p>

<p>ISO C规定 abort的实现须向主机环境递送一个成功的通知，一般是通过raise(SITABRT)或kill(gitpid(), SIGABRT)实现，这个规定，允许程序做清理工作。</p>

<p>一般系统的abort实现，都会冲洗输出流以及是否要删除临时文件。</p>

<p>可以看一下abort的函数实现示例，通过这个示例，学会：</p>

<ul>
<li>sigaction函数的使用</li>
<li>kill函数的使用：kill函数可以给其它进程发送信号。若发给本进程，并且此信号是不被阻塞的，那么kill返回之前，该信号（或某个未决、未阻塞的信号）就被传送给了该进程。这样，kill返回了，就知道该进程一定捕捉到该信号。</li>
</ul>


<h1>system函数</h1>

<p>ISO C定义了system函数，这个函数可以执行系统命令，这个函数的实现也牵扯到信号问题。若不处理，会有问题。</p>

<p>这里通过system的实现，注意信号程序开发的各种问题。</p>

<p>看下面调用过程：
<img src="http://baren.github.io/images/assets/Figure10-1.png" title="time-function" alt="alt text" /></p>

<p>若没有处理信号，问题有：</p>

<ul>
<li>若进程（a.out）捕获SIGCHID信号，当system创建的子进程结束，系统会向父进程（a.out）发送SIGCHID信号，父进程会捕捉。<em>但这阻止了system函数获取它自己创建子进程的状态</em></li>
<li>若system系统没有屏蔽中断和退出信号，则如果想给shell调用程序发送中断信号时，系统会同时向负责进程发送信号（因为都属于前台进程组）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程关系)]]></title>
    <link href="http://baren.github.io/blog/2014/05/04/process-relate/"/>
    <updated>2014-05-04T20:00:26+08:00</updated>
    <id>http://baren.github.io/blog/2014/05/04/process-relate</id>
    <content type="html"><![CDATA[<h1>终端登录</h1>

<p>由终端登录至unix，这个过程是类似的，而与所使用的终端无关，终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端，或者是运行窗口系统的图形终端。</p>

<p>终端登录步骤：</p>

<ol>
<li>系统自举时，创建进程ID为1的init进程。使系统进入多用户状态。</li>
<li>init进程读取文件/etc/ttys，对每一个允许登录的终端设备，init进程调用一次fork，fork后的子进程执行getty程序（exec getty程序）</li>
<li>getty程序会调用open函数，以读写方式打开终端，一旦打开设备，则文件描述符0、1、2设置到该设备，输出login:之类的信息</li>
<li>gettty调用login函数（<code>execle("/bin/login", "login", "-p", username, (char *) 0, envp);</code>）</li>
<li>login执行多个工作

<blockquote><p>验证用户、密码正确性，连续几次不对，则退出；父进程init知道子进程终止后，会再次调用fork，执行getty，重复上述动作。登录成功后：
将当前工作目录改为该用户的起始目录（home目录）
chown改变该终端的所有权，使登录用户成为它的所有者
对该终端设备的访问权限改为用户读写
调用setgid及initgroups设置进程的组id
用login所得到的所有信息初始化环境
调用该登录用户的登录shell</p></blockquote></li>
</ol>


<!-- more -->


<h1>网络登录</h1>

<p>在网络登录情况下，所有的登录都是通过内核的网络接口驱动程序（以太网驱动程序），事情并不知道会有多少这样的登录。必须等待一个网络连接请求的到达。</p>

<p>网络登录，一个特点是：1）既能处理终端登录；2）处理网络登录。为了实现，系统采用<em>伪终端</em>（pseudo terminal）的软件驱动程序。</p>

<p>伪终端仿真：</p>

<ul>
<li>串行终端的运行行为，</li>
<li>并将终端操作映射为网络操作，反之亦然</li>
</ul>


<h2>BSD网络登录</h2>

<p>在BSD中，inetd进程负责等待大多数的网络连接。</p>

<p>启动inetd进程的步骤：</p>

<ol>
<li>init进程调用shell，使shell程序执行/etc/rc脚本，</li>
<li>这个脚本启动守护进程inetd，然后shell脚本结束，inetd的父进程变成init。</li>
<li>inetd进程等待TCP/IP连接，当一个连接请求到达时，执行一次fork，生成子进程执行适当的程序。</li>
</ol>


<p>以telnet网络登录为例。</p>

<p>hostname启动的程序被称为telnet服务进程（称为telnetd）。</p>

<p>客户端进行网络登录命令：telnet hostname，这样客户端和hostname以telnet应用协议通过tcp连接交换数据。</p>

<p>然后，</p>

<p>服务端telnetd打开一个伪终端设备，并用fork分成两个进程。</p>

<ul>
<li>父进程处理网络连接的通信</li>
<li>子进程执行login程序</li>
<li>父子进程通过伪终端程序相连接</li>
</ul>


<p>login登录成功，则进行上一节同样的步骤：更改当前工作目录为起始目录，设置登录用户的组ID合用户ID，以及登录用户的初始环境。
然后login调用exec将其自身替换为登录用户的登录shell。</p>

<p>注意：
linux的因特网守护进程是xinetd。</p>

<h1>进程组</h1>

<p>进程组是一个或多个进程的集合。一般进程组与同一个作业相关联（比如shell中，多个命令用管道合起来，这几个命令分别是一个进程，合起来组成一个进程组）。可以接收同一终端的各种信号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>// 返回调用进程的进程组id
</span><span class='line'>pid_t getpgrp(void);
</span></code></pre></td></tr></table></div></figure>


<p>Sigle UNIX Specification将getpgid函数定义为XSI扩展，模仿了此种运行行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t getpgid(pid_t pid);
</span></code></pre></td></tr></table></div></figure>


<p>若参数pid为0，则返回调用进程的进程组id，这时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getpgid(0) == getpgrp()</span></code></pre></td></tr></table></div></figure>


<p>进程组可以有一个组长进程。条件是：</p>

<ul>
<li>组长进程的ID等于组的ID</li>
</ul>


<p>组长进程的权限：</p>

<ul>
<li>创建一个进程组</li>
<li>创建该组中的进程</li>
</ul>


<p>进程组中，只要有一个进程存在，进程组就存在，这与组长进程的存在与否无关。</p>

<p>进程组的生存期是：进程组创建到最后一个进程终止，最后一个进程可以终止，也可以转移到另一个进程组。</p>

<p>加入一个进程组或者创建进程组：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int setpgid(pid_t pid, pid_t pgid);
</span></code></pre></td></tr></table></div></figure>


<p>setpgid函数将pid进程的进程组ID设置为pgid。</p>

<ul>
<li>如果这两个参数相等，则由pid指定的进程变成进程组组长，</li>
<li>如果pid是0，则使用调用者的进程ID。</li>
<li>如果pgid为0，则由pid指定的进程ID将用作进程组ID</li>
</ul>


<p>调用条件：</p>

<ul>
<li>一个进程只能为它自己或者它的子进程设置进程组ID，</li>
<li>在它的子进程调用了exec函数之一后，它就不能再改变该子进程的进程组ID</li>
</ul>


<p>在大多数的作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并使子进程设置其自己的进程组ID。</p>

<h1>会话</h1>

<p>会话是一个或多个进程组的集合。</p>

<p>例如下面程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>proc1  | proc2 &
</span><span class='line'>proc3 | proc 4 | proc5
</span></code></pre></td></tr></table></div></figure>


<p>会产生如下会话，包括三个进程组：
1. 登录shell
2. proc1和proc2属于一个进程组
3. proc3和proc4和proc5属于一个进程组</p>

<p>可以使用setsid函数建立新会话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>pid_t setsid(void);
</span></code></pre></td></tr></table></div></figure>


<p>如果调用这个函数的进程不是一个进程组的组长，则此函数就会创建一个新会话，结果将发生下面三件事：</p>

<ol>
<li>该进程会变成新会话的首进程（session leader）（会话首进程是创建该会话的进程），此时该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程，新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也会中断。</li>
</ol>


<p>如果该进程已经是一个进程组的组长，则函数返回出错。为了防止这种情况，一般先fork再调用。</p>

<h1>控制终端</h1>

<ul>
<li>一个会话可以有一个控制终端，通常是登录到其上的终端设备或者伪终端设备。</li>
<li>建立与控制终端的会话首进程被称为控制进程</li>
<li>一个会话中得几个进程组可被分成<em>一个</em>前台进程组以及一个或者多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，会话中的其它进程组为后台进程组</li>
<li>无论何时键入终端的中断键（ctrl+c），就会将中断信号发送给前台进程组的所有进程</li>
<li>无论何时键入终端的退出键（ctrl+\），将会将退出信号发送给前台进程组中所有进程</li>
<li>如果终端接口检测到调制解释器或网络已经断开连接，则将挂断信号发送给控制进程（会话首进程）</li>
</ul>


<h1>作业控制</h1>

<p>略</p>
]]></content>
  </entry>
  
</feed>
