<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Baren Blog]]></title>
  <link href="http://baren.github.io/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2014-09-06T23:33:53+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序结构和控制]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow/"/>
    <updated>2014-09-06T21:56:14+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow</id>
    <content type="html"><![CDATA[<h1>程序结构和执行</h1>

<p>python程序被组织为一个语句序列。所有的语言特性，包括变量赋值、函数定义、类定义和模块导入等，都是语句，都是与其他语句具有相同状态。</p>

<p>因此所有语句都可以放置在程序的任何地方。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
</span><span class='line'>          <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected a float&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当加载文件时，python解释器顺序的执行每一条语句，知道不能执行为止。</p>

<p>这种执行方式对于简单的作为主程序执行，或者经过import进行导入是一致的。</p>

<!-- more -->


<h1>循环和迭代</h1>

<p>如果要迭代一个列表，可以使用常用的for in格式。如果迭代列表，还需要获取索引，可以使用enumerate函数，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>enumerate()函数实际上创建了一个iterator，这个迭代器每次返回一个元组(index, s[index])</p>

<p>如果要迭代两个list，比如对两个list的每项元素相加。可以使用zip函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># s and t are two sequences </span>
</span><span class='line'><span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>zip()函数联合了s和t的元素，生成了一个元组序列：s[0],t[0]), (s[1],t[1]), (s[2], t[2]),等，直到最短的list结束。</p>

<p>注意：
* python2中，zip函数全部消耗了序列元素，生成一个序列。如果s和t比较大，那会生成一个大的列表，进而消耗内存资源。
* python3中，zip改进了，一次生成一个元素，而不是一下子生成一个巨大的序列。
* python2中，可以使用itertools.izip()函数来优化，其方式与python3中的zip一致。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">itertools</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>循环结构，还可以有一个else的语句,for-else或者while-else，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># for-else</span>
</span><span class='line'><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">):</span>
</span><span class='line'>  <span class="n">stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">stripped</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span><span class='line'><span class="c"># process the stripped line ...</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Missing section separator&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>有两种情况下能够执行到else分支：
* 立即执行，既循环条件不满足。
* 迭代执行完毕，这意味着，如果是break语句或异常语句中断了循环，则不会执行else分支。</p>

<p>一般需要用到for-else这种结构的情况是：迭代完数据，并且需要检查或者设置标记时，可以使用。</p>

<h1>异常</h1>

<p>记住几个点：</p>

<ol>
<li>在except语句中，既可以 except Exception as e，也可以except Exception, e，后面一个是老式用法，不推荐</li>
<li>可以一次except捕获多个异常：<em>except (IOError, TypeError, NameError) as e:</em></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">do</span> <span class="n">something</span>
</span><span class='line'><span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c"># Handle I/O, Type, or Name errors</span>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ol>
<li>try也支持else语句，执行else的条件是try块中没有抛出异常：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>  <span class="n">error_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Unable to open foo : </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>上下文管理和with语句</h1>

<p>在遇到异常的情况下，正确地管理系统资源（比如锁、文件、连接等）是比较棘手的。比如异常可能会绕过释放重要系统资源的代码。</p>

<p><em>with</em>语句允许代码在一个运行的上下文中执行代码，这个运行的上下文被一个作为上下文管理器的对象来控制。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># 当控制离开with代码块时，with自动的将打开的文件关闭</span>
</span><span class='line'><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;debuglog&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Debugging</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">threading</span>
</span><span class='line'><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
</span><span class='line'><span class="c"># 当控制进入和离开with代码块时，自动获取和释放锁。</span>
</span><span class='line'><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
</span><span class='line'>  <span class="c"># Critical section statements</span>
</span><span class='line'>  <span class="c"># End critical section</span>
</span></code></pre></td></tr></table></div></figure>


<p>语法 <em>with obj</em> 允许让对象obj来控制当执行进入和离开代码块时的行为。</p>

<ul>
<li>进入：
当with obj执行时，它执行obj.<strong>enter</strong>()函数来标记正在进入一个新的上下文。</li>
<li>离开：

<blockquote><p>当控制离开上下文时，执行obj.<strong>exit</strong>(type,value,traceback)，此时，如果没有异常发生，<strong>exit</strong>()函数的三个参数都被设置为None，表示无异常。
否则type,value,traceback就会被赋值为与导致控制流离开with代码块的异常相关联的信息。
<strong>exit</strong>() 返回True和False来标记是否产生的异常被处理了。如果返回False，异常会继续向上传递。</p></blockquote></li>
</ul>


<p>with还可以跟着一个as标识符。<em>with obj as var:</em>如果设置了，则obj.<strong>enter</strong>()的返回值会被赋值给as指定的对象。注意，obj可以不等于var的值。</p>

<p>注意：</p>

<blockquote><p>with只能与支持上下文管理协议的对象（实现了<strong>enter</strong>()和<strong>exit</strong>）一块工作。</p></blockquote>

<p>用户可以实现这两个函数来使自己定义的对象支持上下文管理协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">ListTransaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span> <span class="o">=</span> <span class="n">thelist</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">type</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">tb</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class='line'>          <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">False</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用</span>
</span><span class='line'><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>      <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</span><span class='line'>      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;We&#39;re hosed!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span> <span class="k">pass</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以使用contextlib模块来简化上下文对象的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@contextmanager</span>
</span><span class='line'><span class="k">def</span> <span class="nf">ListTransaction</span><span class="p">(</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>  <span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">workingcopy</span>
</span><span class='line'>  <span class="c"># Modify the original list only if no errors </span>
</span><span class='line'>  <span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">workingcopy</span>
</span></code></pre></td></tr></table></div></figure>


<p>yield生成的对象，就相当于<strong>enter</strong>函数返回的对象。
当执行到<strong>exit</strong>函数时，执行会从yield后继续执行。</p>

<p>如果在上下文中出现了异常，可异常可以在生成器函数中展现（函数内有yield的函数，调用后产生生成器）</p>

<h1>assert</h1>

<p>语法是这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">assert</span> <span class="n">test</span> <span class="p">[,</span> <span class="n">msg</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># test表达式生成True或者False，如果为False，assert会生成一个AssertionError异常，并附带msg信息</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于assert，需要知道以下几点：
* 不能使用assert用来为了使程序正确而必须执行的代码（比如检查用户输入是否合法，则不能使用assert），因为有可能不被执行（运行python使用-O参数）
* assert应该被用来事情总是是true的情况，否则就是个bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress syntax]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/octopress-syntax/"/>
    <updated>2014-09-06T10:53:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/octopress-syntax</id>
    <content type="html"><![CDATA[<h1>代码高亮语法</h1>

<blockquote><p>{ % codeblock [lang:language] [title] [url] [link text] % }
code snippet
{ % endcodeblock % }</p></blockquote>

<p>例子：</p>

<figure class='code'><figcaption><span>Javascript Array Syntax</span><a href='http://j.mp/pPUUmW'>MDN Documentation </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arrayLength</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">element0</span><span class="p">,</span> <span class="nx">element1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">elementN</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>图片语法</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img [class names] /path/to/image [width] [height] [title text [alt text]] %}</span></code></pre></td></tr></table></div></figure>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img /images/assets/linux.png %}
</span><span class='line'>{ % img left /images/assets/linux.png Place Kitten #2 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 Place Kitten #3 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 'Place Kitten #4' 'An image of a very cute kitten' %}</span></code></pre></td></tr></table></div></figure>


<h1>多个分类</h1>

<p>例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>categories:
</span><span class='line'>- CSS3
</span><span class='line'>- Sass
</span><span class='line'>- Media Queries
</span></code></pre></td></tr></table></div></figure>


<h1>显示部分内容</h1>

<p>插入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- more --&gt;</span></code></pre></td></tr></table></div></figure>


<p>会让文章下面的部分不显示，并会提示一个按钮，来查看未显示的内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux performance observability tools]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools/"/>
    <updated>2014-09-06T10:42:48+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools</id>
    <content type="html"><![CDATA[<p><img src="http://baren.github.io/images/assets/linux.png" title="linux" alt="alt text" /></p>

<p>链接：<a href="http://www.brendangregg.com/linuxperf.html">http://www.brendangregg.com/linuxperf.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(线程)]]></title>
    <link href="http://baren.github.io/blog/2014/08/28/pthread/"/>
    <updated>2014-08-28T20:00:53+08:00</updated>
    <id>http://baren.github.io/blog/2014/08/28/pthread</id>
    <content type="html"><![CDATA[<h1>线程概念</h1>

<p>主要是POSIX线程，也就是pthread。</p>

<p>正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。</p>

<p>判断系统是否支持pthread，可以使用宏<em>POSIX_THREADS进行测试，还可以把</em>SC_THREADS传递给sysconf函数来运行时判断。</p>

<p>线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：</p>

<ul>
<li>进程之间共享数据非常困难</li>
<li>使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。</li>
</ul>


<p>使用线程，解决这上面这些问题：</p>

<ul>
<li>线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。</li>
<li>线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。</li>
</ul>


<p>除了共享全局内存，线程还共享一些其他属性，包括</p>

<ul>
<li>进程id和父进程id</li>
<li>进程组合session id</li>
<li>控制终端</li>
<li>进程凭证（用户和组id）</li>
<li>打开的文件描述符（比较重要）</li>
<li>信号处理</li>
<li>文件系统相关信息：umask、当前工作目录和根目录</li>
<li>等</li>
</ul>


<p>下面是各个线程不同的属性：</p>

<ul>
<li>线程id</li>
<li>信号mask</li>
<li>线程私有数据</li>
<li>errno变量</li>
<li>等</li>
</ul>


<!-- more -->


<h2>线程和errno</h2>

<p>进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。</p>

<p>这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。</p>

<p>注：</p>

<blockquote><p>在线程中，使用函数的返回错误码更为清晰整洁。</p></blockquote>

<h2>线程ID</h2>

<p>进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用<code>pid_t</code>来表示；线程的ID，使用<code>pthread_t</code>类型来表示。</p>

<p>为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。</p>

<p>下面是处理线程ID的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>// 比较两个线程ID
</span><span class='line'>int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值
</span><span class='line'>
</span><span class='line'>// 获取线程的ID
</span><span class='line'>pthread_t pthread_self(void);
</span></code></pre></td></tr></table></div></figure>


<h1>线程创建</h1>

<p>使用pthread_create函数创建线程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
</span><span class='line'>void *(*start)(void *), void *arg);
</span><span class='line'>
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的参数意义是：</p>

<ul>
<li>thread——线程创建成功后，将线程的ID写入这个指针指向的内存中</li>
<li>attr——创建线程的属性</li>
<li>start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数</li>
<li>arg——无类型指针参数，作为线程执行函数的参数传入</li>
</ul>


<h1>线程终止</h1>

<ul>
<li><p>进程终止会导致线程终止：</p>

<ul>
<li>任一线程调用了exit，<em>Exit或</em>exit函数，整个进程终止</li>
<li>若信号的默认动作是终止进程，则把信号发送到线程会终止进程</li>
</ul>
</li>
<li><p>单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。</p>

<ul>
<li>线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）</li>
<li>线程可以被同一进程中的其它线程取消（pthread_cancel）</li>
<li>线程调用pthread_exit函数退出</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>void pthread_exit(void *retval);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_exit接收的参数，就是线程的返回值。</p>

<p>其它线程可以通过pthread_join获取这个值。</p>

<p>注意：</p>

<blockquote><p>pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。</p></blockquote>

<h2>pthread_join函数</h2>

<p>pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;pthread.h&gt;
</span><span class='line'>int pthread_join(pthread_t thread, void **retval); // 成功，返回0
</span></code></pre></td></tr></table></div></figure>


<p>如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。</p>

<p>注意：</p>

<blockquote><p>如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。</p></blockquote>

<p>如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程</p>

<p>还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &amp;status, options)); 等待任意进程，线程没有这个操作。</p>

<h2>pthread_detach函数</h2>

<p>默认情况下，线程是可<em>结合的（joinable）</em>，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。</p>

<p>某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是<em>分离的（detached）</em>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>int pthread_detach(pthread_t thread);
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。</p>

<h1>线程参数传递和返回值</h1>

<p>在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。</p>

<ul>
<li>在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数</li>
<li>当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：

<blockquote><ul>
<li>在线程执行函数返回一个指针</li>
<li>调用pthread_exit()，把返回值指针作为pthread_exit的参数</li>
</ul>
</blockquote></li>
</ul>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>/*  our macro for errors checking                                           */
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>#define COND_CHECK(func, cond, retv, errv) \
</span><span class='line'>if ( (cond) ) \
</span><span class='line'> { \
</span><span class='line'>    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
</span><span class='line'>                __FILE__,__LINE__,func,retv,strerror(errv)); \
</span><span class='line'>                   exit(EXIT_FAILURE); \
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'>#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
</span><span class='line'>#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>void *th_func1(void *arg);
</span><span class='line'>void *th_func2(void *arg);
</span><span class='line'>void test_thread_ret();
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  test_thread_ret();
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void test_thread_ret()
</span><span class='line'>{
</span><span class='line'>  int t_ret;
</span><span class='line'>  // pthread ret
</span><span class='line'>  pthread_t t1, t2;
</span><span class='line'>  void *tret;
</span><span class='line'>  t_ret = pthread_create(&t1, NULL, th_func1, NULL);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>  t_ret = pthread_create(&t2, NULL, th_func2, (void *)2);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>
</span><span class='line'>  printf("join t1\n");
</span><span class='line'>  t_ret = pthread_join(t1, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 1 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>  printf("join t2\n");
</span><span class='line'>  t_ret = pthread_join(t2, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 2 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>void *th_func1(void *arg)
</span><span class='line'>{
</span><span class='line'>  printf("thread 1 runing\n");
</span><span class='line'>  return (void *)1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void *th_func2(void *arg)
</span><span class='line'>{
</span><span class='line'>  int * a;
</span><span class='line'>  a = (int *)arg;
</span><span class='line'>  printf("thread 2 arg is %d.\n", (int) a);
</span><span class='line'>  pthread_exit((void *) 2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>取消线程</h1>

<p>线程可以调用pthread_cancel函数<em>请求</em>取消同一进程中的其它线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_cancel(pthread_t tid);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cancel并不等待线程终止仅仅提出请求。</p>

<p>线程在取消请求发出后还继续运行，直到线程打到某个<em>取消点</em>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>

<h1>线程同步</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(信号)]]></title>
    <link href="http://baren.github.io/blog/2014/06/24/signal/"/>
    <updated>2014-06-24T20:00:20+08:00</updated>
    <id>http://baren.github.io/blog/2014/06/24/signal</id>
    <content type="html"><![CDATA[<h1>信号概念</h1>

<p>信号是软中断，提供了一种处理异步事件的方法</p>

<p>关于信号：</p>

<ul>
<li>每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中</li>
<li>产生信号的条件

<blockquote><ul>
<li>用户按终端键，印发终端产生信号</li>
<li>硬件异常产生信号，比如无效的内存引用，除数为0等</li>
<li>进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）</li>
<li>用户用kill命令给进程发送信号</li>
<li>当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。</li>
</ul>
</blockquote></li>
</ul>


<!-- more -->


<p>几种处理信号的方式</p>

<ul>
<li>忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的</li>
<li>捕捉信号——需要注册一个信号处理函数</li>
<li>执行默认操作——大多数的信号的默认动作是终止信号</li>
</ul>


<h1>signal函数</h1>

<p>unix系统提供了两个改变信号处理的方式：signal和signalaction函数</p>

<p>现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void (*signal(int sig, void (*func)(int)))(int)
</span><span class='line'>// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
</span><span class='line'>// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址</span></code></pre></td></tr></table></div></figure>


<p>signal函数太复杂，可以使用typedef类型定义简化一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void Sigfunc(int);
</span><span class='line'>
</span><span class='line'>Sigfunc *signal(int Sigfunc *func);
</span></code></pre></td></tr></table></div></figure>


<p>一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
</span><span class='line'>#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
</span><span class='line'>#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针
</span></code></pre></td></tr></table></div></figure>


<p>可以使用这几个预定义函数常量，来判断信号捕获程序。</p>

<p>关于信号处理程序，注意点：</p>

<ul>
<li>只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误</li>
<li>SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31</li>
<li>kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的</li>
</ul>


<h1>中断的系统调用</h1>

<h2>中断低速系统调用</h2>

<p>若进程调用了一个低速的系统调用，</p>

<p>并且这个系统调用正在阻塞</p>

<p>此时，</p>

<p>捕捉到一个信号。</p>

<p>结果是：该系统调用就被中断不被执行了。</p>

<p><em>注意</em>：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用</p>

<p>低速系统调用是可能是进程阻塞的系统调用，一般包括</p>

<ul>
<li>读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞</li>
<li>打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）</li>
<li>pause和wait，pause会使调用进程一直休眠，指导捕获一个信号</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数</li>
</ul>


<p>这个需要注意的是，磁盘IO操作并不是低速系统调用。</p>

<h2>低速系统调用被中断后的处理和重启</h2>

<p>一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。</p>

<p>这样我们就能够处理这种失败。有两种处理方式：</p>

<ul>
<li>系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作</li>
<li>某些中断的系统调用支持自动重启动</li>
</ul>


<h3>手动检查</h3>

<p>比如可以这样处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
</span><span class='line'>  continue;  // 啥也不做
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<p>如果经常使用这种检查，还可以定义一个宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NO_EINTR(stmt)   while((stmt) == -1 && errno == EINTR);
</span><span class='line'>
</span><span class='line'>// 然后
</span><span class='line'>
</span><span class='line'>NO_EINTR(cnt == read(fd, buf, BUF_SIZE));
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<h3>自动重启动</h3>

<p>为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wait waitpid read write ioctl readv writev
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。</p>

<h1>可重入函数</h1>

<p>在信号处理程序中，不能调用不可重入函数。</p>

<p>所谓不可重入函数是指：</p>

<ol>
<li>它们使用了静态数据结构或全局变量</li>
<li>调用malloc和free，因为malloc维护了一个全局链表</li>
<li>标准IO函数</li>
</ol>


<p>而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数</p>

<p>在标准C函数库中，不可重入函数比较普遍。</p>

<p>比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。</p>

<h1>可靠信号的术语和语义</h1>

<ul>
<li>递送（delivery）信号：当引发信号的事件<em>发生</em>时，为进程产生一个信号（或向进程产生一个信号）</li>
<li>未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的</li>
</ul>


<p>进程可以设置阻塞信号。</p>

<p>若信号被进程设置为阻塞，并且对该信号的动作是系统<strong>默认动作</strong>或<strong>捕捉该信号</strong>，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。</p>

<p>解除未决状态：
    * 对信号解除了阻塞
    * 或者将此信号的动作改为忽略。</p>

<p>注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>void sig_int(int sig);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t osig;
</span><span class='line'>  sigset_t newsig, o_set;
</span><span class='line'>
</span><span class='line'>  sigemptyset(&newsig);
</span><span class='line'>  sigaddset(&newsig, SIGINT);
</span><span class='line'>  // if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
</span><span class='line'>  if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  //pause();
</span><span class='line'>  sleep(4);
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_int) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf(" pause ...\n");
</span><span class='line'>  sigprocmask(0, NULL, &o_set);
</span><span class='line'>  if (sigismember(&o_set, SIGINT))
</span><span class='line'>  {
</span><span class='line'>      printf("is mask\n");
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>void sig_int(int sig)
</span><span class='line'>{
</span><span class='line'>  printf("int sig hand\n");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>执行结果是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果是默认处理，在sleep过程中，产生中断信号，结果是：
</span><span class='line'>$ ./test_pend
</span><span class='line'>^Cint sig hand
</span><span class='line'> pause ...
</span><span class='line'>
</span><span class='line'> 如果改成忽略，在sleep过程中，产生中断信号，结果是：
</span><span class='line'> ./test_pend
</span><span class='line'>^C pause ...</span></code></pre></td></tr></table></div></figure>


<p>注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。</p>

<h1>kill和raise函数</h1>

<p>kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int kill(pid_t pid, int signo);
</span><span class='line'>int raise(int signo);</span></code></pre></td></tr></table></div></figure>


<p>下面是等价的：</p>

<p>raise(signo) == kill(getpid(), signo)</p>

<p>kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid &lt; 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。</p>

<p>上面提到了，给其它进程发信号需要权限，具体是指：</p>

<ul>
<li>超级用户可以将信号发送给任一进程</li>
<li>非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID</li>
</ul>


<p>注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH</p>

<h1>alarm和pause函数</h1>

<p>alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>unsigned int alarm(unsigned int seconds);</span></code></pre></td></tr></table></div></figure>


<p>对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的</p>

<p>pause函数使调用进程挂起直到捕捉到一个信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int pause(void)</span></code></pre></td></tr></table></div></figure>


<p>条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR</p>

<h2>使用alarm实现sleep函数，并暴露问题</h2>

<p>使用信号时，需要精细而周到的考虑，下面代码列出几个问题：</p>

<ul>
<li>问题1：竞争条件</li>
</ul>


<p>看下面的sleep1的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int sleep1(unsigned int nsecs)
</span><span class='line'>{
</span><span class='line'>  if(signal(SIGABRT, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("can't signal alarm!\n");
</span><span class='line'>      return nsecs;
</span><span class='line'>  }
</span><span class='line'>  alarm(nsecs);
</span><span class='line'>  pause();
</span><span class='line'>  return (alarm(0)); // 返回未完成的时间
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  ;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。</p>

<ul>
<li>问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序</li>
</ul>


<p>使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。</p>

<p>第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>static jmp_buf env_alrm;
</span><span class='line'>int sleep2(int);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sleep2(2);
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int sleep2(int sec)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sigalarm err!\n");
</span><span class='line'>      return sec;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alrm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(sec);
</span><span class='line'>      pause();
</span><span class='line'>  }
</span><span class='line'>  return (alarm(0));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  longjmp(env_alrm, 1);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。</p>

<h2>除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限</h2>

<p>下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout);
</span><span class='line'>
</span><span class='line'>static jmp_buf env_alarm;
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char line[100];
</span><span class='line'>  int n;
</span><span class='line'>  n = read_timeout(STDIN_FILENO, line, 100, 3);
</span><span class='line'>  if(n &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("read timeout\n");
</span><span class='line'>  } else {
</span><span class='line'>      printf("read len %d.\n", n);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout)
</span><span class='line'>{
</span><span class='line'>  int n = 0;
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig alarm err\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alarm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(timeout);
</span><span class='line'>      if((n=read(fd, buf, size)) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("read err!\n");
</span><span class='line'>          return n;
</span><span class='line'>      }
</span><span class='line'>      alarm(0);
</span><span class='line'>      return n;
</span><span class='line'>  }
</span><span class='line'>  return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>      longjmp(env_alarm, 1);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>read timeout
</span><span class='line'>user@usertekiMacBook-Pro unix_test$
</span><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>dd
</span><span class='line'>read len 3.</span></code></pre></td></tr></table></div></figure>


<p>注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。</p>

<h1>信号集</h1>

<p>可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigempty(sigset_t *set);
</span><span class='line'>int sigfillset(sigset_t *set);
</span><span class='line'>int sigaddset(sigset_t *set, int signo);
</span><span class='line'>int sigdelset(sigset_t *set, int signo);
</span><span class='line'>  // 四个函数返回值：成功，返回0，失败返回-1
</span><span class='line'>int sigismember(const sigset_t *set, int signo);
</span><span class='line'>  // 若真，返回1，假，返回0，出错，返回-1
</span></code></pre></td></tr></table></div></figure>


<h1>sigpromask函数</h1>

<p>调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>oset非空，则进程当前信号屏蔽字通过oset返回</li>
<li>set非空，则根据第一个参数how指示如何修改当前信号屏蔽字</li>
<li>set为空，不改变</li>
</ul>


<p>how的值：</p>

<ul>
<li>SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集</li>
<li>SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集</li>
<li>SIT_SETMASK: 被set指向的值替代</li>
</ul>


<h1>sigpending函数</h1>

<p>sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigpending(sigset_t *set);</span></code></pre></td></tr></table></div></figure>


<p>注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_quit(int);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t oldset, newset, quitset;
</span><span class='line'>  sigemptyset(&quitset);
</span><span class='line'>  sigaddset(&quitset, SIGINT);
</span><span class='line'>
</span><span class='line'>  // ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  } 
</span><span class='line'>  // ************
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_BLOCK, &quitset, &oldset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  // sleep 5 seconds
</span><span class='line'>  sleep(5);
</span><span class='line'>  if (sigpending(&newset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("pending err \n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if (sigismember(&newset, SIGINT))
</span><span class='line'>      printf("sigquit is block\n");
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &oldset, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask ret sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  printf("sig int unblock\n");
</span><span class='line'>  sleep(5);
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_quit(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("sigquit catch\n");
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>sigaction函数</h1>

<p>sigaction函数的功能是<em>检查</em>或<em>修改</em>与指定信号相关联的处理动作（或同时执行）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
</span><span class='line'>// 成功，返回0，出错返回-1
</span></code></pre></td></tr></table></div></figure>


<p>对于参数：</p>

<ul>
<li>signo是信号</li>
<li>act非空，则修改信号动作</li>
<li>oact非空，则由oact返回上一个动作</li>
</ul>


<p>结构体struct sigaction的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct sigaction {
</span><span class='line'>  void (*sa_handler)(int); // 信号处理函数的地址，或者SIG_IGN或SIG_DFL
</span><span class='line'>  sigset_t sa_mask; // 额外需要阻塞的信号集
</span><span class='line'>  int sa_flags;  // 信号选项，可以设置这个选项来控制处理函数行为
</span><span class='line'>
</span><span class='line'>  /*替换的处理程序，当指定sa_flags为SA_SIGINFO时，采用这个处理函数，提供了额外的一些信息*/
</span><span class='line'>  void (*sa_sigaction)(int, siginfo_t *, void *);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>若更改信号处理函数，则：
* sa_handler指定处理函数的地址
* sa_mask则是信号集，在调用该信号处理函数之前，会先把这个信号集指定的信号加到进程的信号屏蔽字中。信号处理函数返回时，再复原。在信号处理程序被调用时，操作系统建立的新信号屏蔽字也包括正在被递送的信号，这会保证在当前信号处理时，这个信号再次发生，会一直阻塞，直到处理函数完成。
* sa_flags字段指定对信号处理的各个选项:</p>

<blockquote><ul>
<li>SA_RESTART:由此信号中断的系统调用自动重新启动</li>
<li>SA_INTERRUPT: 由此信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 有此选项对信号，会调用sa_sigaction函数，此函数会给额外提供了附加信息：1）指向siginfo结构的指针；2）指向进程上下文标识符的指针</li>
</ul>
</blockquote>

<p>注意：</p>

<blockquote><p>除了那些为了兼容而继续保留原始的signal函数的语义的系统外，大部分系统都是用sigaction来实现signal函数的。</p></blockquote>

<h1>sigsetjmp和siglongjmp函数</h1>

<p>在捕捉到一个信号时，会进入信号捕捉函数，此时会发生：</p>

<ul>
<li>进入信号处理函数时，当前信号会被自动加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序</li>
<li>当正常从信号处理函数中返回时，会自动恢复当前信号为非屏蔽</li>
</ul>


<p>但是，当在信号处理函数内，调用了longjmp函数，那么是否恢复这个被屏蔽的当前信号？</p>

<p>FreeBSD 5.2.1 和Mac OS X10.3中，setjmp和longjmp保持和恢复信号屏蔽字</p>

<p>Linux2.4.22和Solaris9 并不执行这种操作。FreeBSD 5.2.1 和Mac OS X10.3提供函数<em>setjmp和</em>longjmp，他们不保存和恢复信号屏蔽字</p>

<p>为了允许两种形式的行为存在， POSIX.1并没有说明setjmp和longjmp对屏蔽字的作用，而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部跳转是，使用这两个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt; // 与setjmp和longjmp一个头
</span><span class='line'>
</span><span class='line'>int sigsetjmp(sigjmp_buf env, int savemask); // 直接调用，返回0，若从siglongjmp调用返回，则返回非0值
</span><span class='line'>
</span><span class='line'>void siglongjmp(sigjmp_buf env, int val);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>若savemask非零，则env保存进程的当前屏蔽字。并在siglongjmp调用时，恢复由env保存进程的当前屏蔽字。</p>

<p>涉及到信号时，使用sigsetjmp和siglongjmp的典型使用模板是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static sigjmp_buf;
</span><span class='line'>static volatile sig_atomic_t canjump;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>// 在主函数中
</span><span class='line'>if (sigsetjmp(jmpbuf, 1)) {
</span><span class='line'>  ....
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>canjump = 1; // 调用sigsetjmp后才设置canjump为非零
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 然后，在信号处理程序中，这样：
</span><span class='line'>void sig_handler(int) {}
</span><span class='line'>
</span><span class='line'>if (canjmp == 0) // 只有非零时，才调用siglongjmp
</span><span class='line'>  return
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>siglongjmp(jmpbuf, 1);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<blockquote><p>原因：
之所以使用canjump，主要是保护机制，防止当jmpbuf还没有被sigsetjmp初始化时，就调用了信号处理程序。
在非信号环境下没有问题，但在信号环境下，信号是随时发生的，因此需要保护</p></blockquote>

<h1>sigsuspend函数</h1>

<p>屏蔽进程的信号，使用这种技术，可以保护不希望由信号中断的代码临界区。然后在临界区之后等待以前的信号发生。</p>

<p>但是下面的实现方式有问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sigprocmask(SIG_BLOCK, &newmask, &oldmask);
</span><span class='line'>
</span><span class='line'>// .....临界区代码
</span><span class='line'>
</span><span class='line'>1) sigprocmask(SIG_BLOCK, &oldmask, NULL);
</span><span class='line'>2) pause(); // 等待之前阻塞的信号发生
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，1）和2）代码出有问题，会有竞争条件，在sigprocmask和pause之间有可能信号会发生，这会导致pause无法返回，永远阻塞。</p>

<p>解决这个竞争条件的办法就是让这两个操作合并成一个原子操作。这就是sigsuspend函数的由来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigsuspend(const sigset_t * sigmask);
</span></code></pre></td></tr></table></div></figure>


<p>用sigsuspend实现临界区代码，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_int(int signo);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  sigset_t newsigset, oldsigset, waitsigset;
</span><span class='line'>  sigemptyset(&newsigset);
</span><span class='line'>  sigaddset(&waitsigset, SIGUSR1);
</span><span class='line'>  struct sigaction act;
</span><span class='line'>  act.sa_handler = sig_int;
</span><span class='line'>
</span><span class='line'>  if(sigaction(SIGINT, &act, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("siganction err.\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(sigprocmask(SIG_BLOCK, &newsigset, &oldsigset) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  // code procted
</span><span class='line'>  printf("this is procted code!\n");
</span><span class='line'>
</span><span class='line'>  if(sigsuspend(&waitsigset) != -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigsuspend err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf("after sigsuspend\n");
</span><span class='line'>  if(sigprocmask(SIG_SETMASK, &oldsigset, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("revert old sig mask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_int(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("catch signo %d\n", signo);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sigsuspend函数实现的巧妙之处：</p>

<ul>
<li>为了实现解除屏蔽（sigprocmask）和等待（pause），sigsuspend把进程的屏蔽信号设置为参数信号，并在返回后设置为调用sigsuspend之前的屏蔽信号值。</li>
</ul>


<p>sigsuspend函数还有两种经典应用：</p>

<ol>
<li>等待一个信号处理程序设置一个全局变量</li>
<li>父子进程实现同步</li>
</ol>


<p>注意：在实现父子进程通讯，可以使用kill给对象发信号，并使用sigsuspend等待某种条件</p>

<h1>abort函数</h1>

<p>abort函数使异常程序终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void abort(void);
</span></code></pre></td></tr></table></div></figure>


<p>这个函数将SIGABRT信号发送给调用进程。</p>

<p>ISO C规定 abort的实现须向主机环境递送一个成功的通知，一般是通过raise(SITABRT)或kill(gitpid(), SIGABRT)实现，这个规定，允许程序做清理工作。</p>

<p>一般系统的abort实现，都会冲洗输出流以及是否要删除临时文件。</p>

<p>可以看一下abort的函数实现示例，通过这个示例，学会：</p>

<ul>
<li>sigaction函数的使用</li>
<li>kill函数的使用：kill函数可以给其它进程发送信号。若发给本进程，并且此信号是不被阻塞的，那么kill返回之前，该信号（或某个未决、未阻塞的信号）就被传送给了该进程。这样，kill返回了，就知道该进程一定捕捉到该信号。</li>
</ul>


<h1>system函数</h1>

<p>ISO C定义了system函数，这个函数可以执行系统命令，这个函数的实现也牵扯到信号问题。若不处理，会有问题。</p>

<p>这里通过system的实现，注意信号程序开发的各种问题。</p>

<p>看下面调用过程：
<img src="http://baren.github.io/images/assets/Figure10-1.png" title="time-function" alt="alt text" /></p>

<p>若没有处理信号，问题有：</p>

<ul>
<li>若进程（a.out）捕获SIGCHID信号，当system创建的子进程结束，系统会向父进程（a.out）发送SIGCHID信号，父进程会捕捉。<em>但这阻止了system函数获取它自己创建子进程的状态</em></li>
<li>若system系统没有屏蔽中断和退出信号，则如果想给shell调用程序发送中断信号时，系统会同时向负责进程发送信号（因为都属于前台进程组）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程关系)]]></title>
    <link href="http://baren.github.io/blog/2014/05/04/process-relate/"/>
    <updated>2014-05-04T20:00:26+08:00</updated>
    <id>http://baren.github.io/blog/2014/05/04/process-relate</id>
    <content type="html"><![CDATA[<h1>终端登录</h1>

<p>由终端登录至unix，这个过程是类似的，而与所使用的终端无关，终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端，或者是运行窗口系统的图形终端。</p>

<p>终端登录步骤：</p>

<ol>
<li>系统自举时，创建进程ID为1的init进程。使系统进入多用户状态。</li>
<li>init进程读取文件/etc/ttys，对每一个允许登录的终端设备，init进程调用一次fork，fork后的子进程执行getty程序（exec getty程序）</li>
<li>getty程序会调用open函数，以读写方式打开终端，一旦打开设备，则文件描述符0、1、2设置到该设备，输出login:之类的信息</li>
<li>gettty调用login函数（<code>execle("/bin/login", "login", "-p", username, (char *) 0, envp);</code>）</li>
<li>login执行多个工作

<blockquote><p>验证用户、密码正确性，连续几次不对，则退出；父进程init知道子进程终止后，会再次调用fork，执行getty，重复上述动作。登录成功后：
将当前工作目录改为该用户的起始目录（home目录）
chown改变该终端的所有权，使登录用户成为它的所有者
对该终端设备的访问权限改为用户读写
调用setgid及initgroups设置进程的组id
用login所得到的所有信息初始化环境
调用该登录用户的登录shell</p></blockquote></li>
</ol>


<!-- more -->


<h1>网络登录</h1>

<p>在网络登录情况下，所有的登录都是通过内核的网络接口驱动程序（以太网驱动程序），事情并不知道会有多少这样的登录。必须等待一个网络连接请求的到达。</p>

<p>网络登录，一个特点是：1）既能处理终端登录；2）处理网络登录。为了实现，系统采用<em>伪终端</em>（pseudo terminal）的软件驱动程序。</p>

<p>伪终端仿真：</p>

<ul>
<li>串行终端的运行行为，</li>
<li>并将终端操作映射为网络操作，反之亦然</li>
</ul>


<h2>BSD网络登录</h2>

<p>在BSD中，inetd进程负责等待大多数的网络连接。</p>

<p>启动inetd进程的步骤：</p>

<ol>
<li>init进程调用shell，使shell程序执行/etc/rc脚本，</li>
<li>这个脚本启动守护进程inetd，然后shell脚本结束，inetd的父进程变成init。</li>
<li>inetd进程等待TCP/IP连接，当一个连接请求到达时，执行一次fork，生成子进程执行适当的程序。</li>
</ol>


<p>以telnet网络登录为例。</p>

<p>hostname启动的程序被称为telnet服务进程（称为telnetd）。</p>

<p>客户端进行网络登录命令：telnet hostname，这样客户端和hostname以telnet应用协议通过tcp连接交换数据。</p>

<p>然后，</p>

<p>服务端telnetd打开一个伪终端设备，并用fork分成两个进程。</p>

<ul>
<li>父进程处理网络连接的通信</li>
<li>子进程执行login程序</li>
<li>父子进程通过伪终端程序相连接</li>
</ul>


<p>login登录成功，则进行上一节同样的步骤：更改当前工作目录为起始目录，设置登录用户的组ID合用户ID，以及登录用户的初始环境。
然后login调用exec将其自身替换为登录用户的登录shell。</p>

<p>注意：
linux的因特网守护进程是xinetd。</p>

<h1>进程组</h1>

<p>进程组是一个或多个进程的集合。一般进程组与同一个作业相关联（比如shell中，多个命令用管道合起来，这几个命令分别是一个进程，合起来组成一个进程组）。可以接收同一终端的各种信号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>// 返回调用进程的进程组id
</span><span class='line'>pid_t getpgrp(void);
</span></code></pre></td></tr></table></div></figure>


<p>Sigle UNIX Specification将getpgid函数定义为XSI扩展，模仿了此种运行行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t getpgid(pid_t pid);
</span></code></pre></td></tr></table></div></figure>


<p>若参数pid为0，则返回调用进程的进程组id，这时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getpgid(0) == getpgrp()</span></code></pre></td></tr></table></div></figure>


<p>进程组可以有一个组长进程。条件是：</p>

<ul>
<li>组长进程的ID等于组的ID</li>
</ul>


<p>组长进程的权限：</p>

<ul>
<li>创建一个进程组</li>
<li>创建该组中的进程</li>
</ul>


<p>进程组中，只要有一个进程存在，进程组就存在，这与组长进程的存在与否无关。</p>

<p>进程组的生存期是：进程组创建到最后一个进程终止，最后一个进程可以终止，也可以转移到另一个进程组。</p>

<p>加入一个进程组或者创建进程组：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int setpgid(pid_t pid, pid_t pgid);
</span></code></pre></td></tr></table></div></figure>


<p>setpgid函数将pid进程的进程组ID设置为pgid。</p>

<ul>
<li>如果这两个参数相等，则由pid指定的进程变成进程组组长，</li>
<li>如果pid是0，则使用调用者的进程ID。</li>
<li>如果pgid为0，则由pid指定的进程ID将用作进程组ID</li>
</ul>


<p>调用条件：</p>

<ul>
<li>一个进程只能为它自己或者它的子进程设置进程组ID，</li>
<li>在它的子进程调用了exec函数之一后，它就不能再改变该子进程的进程组ID</li>
</ul>


<p>在大多数的作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并使子进程设置其自己的进程组ID。</p>

<h1>会话</h1>

<p>会话是一个或多个进程组的集合。</p>

<p>例如下面程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>proc1  | proc2 &
</span><span class='line'>proc3 | proc 4 | proc5
</span></code></pre></td></tr></table></div></figure>


<p>会产生如下会话，包括三个进程组：
1. 登录shell
2. proc1和proc2属于一个进程组
3. proc3和proc4和proc5属于一个进程组</p>

<p>可以使用setsid函数建立新会话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>pid_t setsid(void);
</span></code></pre></td></tr></table></div></figure>


<p>如果调用这个函数的进程不是一个进程组的组长，则此函数就会创建一个新会话，结果将发生下面三件事：</p>

<ol>
<li>该进程会变成新会话的首进程（session leader）（会话首进程是创建该会话的进程），此时该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程，新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也会中断。</li>
</ol>


<p>如果该进程已经是一个进程组的组长，则函数返回出错。为了防止这种情况，一般先fork再调用。</p>

<h1>控制终端</h1>

<ul>
<li>一个会话可以有一个控制终端，通常是登录到其上的终端设备或者伪终端设备。</li>
<li>建立与控制终端的会话首进程被称为控制进程</li>
<li>一个会话中得几个进程组可被分成<em>一个</em>前台进程组以及一个或者多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，会话中的其它进程组为后台进程组</li>
<li>无论何时键入终端的中断键（ctrl+c），就会将中断信号发送给前台进程组的所有进程</li>
<li>无论何时键入终端的退出键（ctrl+\），将会将退出信号发送给前台进程组中所有进程</li>
<li>如果终端接口检测到调制解释器或网络已经断开连接，则将挂断信号发送给控制进程（会话首进程）</li>
</ul>


<h1>作业控制</h1>

<p>略</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程控制)]]></title>
    <link href="http://baren.github.io/blog/2014/05/04/process-control/"/>
    <updated>2014-05-04T20:00:02+08:00</updated>
    <id>http://baren.github.io/blog/2014/05/04/process-control</id>
    <content type="html"><![CDATA[<h1>进程标识符</h1>

<p>进程都有一个非负整数代表唯一的进程ID。</p>

<p>当进程终止后，进程ID可以重用，为了防止将新进程视为使用同一个进程ID的旧的进程，系统采用了<em>延迟重用</em>算法来重用进程ID。</p>

<p>系统启动后有一些专用进程：</p>

<ul>
<li>ID为0的进程——调度进程，也称为交换进程（swapper），这个进程是内核的一部分，不执行磁盘上的程序，被称为系统进程。</li>
<li>ID为1的进程——init进程，自举结束时由内核调用；早期的进程文件是/etc/init，现在都是/sbin/init。init通常读取系统的配置文件来初始化系统（/etc/rc*或/etc/initab, /etc/init.d）。init进程不会终止，虽然是普通进程，但是以超级用户权限运行，还接收孤儿进程，是所有孤儿进程（子进程还活着，父进程终止了，称为孤儿进程）父进程。</li>
</ul>


<p>下面函数返回与进程相关的其他标识符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t getpid(void);
</span><span class='line'>
</span><span class='line'>pid_t getppid(void);
</span><span class='line'>
</span><span class='line'>uid_t getuid(void);  // 实际用户id
</span><span class='line'>
</span><span class='line'>uid_t geteuid(void);  // 有效用户id
</span><span class='line'>
</span><span class='line'>gid_t getgid(void);  // 实际组id
</span><span class='line'>
</span><span class='line'>gid_t getegid(void);  // 有效组id
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h1>fork函数</h1>

<p>可以调用<code>fork</code>函数创建一个新进程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t fork(void);
</span></code></pre></td></tr></table></div></figure>


<p>fork创建的新进程被称为子进程。fork调用一次返回两次：</p>

<ul>
<li>子进程返回0.</li>
<li>父进程返回子进程的ID，如果返回-1，表示创建进程出错</li>
</ul>


<p>返回后，父进程和子进程继续执行调用fork之后的指令。</p>

<p>fork后，子进程是父进程的副本。比如子进程获得父进程的数据空间，堆和栈的副本。父子进程不共享这些，只是共享正文段。</p>

<p>一般fork后都执行exec函数，因此现在的系统在fork的实现上，并不立即完全复制父进程的数据段、堆栈的完全复制，而是采用copy-on-write的技术，只有在父或子进程写的时候才进行复制，复制也是仅仅复制写的那块区域，一般就是存储系统中的一页。</p>

<p>在fork后，是先返回父进程还是子进程，是不确定的，取决于系统的调度算法的实现。</p>

<p>如果fork后没有调用exec，子进程与父进程执行同一代码，则需要注意调用fork之前的IO流缓冲问题。</p>

<ul>
<li>如果之前有IO流缓冲，则可能会被子进程和父进程各调用一次，伪代码：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>printf("。。。");  // 如果标准输出被重定向到一个文件，则是全缓冲的。
</span><span class='line'>
</span><span class='line'>pid = fork()
</span><span class='line'>if(pid == 0){
</span><span class='line'>  exit()
</span><span class='line'>} else if (pid == -1) {
</span><span class='line'>  printf('error')
</span><span class='line'>} else {
</span><span class='line'>  exit()
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，如果printf的标准输出重定向到文件，则是全缓冲的，因此调用printf的时候，有可能把数据存放到缓冲中。</p>

<p>这样，fork后，父子进程各有一个缓冲，因此exit后，printf各被flush，因此父子进程都会打印printf的输出。</p>

<blockquote><p>注意：
strlen() 和sizeof()的区别。strlen是返回不包含null终止符的字符串的长度。sizeof返回包含null终止符的缓冲区的大小。
strlen() 是一次函数调用。而sizeof在编译时期就知道大小。</p></blockquote>

<h2>文件共享</h2>

<p>fork的一个特征是文件进程所有打开文件的描述符都被复制到子进程。</p>

<p>这样父子进程每个相同的打开描述符共享一个文件表项（内核为每个打开的文件维持文件表，若两个进程打开同一个文件，每个进程都有自己的文件表项。但是fork后，两个进程就会共享同一个文件表项，也就是共享偏移量。）</p>

<p>如图：</p>

<p>如果两个进程打开同一个文件，每个进程都有自己的文件偏移量：
<img src="http://baren.github.io/images/assets/Figure8-1.png" title="time-function" alt="alt text" /></p>

<p>如果fork后，父进程和子进程则共享一个文件表项，共享文件偏移量：
<img src="http://baren.github.io/images/assets/Figure8-2.png" title="time-function" alt="alt text" /></p>

<p>fork后处理文件描述符的两种情况：</p>

<ol>
<li>父进程等子进程完成，在这种情况下，父进程无需对描述符进行任何处理，当子进程结束后，父进程的偏移量也已经被更新。</li>
<li>父子进程各自执行不同的程序段，fork，父子进程各自关闭不需要的文件描述符，这样不会干扰对方使用的文件描述符。网络服务进程常用这种方式。</li>
</ol>


<p>除了文件，许多其它属性也被子进程继承：</p>

<ul>
<li>实际用户（组）ID，有效用户（组）ID</li>
<li>会话ID</li>
<li>环境</li>
</ul>


<p>注意：
 父进程的文件锁不会被继承</p>

<p> fork的两种用法：</p>

<ol>
<li>父进程希望复制自己，是父子进程执行不同的代码段（比如网络服务）</li>
<li>子进程执行一个不同的程序，比如shell</li>
</ol>


<h1>vfork函数</h1>

<p>vfork的目的是创建一个新进程，而该进程的目的是exec一个新进程。</p>

<p>vfork与fork调用相同，有两点不同：</p>

<ul>
<li>vfork不会复制父进程的地址空间，在子进程调用exec或exit之前，子进程在父进程的地址空间中执行（意味着会修改父进程的变量等）</li>
<li>vfork函数保证子进程先执行，在它调用exec或exit之后，父进程才被调度运行</li>
</ul>


<h1>exit函数</h1>

<p>5种正常终止进程的方式：</p>

<ul>
<li>main函数中return返回，等效于调用exit函数</li>
<li>调用exit函数。ISO C定义的函数，操作包括1）调用终止处理程序（atexit注册的函数）；2）关闭所有标准IO流描述符</li>
<li>调用<em>exit或</em>Exit函数。ISO C定义_Exit函数。这两个函数的目的是提供一种无需运行终止处理程序（atexit注册的函数）或信号处理程序而终止的方法；这两个函数一般都不对标准IO流进行冲洗。</li>
<li>进程最后一个线程在启动例程中执行返回语句，进程终止状态为0</li>
<li>进程最后一个线程调用pthread_exit函数，进程终止状态为0</li>
</ul>


<p>3种异常终止程序：</p>

<ul>
<li>调用abort</li>
<li>进程收到某些信号，这个信号可以由其它进程、自己或内核发起。</li>
<li>最后一个线程对“取消”做出响应。</li>
</ul>


<blockquote><p>注意：
不管是正常终止或者是异常终止，内核都会在进程结束后执行一段代码，工作是：
1. 关闭打开的描述符
2. 释放使用的存储器</p></blockquote>

<h2>子进程如何通知父进程它的终止状态</h2>

<ol>
<li>对于三个终止函数（exit, <em>exit, </em>Exit）退出的进程，若通知父进程其退出状态，需要把状态作为参数传递给这三个函数。其它两种正常退出，终止状态为0.</li>
<li>异常终止，内核产生一个指示其异常终止原因的终止状态。</li>
</ol>


<blockquote><p>注意：
不管哪种情况，父进程都可以通过wait和waitpit函数获取其终止状态。</p></blockquote>

<h2>进程领养与僵死进程</h2>

<p>父子进行结束的两种情况：</p>

<ol>
<li>父进程先于子进程终止。</li>
</ol>


<p>对于父进程已经终止的子进程，其父进程改变为init进程（ID为1）。每当一个进程终止时，内核会挨个检查所有活动的进程，判断是否是已终止进程的子进程。是，则将其父进程修改为init进程。</p>

<p>这个步骤称为<em>进程的领养</em>。</p>

<ol>
<li>子进程先于父进程终止。</li>
</ol>


<p>为了让父进程获取其子进程的终止状态，内核为每个终止的子进程保存了一定量的信息。因此当父进程调用wait或waitpid函数时，可以获取子进程的终止状态。</p>

<p>内核为终止的子进程保存的信息有：</p>

<ul>
<li>进程ID</li>
<li>终止状态</li>
<li>进程使用CPU时间总量</li>
</ul>


<blockquote><p>注意：
由于进程终止时，内核释放了其占用的存储空间和关闭了打开的文件描述符，引起，进程占用的大部分资源都已经释放掉了。</p></blockquote>

<p><em>僵死进程（zombie）</em> ：一个已终止，而父进程没有终止，并且父进程还没有对其进行善后处理（获取子进程的终止信息，也就是还没有经过wait调用）的进程，被称为僵死进程，状态为Z。</p>

<blockquote><p>注意：
由init进程领养的子进程终止时，不会称为僵死进程。因为init的实现，只要有子进程终止，就会调用wait函数获取其终止状态。</p></blockquote>

<h1>父进程获取子进程终止状态（wait和waitpid函数）</h1>

<p>当进程的子进程终止时，内核会立即向其父进程发送SIGCHLD信号。因此父进程可以提供一个信号处理程序处理这个信号。</p>

<p>对于这个信号，父进程可以有两种处理方式：</p>

<ul>
<li>编写一个处理这个信号的处理程序（然后调用wait函数获取其终止子进程的终止状态）</li>
<li>忽略掉（系统默认）</li>
</ul>


<p>除了信号方式外，若父进程在程序内调用wait或者waitpid函数，则可能会发生以下：</p>

<ul>
<li>若所有子进程都在运行，阻塞</li>
<li>若一个子进程已经终止，正等待父进程获取其终止状态，则会立刻返回</li>
<li>若没有任何子进程，立即出错返回</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/wait.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t wait(int *statloc);
</span><span class='line'>
</span><span class='line'>pid_t waitpid(pid_t pid, int *statloc, int options);
</span></code></pre></td></tr></table></div></figure>


<p>wait和waitpid函数的区别：</p>

<ul>
<li>在一个子进程终止前，wait函数会使其调用至阻塞，而waitpid有一个选项，可使调用者不阻塞（比如：<code>waitpid(-1, &amp;statloc, WNOHANG)</code>）</li>
<li>waitpid可以不用等待其调用后的第一个终止的子进程，可以指定它等待的进程（参数pid > 0时）</li>
</ul>


<p>参数statloc是一个整型指针，子进程的终止状态存放于此，若不关心终止状态，可以传空指针。而判断子进程的终止状态，可以使用wait.h定义的宏：</p>

<table>
<thead>
<tr>
<th>宏        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFEXITED       </td>
<td style="text-align:center;"> 若正常终止的子进程，则为真。此时，可以调用WEXITSTATUS(status)获取子进程传送给exit <em>exit </em>Exit参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED     </td>
<td style="text-align:center;"> 若为异常终止的子进程返回的状态，则为真。可以使用WTERMSIG(status)获取子进程终止的信号编号。</td>
</tr>
<tr>
<td>WIFSTOPPED      </td>
<td style="text-align:center;"> 若为当前暂停子进程的返回状态，则为真。可使用WSTOPSIG(status)获取进程暂停信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED    </td>
<td style="text-align:center;"> 若作业控制暂停后已经继续的子进程返回了状态，则为真。</td>
</tr>
</tbody>
</table>


<h2>waitpid</h2>

<p>waitpid函数功能多于wait函数，其中，pid参数的意义：</p>

<ul>
<li>pid == -1 ，等待任一子进程，此时与wait等效</li>
<li>pid > 0，等待进程Id等于PID的进程</li>
<li>pid == 0，等待其组ID等于调用进程组ID的任意一子进程</li>
<li>pid &lt; -1，等待其组ID等于pid绝对值的任一子进程</li>
</ul>


<p>而waitpid的options参数进一步控制了waitpid的操作：</p>

<ul>
<li>WNOHANG : 不阻塞</li>
<li>WCONTINUED : 作业控制相关</li>
<li>WUNTEACED: 作业控制相关</li>
</ul>


<p>依据这两个参数，waitpid提供了wait不具有的三个功能：</p>

<ul>
<li>可等待特定的进程</li>
<li>提供了wait的非阻塞版本</li>
<li>支持作业控制</li>
</ul>


<h1>关于僵死进程补充</h1>

<h2>僵死进程的危害</h2>

<p>若父进程一直存在，但不调用wait回收终止子进程的终止状态，则：</p>

<ul>
<li>内核保留了僵死进程的一定量信息，资源浪费</li>
<li>进程号一直没有释放，也就得不到重用</li>
</ul>


<h2>避免僵死进程的方法</h2>

<ul>
<li>通过信号机制</li>
<li>wait/waitpid函数调用</li>
<li>fork两次，由init来回收</li>
</ul>


<h2>如何查看僵死进程</h2>

<p>命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps -A -o stat, ppid, pid, cmd | grep -e '^[zZ]'
</span><span class='line'>
</span><span class='line'>* -A 列出所有进程
</span><span class='line'>* -o 自定义输出字段，stat表示进程状态，Z/z表示僵死进程
</span><span class='line'>
</span><span class='line'># 竞争条件
</span><span class='line'>
</span><span class='line'>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则认为发生了*竞争条件（race condition）*
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h1>exec函数</h1>

<p>在fork后，如果调用exec函数，则该进程执行的程序完全替换成新程序，并且从新程序的main函数开始执行。exec并不创建新进程，因此调用exec前后并不改变进程ID。exec只是用全新的程序替换了当前进程的正文数据堆和栈等段。</p>

<p>unix系统提供了6个exec函数，unix对进程的控制：</p>

<ul>
<li>fork</li>
<li>exit</li>
<li>wait</li>
<li>exec</li>
</ul>


<p>这几个函数使得unix进程控制原语更加完善。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>// 下面四个函数，执行程序是路径
</span><span class='line'>int execl(const char *pathname, const char *arg0, ... /* (char *)0 */)  // 参数是列表，以空指针结束
</span><span class='line'>
</span><span class='line'>int execv(const char *pathname, char *const argv[]) // 参数列表是一个数组
</span><span class='line'>
</span><span class='line'>int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */) // 可以传递一个环境表，这个环境表是个指针数组，每个元素是指向字符的指针
</span><span class='line'>
</span><span class='line'>int execve(const char *pathname, char *const argv[], char *const envp[]) // 传递环境表
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 执行程序是文件名，如果文件名以“/”开头，则认为是路径，否则从PATH变量中搜寻执行文件
</span><span class='line'>int execlp(const char *filename, const char *arg0, ... /* (char *)0 */)
</span><span class='line'>
</span><span class='line'>int execvp(const char *filename, char *const argv[])
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这六个函数的几种区别是：</p>

<ol>
<li>前四个函数已路径名作为参数，而后两个使用文件名作为参数，如果是文件名作为参数，则：

<ul>
<li>如果filename是包含“/”，则认为是路径</li>
<li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件（如果找到的可执行文件不是链接器生成的机器可执行文件，则认为是shell脚本，就会调用/bin/sh，并以filename作为shell的输入）</li>
</ul>
</li>
</ol>


<blockquote><p>说明：
环境表：每个程序都会接收一张环境表，这个环境表是一个字符指针数组，全局变量environ指向这个数组。
      环境表包含的环境变量，比如PATH=:/bin:/usr/bin:、USER=sar、等</p>

<p>环境变量（环境表中的每个数组元素），可以通过getenv获取环境变量。通过putenv、setenv等设置环境变量，一般使用这两个
函数访问设置环境变量，而不推荐直接访问environ全局变量。</p>

<p>POSIX.1 XSI等预定义了很多环境变量，其中PATH环境变量表示“搜索可执行文件的路径前缀列表”</p></blockquote>

<ol>
<li><p>第二个区别是参数表的传递不同。l表示list，v表示vector。execl、execle、execlp的每个命令行参数都说明为一个单独的参数，最后以空指针结尾。而execv、execve、execvp的命令行参数是以数组提供。</p></li>
<li><p>最后一个区别，传递的环境表有关。已e结尾的两个函数execle和execve，可以传递一个指向环境字符串指针数组的指针，其它几个函数则使用调用进程中的environ变量为新程序复制现有的环境。</p></li>
</ol>


<p>注意几点：</p>

<ol>
<li>对打开的文件的处理</li>
</ol>


<p>这与执行时关闭close-on-exec设置有关</p>

<p>进程中每个打开描述符都有一个执行时关闭标志。若设置此标志，则在执行exec时关闭该描述符，否则该描述符仍然打开。除非特地用fcntl设置了该标志，否则系统默认的操作是在执行exec后仍保持这种描述符的打开。</p>

<blockquote><p>fcntl函数可以：
* 复制一个现有描述符
* 设置/获得文件描述符标记（文件描述符标志，当前只定义了一个，就是FD_CLOEXEC）
* 获得/设置文件状态标志
* 等。</p></blockquote>

<p>posix.1明确要求在执行exec时关闭打开的目录流，这通常是opendir来实现的。它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志。</p>

<blockquote><p>疑问：
设置close-on-exec的场景是什么？？</p></blockquote>

<ol>
<li>有效用户问题</li>
</ol>


<p>exec后，实际用户id和实际组id不变，而有效id是否改变，则取决于程序文件的设置用户id和设置组id是否设置。</p>

<p>很多unix实现中，只有execve是系统调用，其它函数是库函数。</p>

<h1>更改用户ID和组ID</h1>

<p>unix系统中，特权是基于用户和组ID的。</p>

<p>可以调用setuid函数设置实际用户id和有效用户id。setgid函数设置实际组id和有效组id。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int setuid(uid_t uid);
</span><span class='line'>
</span><span class='line'>int setgid(gid_t gid);
</span></code></pre></td></tr></table></div></figure>


<p>对于修改ID有以下规则：</p>

<ul>
<li>若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为参数uid</li>
<li>若进程没有超级用户特权，但是参数uid等于实际用户ID<strong>或者</strong>保存的设置用户ID，则setuid只将有效用户ID设置为uid，不改变实际用户ID<strong>和</strong>保存的设置用户ID</li>
<li>若上面两个条件都不满足，则将errno设置为EPERM，并返回-1.</li>
</ul>


<p>关于内核维护的三个用户ID，注意：</p>

<ol>
<li>只有超级用户进程可以更改实际用户ID。通常实际用户ID是在用户登录时，有login程序设置的，而且拥有不会改变他。</li>
<li>仅当对程序文件设置了设置用户ID位时，exec函数才会设置有效用户ID。如果设置用户位没有设置，则exec函数不会改变有效用户ID，而将其维持为原先的值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID。</li>
<li>保存的设置用户id是由exec复制有效用户ID而得来的。如果设置了文件的设置用户ID位（执行位显示为s），则exec根据文件的用户ID设置了进程的有效用户ID以后，就将这个副本保存起来。</li>
</ol>


<table>
<thead>
<tr>
<th>ID    </th>
<th style="text-align:center;"> exec(设置用户ID位关闭) </th>
<th style="text-align:center;"> exec（设置用户ID位开启）</th>
<th style="text-align:center;"> setuid（超级用户） </th>
<th style="text-align:center;"> setuid（非特权用户）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实际用户ID     </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 设置为uid  </td>
<td style="text-align:center;">不变</td>
</tr>
<tr>
<td>有效用户id     </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 设置为程序文件的用户ID  </td>
<td style="text-align:center;"> 设置为uid  </td>
<td style="text-align:center;">设置为uid</td>
</tr>
<tr>
<td>保存的设置用户ID</td>
<td style="text-align:center;"> 从有效用户ID复制   </td>
<td style="text-align:center;"> 从有效用户ID复制</td>
<td style="text-align:center;">设置为uid </td>
<td style="text-align:center;"> 不变</td>
</tr>
</tbody>
</table>


<h2>su 和sudo和setuid的关系</h2>

<p>su命令可以切换用户，而sudo可以以超级用户权限运行命令。查看这两个文件状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ll /usr/bin/su
</span><span class='line'>-rwsr-xr-x  1 root  wheel  21472  3 13  2013 /usr/bin/su
</span><span class='line'>$ ll /usr/bin/sudo
</span><span class='line'>-r-s--x--x  1 root  wheel  164496  3 13  2013 /usr/bin/sudo
</span></code></pre></td></tr></table></div></figure>


<p>su和sudo的用户执行位都是s，表示setuid为开启。当用户运行这个程序时，</p>

<p>会设置程序的有效用户ID为文件所有者，就会以这个文件的所有者（这里是root）权限运行。</p>

<p>因此，sudo命令可以以root权限执行命令。</p>

<p>当su命令执行时，设置进程的有效用户ID为root。</p>

<h1>解释器文件</h1>

<p>解释器文件，是文本文件，起始行的形式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! pathname [optional-argument]
</span></code></pre></td></tr></table></div></figure>


<p>感叹号和pathname之间的空格是可选的。最常见的解释器是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/sh</span></code></pre></td></tr></table></div></figure>


<ul>
<li>pathname通常是绝对路径，对它不进行特殊处理（既不视屏PATH进行路径搜索），对这种文件识别，是由内核作为exec系统调用处理的一部分完成的。</li>
<li>内核调用exec函数实际上执行的并不是解释器文件，而是解释器文件中第一行pathname指定的文件</li>
<li>注意区别解释器文件（文本文件，以#!开头）和解释器之间区别（解释器文件第一行pathname指定）</li>
</ul>


<h2>解释器例子</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;sys/wait.h&gt;
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  pid_t pid;
</span><span class='line'>  if((pid = fork()) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("fork error\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(pid == 0)
</span><span class='line'>  {
</span><span class='line'>      printf("child process\n");
</span><span class='line'>      if(execl("/Users/user/work/cproj/testinterp", "testinterp", "myarg1", "My arg2", (char *) 0) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("error execl\n");
</span><span class='line'>          exit(-1);
</span><span class='line'>      }
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if(waitpid(pid, NULL, 0) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("error waitpid");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>解释器文件testinterp很简单，只有一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#! /Users/user/work/cproj/echoarg foo</span></code></pre></td></tr></table></div></figure>


<p>而echoarg程序仅仅是打印参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  int i;
</span><span class='line'>  for (i = 0; i &lt; argc; i++)
</span><span class='line'>  {
</span><span class='line'>      printf("ARGV[%d]:%s\n", i, *(argv+i));
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>结果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ser@usertekiMacBook-Pro cproj$ ./execinterp
</span><span class='line'>child process
</span><span class='line'>ARGV[0]:/Users/user/work/cproj/echoarg
</span><span class='line'>ARGV[1]:foo
</span><span class='line'>ARGV[2]:/Users/user/work/cproj/testinterp
</span><span class='line'>ARGV[3]:myarg1
</span><span class='line'>ARGV[4]:My arg2
</span></code></pre></td></tr></table></div></figure>


<p>对程序结果的解释：</p>

<ul>
<li>当exec调用解释器（/Users/user/work/cproj/echoarg）时，argv[0]是该解释器的pathname（）。</li>
<li>argv[1]是解释器文件中的可选参数（foo）</li>
<li>其余参数是pathname（/Users/user/work/cproj/testinterp）</li>
<li>以及第二、三个参数（myarg1和My arg2）</li>
<li>注意，第一个参数（testinterp），是没有用的</li>
</ul>


<h2>解释器文件可选参数例子</h2>

<p>解释器pathname后可跟随可选参数，比如awk支持-f选项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>awk -f myfile</span></code></pre></td></tr></table></div></figure>


<p>它告诉awk从文件myfile中读awk程序。</p>

<p>如果在解释器文件中使用-f选项，则解释器文件可以这么写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#! /bin/awk -f
</span><span class='line'>
</span><span class='line'>后面跟着awk程序</span></code></pre></td></tr></table></div></figure>


<p>比如解释器文件/usr/local/bin/awkexample的内容是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/awk -f 
</span><span class='line'>BEGIN {
</span><span class='line'>  for (i = 0; i &lt; ARGC; i++)
</span><span class='line'>      printf "ARGV[%d] = %s\n", i, ARGV[i]
</span><span class='line'>  exit 
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ awkexample file1 FILENAME2 f3 ARGV[0] = awk
</span><span class='line'>ARGV[1] = file1
</span><span class='line'>ARGV[2] = FILENAME2
</span><span class='line'>ARGV[3] = f3</span></code></pre></td></tr></table></div></figure>


<p>如果执行这个文件时，实际上，是这么调用的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/bin/awk -f /usr/local/bin/awkexample file1 FILENAME2 f3</span></code></pre></td></tr></table></div></figure>


<ol>
<li>解释器文件的路径名/usr/local/bin/awkexample给传给解释器，因为不知道解释器是不是会从搜索路径中搜索该文件，因此传全路径文件名</li>
<li>awk读取解释器文件，第一行是#，注释，因此忽略第一行，执行后续程序</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python杂记]]></title>
    <link href="http://baren.github.io/blog/2014/04/22/python-note/"/>
    <updated>2014-04-22T11:15:07+08:00</updated>
    <id>http://baren.github.io/blog/2014/04/22/python-note</id>
    <content type="html"><![CDATA[<ul>
<li><p>实际上，每一个python函数都有返回值，如果有return，则返回return指定的值；没有就返回None。</p></li>
<li><p>python的搜索路径是在sys.path中搜索，sys.path是一个list，可以修改这个list的值。</p></li>
<li><p>python中，所有都是对象（函数是对象，模块是对象等），意思是所有都可以赋值给变量，或者作为参数传递给函数。所有都是对象，有些可能不具有方法和属性，有些不能被继承，但是都可以赋值和传参。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程环境)]]></title>
    <link href="http://baren.github.io/blog/2014/04/09/process-environment/"/>
    <updated>2014-04-09T20:00:58+08:00</updated>
    <id>http://baren.github.io/blog/2014/04/09/process-environment</id>
    <content type="html"><![CDATA[<h1>main函数</h1>

<p>c程序的起始运行函数是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, char *argv[]);
</span></code></pre></td></tr></table></div></figure>


<p>argc是命令行参数数目，argv是指针数组，指向每一个参数。</p>

<p>内核执行C程序是调用exec函数，在调用main函数之前，会先调用一个特殊的启动例程，可执行程序文件指定这个例程作为程序的启动地址。这是由链接编辑器设置的。链接编辑器由编译器调用。</p>

<p>启动例程会从内核取得命令行参数和环境变量值。</p>

<!-- more -->


<h1>进程终止</h1>

<p>有八种终止进程的方式，其中5种方式为正常终止，为：</p>

<ol>
<li>从main函数返回</li>
<li>调用exit函数</li>
<li>调用<em>exit或</em>Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用pthread_exit</li>
</ol>


<p>异常终止的三种方式：</p>

<ol>
<li>调用abort</li>
<li>接到一个信号并终止</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>


<p>程序启动例程，在main函数返回后，会立即调用exit函数。其类似过程是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exit(main(argc, argv));</span></code></pre></td></tr></table></div></figure>


<p>实际上，并不是这样（过程是一样的），启动例程一般是用汇编编写。</p>

<h2>exit函数</h2>

<p>三个用于正常终止程序的函数中，<em>exit和</em>Exit函数立即进入内核。</p>

<p>exit函数则先执行一些清理处理（调用终止处理程序，关闭所有标识I/O流），然后进入内核。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>void exit(int status);
</span><span class='line'>void _Exit(int status);
</span><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>void _exit(int status);
</span></code></pre></td></tr></table></div></figure>


<p>exit的清理操作，执行一个标准的I/O库的清理关闭操作，为所有打开流调用fclose函数（怎么实现的？）</p>

<blockquote><p>注意
exit和<em>Exit函数是ISO C标准定义的，而</em>exit则是POSIX说明的，因此使用的头不一样。</p></blockquote>

<p>由于标准库有buffer，因此怎样退出程序很重要。</p>

<p>若使用fopen函数打开文件，并没用fclost关闭它，影响是什么呢？</p>

<p>若使用exit函数或正常从main函数返回，两种方式都会调用exit函数。因此，exit函数会为你处理：</p>

<ul>
<li>flush输出流</li>
<li>关闭文件</li>
<li>进程拥有的其它资源也会被释放</li>
</ul>


<p>如果非正常退出，或调用<em>exit或</em>Exit函数，则</p>

<ul>
<li>系统会关闭打开的文件</li>
<li>释放资源</li>
<li>buffer并不会被flush</li>
</ul>


<p>三个exit函数都有一个整型参数，称之为终止状态（或退出状态，exit status），shell可用$?查看上一条命令的返回值。</p>

<p>若：</p>

<ul>
<li>调用这些函数不带终止符</li>
<li>main执行了一个无返回值的return语句</li>
<li>main没有生命返回类型为整型</li>
</ul>


<p>则：</p>

<p>进程状态为未定义的。</p>

<p>但：</p>

<p>若main生命为int返回类型，并执行到最后一条语句时返回（隐式返回），</p>

<p>则：</p>

<p>进程终止状态为0</p>

<p>在main函数返回一整型值与用该值调用exit函数是等价的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exit(0) == return 0;</span></code></pre></td></tr></table></div></figure>


<h2>atexit函数</h2>

<p>可以注册终止处理函数，这批函数在exit自动调用，ISO C规定，可注册函数多达32个，注册这些函数使用atexit函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>int atexit(void (*func)(void));
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注：
1. exit调用这些函数顺序与他们登记的顺序相近
2. 同一个函数若登记多次，则会调用多次</p></blockquote>

<p><img src="http://baren.github.io/images/assets/Figure7-1.png" title="time-function" alt="alt text" /></p>

<h1>命令行参数</h1>

<p>比较简单，记录一点。</p>

<p>argv[argc]是一个空指针，这样，可以在循环获取参数时，这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>for(i=0; garv[i] != NULL; i++)
</span><span class='line'>{
</span><span class='line'>  // 代码
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>环境表</h1>

<p>每个程序，都会收到一张环境表，环境表是字符指针数组，每个指针指向的字符以null结束。</p>

<p><strong>全局变量</strong><code>environ</code>包含了该指针数组的地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extern char ** environ;
</span></code></pre></td></tr></table></div></figure>


<p>称environ为环境指针，指针数组为环境表，环境表每个表项由name=value组成。</p>

<h1>C程序的存储空间</h1>

<p>C程序由以下几部分组成</p>

<ul>
<li>正文段：是由CPU执行的机器指令部分，正文段是共享的，而且是只读的。</li>
<li>初始化数据段：常称为数据段，它包含了程序中须明确的赋初始值的变量。比如
在C程序中出现在任何函数之外的声明：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int maxcount = 99;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>非初始化数据段：常称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针，出现在任何函数外的C声明：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>long sum[1000];
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>栈：自动变量，函数调用时所需要保存的信息，都存放到栈中，这种实现方式允许递归调用。</li>
<li>堆：一般在堆中进行动态存储分配。堆位于非初始化数据段和栈之间。</li>
</ul>


<p>示意图：</p>

<p><img src="http://baren.github.io/images/assets/Figure7-2.png" title="time-function" alt="" /></p>

<p>linux的size命令可以报告正文段、数据段和bss段的长度。</p>

<h1>共享库</h1>

<p>共享库使得可执行文件中不再需要包含共用库的例程。</p>

<p>只需要在所有进程都可引用的存储区中维护这种库例程的一个副本，在例程<strong>第一次</strong>执行或在第一次调用某个库函数时，用<strong>动态链接</strong>方法，将程序与共享库函数相链接。</p>

<p>好处：</p>

<ul>
<li>减少了执行文件长度</li>
<li>方便替换使用的库函数的版本而不需要重新链接。</li>
</ul>


<p>坏处：
* 增加了首次的运行时间</p>

<blockquote><p>GCC编译器，默认引用动态库，动态库是以.so结尾；而静态库是以.a为扩展名。引用一个程序库，可以使用-l<em>NAME</em>选项。</p></blockquote>

<h1>存储器分配</h1>

<ol>
<li>malloc 分配指定大小（字节数）的存储区，初始值不确定</li>
<li>calloc 为指定数量且指定长度的对象分配存储空间，初始化值为0</li>
<li>realloc 更改以前分配区的长度（增加或减少）</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'># include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void *malloc(size_t size);
</span><span class='line'>void *calloc(size_t nobj, size_t size);
</span><span class='line'>void *realloc(void *ptr, size_t newsize);
</span><span class='line'>
</span><span class='line'>void free(void *ptr);
</span></code></pre></td></tr></table></div></figure>


<p>三个函数返回的指针一定是适当对齐的（原理基本上是已对齐单位的倍数的方式多分配内存）。</p>

<p>三个函数返回void *指针，因此可以将其赋值给任何指针而不需要强制转换。</p>

<p>free可以释放由上面三个函数分配的内存。</p>

<p>这些分配函数通常调用sbrk系统调用实现。</p>

<p>sbrk可增大和减少进程的存储空间，但malloc和free一般都不减少存储空间，以便分配并保持在malloc池中不返回内核。</p>

<h1>环境变量</h1>

<p>环境变量字符串的形式为<code>name=value</code>，unix不会查看此字符串，完全由程序解释。</p>

<p>ISO C定义了一个函数getenv，根据name获取其value。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>char *getenv(const char *name);</span></code></pre></td></tr></table></div></figure>


<p>除了获取环境变量，还可以设置环境变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>int putenv(char *str);
</span><span class='line'>
</span><span class='line'>int setenv(const char *name, const char *value, int rewrite);
</span><span class='line'>
</span><span class='line'>int unsetenv(const char *name);</span></code></pre></td></tr></table></div></figure>


<p>putenv，参数为name=value字符串，若name存在，则先删除</p>

<p>setenv，参数name的值设为value，如果name存在，则根据rewrite参数决定是重写还是不删除。</p>

<p>unsetenv，删除name的定义</p>

<blockquote><p>注意：
1. putenv的实现，linux直接将字符串地址作为参数放入环境表中，如果参数是存放在栈中，则会发生错误。
2. 由于环境变量存放在程序空间的最上面，大小是有边界的，因此，如果设置的环境变量超出了存储空间大小，则需要由malloc在堆上分配空间来存储。</p></blockquote>

<h1>setjmp和longjmp函数</h1>

<p>c语言中，goto语句不能跨函数，如果要跨函数，则需要setjmp和longjmp函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>int setjmp(jmp_buf env);
</span><span class='line'>void longjmp(jmp_buf env, int val);</span></code></pre></td></tr></table></div></figure>


<p>调用这两个函数，遇到的问题是：</p>

<ol>
<li>调用longjmp后，自动变量和寄存器变量的状态如何？这些值能回滚到调用setjmp的状态码？</li>
</ol>


<p>答：不确定，跟实现有关系。大多数实现并不回滚这些自动变量和寄存器变量的值，而所有标准则说他们的值是不确定的。如果有一个自动变量，而又不想使其回滚，则可以定义具有volatile属性。声明为全局或静态变量的值在执行longjmp时保持不变。</p>

<ol>
<li>自动变量的问题：若在函数内部声明指针，并返回了这个指针，则会出问题。</li>
</ol>


<h1>进程资源</h1>

<h2>进程资源使用</h2>

<p>getrusage()系统调用返回调用进程或者其所有子进程运行所使用的各种系统资源。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/resource.h&gt;
</span><span class='line'>
</span><span class='line'>int getrusage(int who, struct rusage *res_usage);</span></code></pre></td></tr></table></div></figure>


<p>参数who指定了进程中谁的资源使用信息将会被获取。有下面几个值：</p>

<ul>
<li>RUSAGE_SELF 返回调用进程的资源</li>
<li>RUSAGE_CHILDREN 返回调用进程的所有子进程的资源。子进程是停止的和wait的。</li>
<li>RUSAGE_THREAD 返回调用线程的资源（Linux 2.6.26）</li>
</ul>


<p>res_usage参数是一个指针，指向结构为rusage的对象。</p>

<h2>进程资源限制</h2>

<p>每个进程都消耗系统资源，OS对每个进程都有一些资源限制。在shell中，可以使用ulimit命令设置进程的资源限制。所有通过shell启动的进程都会继承ulimit设置的限制。</p>

<p><em>getrlimit()</em> 和 <em>setrlimit()</em> 两个函数可以获取和设置进程的资源限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/resource.h&gt;
</span><span class='line'>int getrlimit(int resource, struct rlimit *rlim);
</span><span class='line'>int setrlimit(int resource, const struct rlimit *rlim);
</span><span class='line'>// Both return 0 on success, or –1 on error
</span></code></pre></td></tr></table></div></figure>


<p><em>resource</em>参数代表了需要获取或设置的资源标记符。rlimit是一个结构体，用来描述资源限制的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rlimit {
</span><span class='line'>rlim_t rlim_cur; /* Soft limit (actual process limit) */ 
</span><span class='line'>rlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>关于结构体<code>struct rlimit</code>解释如下：</p>

<p>既有软限制（rlim_cur），又有硬限制（rlim_max）。软限制表示进程可以消耗的最大资源设置。一个进程可以调整软限制，调整范围是[0-硬限制]。进程可以调整其硬限制。没有权限的进程，只能降硬限制调小（但不小于软限制），对于大多数进程，硬限制只是说明进程的可消耗的资源的最大值。</p>

<p>有权限的进程（CAP_SYS_RESOURCE）可以调整硬限制大小，既可往大得方向调整，也可以往小的方向调整。</p>

<p>如果rlim_cur和rlim_max的值是RLIM_INFINITY，表示没有限制。</p>

<p>虽然设置进程的资源限制是针对单个进程的。但进程可消耗的资源除了与这个设置有关系外，还需要依赖同一个用户id的进程所消耗的资源之和。</p>

<p>比如RLIMIT_NPROC资源，表示可创建的进程数限制，就是一个很好的例子。但是如果根据进程的子进程数来检查这个限制，将会失效，因为子进程也会创建新的进程。实际上，这个资源限制是针对所有的用户id都相同的进程设置的。但是，即使是具有同样的用户id，如果其他进程并没有针对这个资源进行限制，或者有限制，但是限制数跟其他不一样，则这个限制资源检查则是根据这个进程的相应设置来进行相应检查的。</p>

<p>下表是参数<em>resource</em>的取值表：</p>

<table>
<thead>
<tr>
<th>resource        </th>
<th style="text-align:center;"> Limit on</th>
</tr>
</thead>
<tbody>
<tr>
<td>RLIMIT_AS      </td>
<td style="text-align:center;"> 进程的虚拟内存大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_CORE    </td>
<td style="text-align:center;"> Core 文件大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_CPU     </td>
<td style="text-align:center;"> 进程的cpu时间(seconds)</td>
</tr>
<tr>
<td>RLIMIT_DATA    </td>
<td style="text-align:center;"> 进程的数据段大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_FSIZE   </td>
<td style="text-align:center;"> 文件大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_MEMLOCK </td>
<td style="text-align:center;"> 锁定的内存大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_MSGQUEUE </td>
<td style="text-align:center;"> 为实际用户id分配的POSIX的消息队列的大小(since Linux 2.6.8)</td>
</tr>
<tr>
<td>RLIMIT_NICE    </td>
<td style="text-align:center;"> nice的值(since Linux 2.6.12)</td>
</tr>
<tr>
<td>RLIMIT_NOFILE  </td>
<td style="text-align:center;"> 最大的文件描述符个数</td>
</tr>
<tr>
<td>RLIMIT_NPROC   </td>
<td style="text-align:center;"> 一个实际用户id可创建的进程数</td>
</tr>
<tr>
<td>RLIMIT_RSS     </td>
<td style="text-align:center;"> Resident set size (bytes; not implemented)</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(系统数据文件和信息)]]></title>
    <link href="http://baren.github.io/blog/2014/03/29/system-data-file-and-info/"/>
    <updated>2014-03-29T08:06:39+08:00</updated>
    <id>http://baren.github.io/blog/2014/03/29/system-data-file-and-info</id>
    <content type="html"><![CDATA[<h1>时间和日期</h1>

<p>unix内核提供的<em>基本时间服务</em>是计算自国际标准时间公元1970年1月1日00:00:00以来经过的秒数。</p>

<p>这种秒数是以数据类型time_t表示的。称之为<strong>日历时间</strong>，日历时间包括日期和时间。</p>

<p>time函数返回当前的时间和日期：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>time_t time(time_t *calptr);
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>时间值总是作为函数值返回。如果参数不为空，则时间也存放在由calptr执行的内存中。</p>

<p>gettimeofday函数提供了更高分辨率（最高为微妙级）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/time.h&gt;  ## 这里就是sys/time.h头文件了
</span><span class='line'>
</span><span class='line'>int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>该函数作为XSI扩展定于在Single UNIX Specification中，tzp唯一合法的值是NULL，其它值则将产生不确定的结果。</p>

<p>gettimeofday函数把当前时间放在tp指向的timeval结构中，该结构存储秒和微妙。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct timeval {
</span><span class='line'>  time_t tv_sec;  /*秒*/
</span><span class='line'>  long tv_usec;  /*微妙，注意是微妙，不是毫秒*/
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>取到time_t后，可以调用其它函数来转成成可读的日期和时间。</p>

<p><img src="http://baren.github.io/images/assets/Figure6-1.png" title="time-function" alt="alt text" /></p>

<p>localtime和gmtime将日历时间转换成以年、月、日、时、分、秒、周日表示的时间，并将这些存放在tm结构中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'># 将日历时间转换成国际标准时间的年、月、日、时、分、秒、周日。
</span><span class='line'>struct tm *gmtime(const time_t *calptr);
</span><span class='line'># 将日历时间转换成本地时间（考虑本地时区和夏令时）
</span><span class='line'>struct tm *localtime(const time_t *calptr);
</span><span class='line'>
</span><span class='line'>struct tm{
</span><span class='line'>  int time_sec; /*秒 [0-60]*/
</span><span class='line'>  int time_min; /*分 [0-59]*/
</span><span class='line'>  int tm_hour; /*时 [0-23]*/
</span><span class='line'>  int time_mday; /*日 [0-31]*/
</span><span class='line'>  int tm_mon; /*月 [0-11]*/
</span><span class='line'>  int tm_year; /*年 [1900年开始]*/
</span><span class='line'>  int tm_wday; /*从周日开始的天 [0-6]*/
</span><span class='line'>  int tm_yday; /*从一月开始的天数 [0-365]*/
</span><span class='line'>  int tm_isdst; /*daylight(夏令时)保存时间标记，&lt;0, 0, &gt;0*/
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>秒可以超过59的原因是可以闰秒。如果夏令时生效，夏令时标志值为正；如果非夏令时制时间，标志位0；不可用，则为负。</p>

<p>mktime函数把年月日等作为参数，转换成time_t的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>time_t mktime(struct tm *tmptr);
</span><span class='line'>
</span><span class='line'># 下面两个函数把时间转换成date命令的系统默认输出形式。只是参数不一样
</span><span class='line'>char *asctime(const struct tm *tmptr);
</span><span class='line'>char *ctime(const time_t *calptr);
</span></code></pre></td></tr></table></div></figure>


<p>strftime函数是格式化时间：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>size_t strftime(char *restrict buf, size_t masxize, const char *restrict format, const struct tm *restrict tmptr);
</span></code></pre></td></tr></table></div></figure>


<p>最后一个参数是要格式化的时间值，tm结构指针传递。格式化结果存放在一个长度为maxsize的buf数组中，如果buf长度可以存放格式化结果和一个null终止符，则该函数返回在buf中存放的字符数，否则该函数返回0.</p>

<p>format是格式化字符串。</p>

<p>转换符略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(标准I/O库)]]></title>
    <link href="http://baren.github.io/blog/2014/03/22/standard-io/"/>
    <updated>2014-03-22T20:06:00+08:00</updated>
    <id>http://baren.github.io/blog/2014/03/22/standard-io</id>
    <content type="html"><![CDATA[<h1>流和FILE对象</h1>

<h2>流介绍</h2>

<p>对于标准I/O库，他们的操作是围绕<em>流</em>进行的。</p>

<p>与JAVA使用Stream类来代表流不一样，标准I/O采用结构体FILE来代表流，由于大多数标准库的函数使用FILE <em>来作为参数，因此也用</em>文件指针*来代称流。</p>

<p>struct FILE结构体在stdio.h中做了声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct _sFILE{...} FILE;
</span></code></pre></td></tr></table></div></figure>


<p>数据类型FILE
    > 代表流对象，FILE对象含有所有的连接文件的内部状态，包括文件位置标记和缓存信息等。
    > 每一个流海包含error和文件末尾状态标记，可以通过ferror和feof函数进行测试。</p>

<!-- more -->


<h2>流的定向</h2>

<p>标准I/O可以用于单字节的字符集（ascii字符集）和多字节（宽）字符集，这就要求<em>流的定向</em>。
对于宽字节的处理，有一套专门的多字节处理函数（wchar.h中声明）。
对于同样的流，为了能处理宽的和正常的字符的操作，有一个限制：</p>

<ul>
<li>流要么被标记为宽定向的，要么是字节定向的</li>
<li>一旦确定定向后，不能二者混用</li>
</ul>


<p>有三种方式来定向流：</p>

<ul>
<li>创建流后，任一个正常字符函数被使用，流被标记为字节定向的。</li>
<li>创建流后，任一个宽字符函数被使用，流被标记为宽定向的。</li>
<li>使用<code>fwide函数</code>来设置流的定向。</li>
<li>freopen函数可以清除流的定向。</li>
</ul>


<p>注意：</p>

<ul>
<li>流刚被创建时，并没有定向</li>
<li>在未定向流上使用字节字符函数则置为字节定向的</li>
<li>在未定向流上使用宽字节函数则置为宽字节定向的</li>
</ul>


<p>fwide函数说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;wchar.h&gt;
</span><span class='line'>
</span><span class='line'># 返回值：若流是宽定向的，则返回正值；若流是字节定向的，则返回负值；若流是未定向的，则返回0.
</span><span class='line'>int fwide(FILE *fp, int mode);</span></code></pre></td></tr></table></div></figure>


<p>根据mode参数的值，fwide执行不同的工作：</p>

<ul>
<li>若mode参数为负值，fwide试图使指定的流是字节定向的</li>
<li>若mode参数为正值，fwide试图使指定的流是宽定向的</li>
<li>若mode参数为0，fwide将不试图设置流的定向，但返回标识该流定向的值</li>
</ul>


<blockquote><p>注意:
fwide不会改变已经设置定向的流
fwide不会出错，想检查错误，唯一可用的是调用之前先清除errno，调用fwide后检查errno的值。（errno是全局变量，每次调用失败，系统会用错误代码赋值给errno）</p></blockquote>

<h1>标准输入/输出/错误</h1>

<p>当main函数被调用，就已经有3哥预先定义的打开的流可以使用，这三个流在stdio.h中声明：</p>

<ul>
<li>FILE *stdin。标准输入流</li>
<li>FILE *stdout。标准输出流</li>
<li>FILE *stderr。标准错误流</li>
</ul>


<p>在GNU C中，stdin、stdout和stderr是正常常量，可以直接用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fclost(stdout);
</span><span class='line'>stdout = fopen("filepath", "w");
</span></code></pre></td></tr></table></div></figure>


<h1>缓冲</h1>

<p>标准I/O提供了三种类型的缓冲：</p>

<ul>
<li>全缓冲。填满缓冲区后才进行实际的I/O操作。对于磁盘文件，通常是全缓冲的。在一个流上第一次执行I/O操作时，标准I/O函数通常用malloc获取需要使用的缓冲区。</li>
<li>行缓冲。当输入和输出中遇到换行符时，标准I/O库执行I/O操作。当涉及到终端时，通常使用行缓冲。</li>
</ul>


<blockquote><p>行缓冲有两个限制：</p>

<p>缓冲区长度是固定的，所以只要填满了缓冲区，即使没有缓冲区，也进行I/O操作</p>

<p>任何时候，只要标准I/O库从 a）不带缓冲的流，或者 b）一个行缓冲的流（但数据从内核获取）得到输入数据，那么就会造成冲洗所有行缓冲输出流。</p>

<p>从实现角度说，这么个限制是有原因的：如果从不带缓冲的流中获取数据，那么缓冲区中的没有冲洗的旧数据会对新数据造成污染。</p></blockquote>

<ul>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。标准错误流通常不带缓冲的。</li>
</ul>


<p>iso c 是这样设置缓冲的：
* 当且仅当标准输入和标准输出并不涉及交互设备时，他们才是全缓冲。
* 标准错误绝不会是全缓冲。</p>

<p>但是标准输入输出涉及交互设备时，一般：</p>

<ul>
<li>标准错误不带缓冲。</li>
<li>其它流，涉及终端设备，则是行缓冲；否则是全缓冲。</li>
</ul>


<p>对于这些默认的缓冲情况，可以使用函数进行修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void setbuf(FILE * fp, char * buf);
</span><span class='line'>int servbuf(FILE * fp, char * buf, int mode, size_t size);
</span></code></pre></td></tr></table></div></figure>


<p>这些函数的使用限制是：</p>

<ul>
<li>一定要在流已被打开后调用</li>
<li>在对流执行任何一个其它操作之前调用</li>
</ul>


<p>setbuf可以打开和关闭缓冲，打开缓冲，将buf指向一个长为BUFSIZE的缓冲区（该常量被定义在stdio.h中）。关闭缓冲，则设置buf为NULL。
setvbuf，可以精确控制缓冲类型，通过mode参数指定：</p>

<ul>
<li>_IOFBF    全缓冲</li>
<li>_IOLBF    行缓冲</li>
<li>_IONBF    不缓冲</li>
</ul>


<blockquote><p>注意：
如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流（也就是把数据冲洗一下）。
一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。这种情况下，关闭此流时，标准I/O库将自动释放缓冲区。</p></blockquote>

<p>可以通过函数强制缓冲一个流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdih.h&gt;
</span><span class='line'>
</span><span class='line'>int fflush(FILE * fp);</span></code></pre></td></tr></table></div></figure>


<h1>打开流</h1>

<p>使用下列函数打开流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>FILE *fopen(char * pathname, char *type);
</span><span class='line'>FILE *freopen(char *pachname, char *type, FILE *fp);
</span><span class='line'>FILE *fdopen(int fd, char *type);
</span></code></pre></td></tr></table></div></figure>


<p>使用fopen函数打开一个文件，创建一个新流，并建立这个流和文件之间的连接。这个过程也会涉及到创建新文件。</p>

<p>其中，type参数指定对该流的读、写方式：</p>

<ul>
<li><code>'r'</code>: 只读打开文件</li>
<li><code>'w'</code>: 只写打开，若文件存在，截断为0；否则创建新文件</li>
<li><code>'a'</code>: 追加打开，为在文件为写而打开。文件若存在，则不改变内容。</li>
<li><code>'r+'</code>: 读写打开文件，初始化内容不变，初始化文件位置在文件开头。</li>
<li><code>'w+'</code>: 读写打开文件，若文件存在，截断为0.否则创建新文件</li>
<li><code>'a+'</code>: 为在文件尾读和写而打开文件。</li>
</ul>


<blockquote><p>注意：</p>

<p>&lsquo;+&#8217;请求一个流可以读和写，当使用这种流时，在读写之间转换时，必须刷新buffer，fflush或者订货函数fseek都可以。不然内部的buffer可能不空。</p></blockquote>

<p>freopen函数像fclos和fopen的联合。受限关闭有fp指向的流（这个过程会忽略任何错误），然后再打开pathname指向的文件，一般用于将一个指定的文件打开为一个预定义的流。</p>

<p>可以使用fclose关闭流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fclose(FILE *fp);</span></code></pre></td></tr></table></div></figure>


<p>关闭一个流，关闭文件，并刷新缓冲区的输出数据，并释放由标准I/O库分配的内存。</p>

<blockquote><p>注意：
当程序正常关闭时（调用exit函数和正常从main返回），所有未写缓冲数据的标准I/O流，都会被冲洗；所有打开的标准I/O都会关闭。</p></blockquote>

<h1>读和写流</h1>

<p>一旦打开了流，就可在三中不同类型的非格式化I/O中选择，进行读写。包括：</p>

<ul>
<li>每次只读一个字符的I/O，一次读写一个字符。若流是缓冲的，标准I/O会处理所有缓冲。</li>
<li>每次一行I/O，可以使用fgets和fputs，每行以换行符终止。</li>
<li>direct I/O，直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。用于从二进制文件中每次读或写一个结构。</li>
</ul>


<h2>一次一个字符</h2>

<p>下面三个函数可以用于一次读一个字符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 三个函数的返回值，若成功，返回下一个字符；达文件末尾或失败，则返回EOF
</span><span class='line'>int getc(FILE *fp);
</span><span class='line'>int fgetc(FILE *fp);
</span><span class='line'>
</span><span class='line'>int getchar(void);
</span><span class='line'>
</span><span class='line'># 写入流
</span><span class='line'>int putc(int c, FILE *fp);
</span><span class='line'>int fputc(int c, FILE * fp);
</span><span class='line'>int putchar(int c);
</span></code></pre></td></tr></table></div></figure>


<p>getchar 等价于getc(stdin)，而getc和fgetc的区别是前者可以实现为宏；而后者不可。这意味着：</p>

<ul>
<li>getc的参数不应当是具有副作用的表达式</li>
<li>fgetc是函数，可得到其地址，允许fgetc地址作为参数传递给其它函数</li>
<li>fgetc函数执行时间长于getc函数（宏的优势）</li>
</ul>


<p>不管是出错，还是到达文件末尾，三个函数都返回EOF，为了区分是出错还是到达文件末尾，需要使用ferror或feof函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int ferror(FILE *fp);
</span><span class='line'>
</span><span class='line'>int feof(FILE *fp);
</span><span class='line'>
</span><span class='line'>void clearerr(FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>大多数实现，为每个流在FILE对象中维持了两个标志：</p>

<ul>
<li>出错标志</li>
<li>文件结束标志</li>
</ul>


<p>从流中读取数据后，可以调用ungetc奖字符再压回流中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 成功，返回c，出错返回EOF
</span><span class='line'>int ungetc(int c, FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>关于压回，注意：</p>

<ul>
<li>压回流中的字符可以再读出，但与压入顺序相反。</li>
<li>不能压回EOF。</li>
<li>到达文件末尾，还可压回字符。下次读取将返回该字符，再次读取则返回EOF。这么做的一个原因是，一次成功的ungetc调用会清除该流的文件结束标志。</li>
</ul>


<h2>每次一行</h2>

<p>下面函数是每次一行函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 读一行函数，成功，则返回bug，错误或到达末尾，则返回NULL
</span><span class='line'>char * fgets(char * buf, int n, FILE *fp);
</span><span class='line'>
</span><span class='line'>char * gets(char *buf);
</span><span class='line'>
</span><span class='line'># 写一行函数，成功，返回非负值，出错返回EOF
</span><span class='line'>
</span><span class='line'>int fputs(char * str, FILE *fp);
</span><span class='line'>
</span><span class='line'>int puts(char *str);
</span></code></pre></td></tr></table></div></figure>


<p>两个gets函数，指定了缓冲区，把读的行送入其中。gets从标准输入读，fgets从指定流读。</p>

<ul>
<li>fgets必须指定缓冲区的长度。此函数一直读到下一个换行符为止，但不超过n-1（放null字符），读入的数据被送入缓冲区。</li>
<li>该缓冲区一null结尾。</li>
<li>若该行的字符数超过n-1，则fgets只返回一个不完整的行，但是，缓冲区总是以null字符结尾。</li>
</ul>


<blockquote><p>注意：
gets函数不推荐，由于没有指定缓冲区大小，容易造成缓冲区溢出。</p></blockquote>

<p>写入一行函数，将一个以null符终止的字符串写入到指定流。尾端null不会被写入。</p>

<h2>二进制I/O</h2>

<p>对于直接I/O，也就是二进制I/O，提供两个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>size_t fread(void *ptr, size_t size, size_t nobj, FILE *fp);
</span><span class='line'>
</span><span class='line'>size_t fwrite(void * ptr, size_t size, size_t nobj, FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>这两个函数的常用用法：</p>

<ol>
<li>读或写一个二进制数组。比如将一个浮点数组的第2~5个元素写到一个文件上：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>float data[10];
</span><span class='line'>
</span><span class='line'>if (fwrite(&data[2], sizeof(float), 4, fp) != 4)
</span><span class='line'>  printf("error");</span></code></pre></td></tr></table></div></figure>


<ol>
<li>读写一个结构</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct {
</span><span class='line'>  
</span><span class='line'>  short count;
</span><span class='line'>  long total;
</span><span class='line'>  char name[NAMESIZE];
</span><span class='line'>
</span><span class='line'>} item;
</span><span class='line'>
</span><span class='line'>if (fwrite(&item, sizeof(item), 1, fp) != 1)
</span><span class='line'>  printf("error");
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
对于二进制读写的问题是：只能用于同一个系统上已写的数据，原因是：
1. 在同一个结构中，同一个成员的偏移量可能因为编译器和系统而异。
2. 用来存储多字节整数和浮点值的二进制格式，在不同机器体系结构不同。</p></blockquote>

<h1>定位流</h1>

<p>三种方法定位标准I/O流</p>

<ul>
<li>ftell和fseek，假设位置偏移量，可以使用长整型。</li>
<li>ftello和fseeko，文件偏移量，使用off_t代替长整型。</li>
<li>fgetpos和fsetpos，ISO C引入，使用抽象数据类型fpos_t来记录文件的位置。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>long ftell(FILE *fp); # 成功，返回当前文件位置指示，出错返回-1
</span><span class='line'>
</span><span class='line'>int fseek(FILE *fp, long offset, int whence);
</span><span class='line'>
</span><span class='line'>void rewind(FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>定位涉及到文本文件和二进制文件，由于存放格式不一样，里面许多注意点。</p>

<h2>对于二进制文件</h2>

<p>二进制文件，文件位置指示器是从文件起始位置开始度量，并以字节为计量单位。</p>

<p>ftell用于二进制文件时，其返回值就是这种字节位置。</p>

<p>为了使用fseek定位一个二进制文件，必须指定一个字节的<em>offset</em>。以及解释这种偏移量的方式。</p>

<p>whence的值与内核函数lseek函数相同：</p>

<ul>
<li>SEEK_SET表示从文件的起始位置开始</li>
<li>SEEK_CUR表示从当前文件位置开始</li>
<li>SEEK_END表示从文件尾端开始。</li>
</ul>


<h2>文本文件</h2>

<p>对于文本文件，他们的文件位置可能不以简单的字节偏移量来度量。主要是在非unix系统中，以不同格式存放文本文件。</p>

<p>为了定位文本文件，<em>whence</em>一定要是SEEK_SET，而<em>offset</em>的值只有两种：0（绕回到文件的起始位置）。或是对该文件调用ftell返回的值。</p>

<p>使用fewind可以将流设置到文件的起始位置。</p>

<h1>格式化I/O</h1>

<h2>scanf函数</h2>

<p>有以下几个scanf函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fscanf(FILE *stream, char const *format, ...);
</span><span class='line'>
</span><span class='line'>int scanf(char const *format, ...);
</span><span class='line'>
</span><span class='line'>int sscanf(char const *string, char const *format, ...);
</span></code></pre></td></tr></table></div></figure>


<p>这些函数都是从输入源中读取字符并根据format字符串给出的格式代码对他们进行转换。</p>

<p>fscanf输入源就是作为参数给出的流，scanf从标准输入读取，sscanf从第一个参数所给的字符串中读取字符。</p>

<p>读取停止条件：</p>

<ol>
<li>当格式化字符串到达末尾</li>
<li>读取的输入不再匹配格式字符串所指定的类型时</li>
</ol>


<p>返回结果是被转换的输入值的数据。</p>

<p>如果在任何输入值被转换之前文件就已经到达尾部，函数就返回常量值EOF。</p>

<blockquote><p>注意：
对于scanf函数的参数，前面需要使用<code>&amp;</code>。</p></blockquote>

<p>scanf函数族中的format字符串参数可能包含下面内容：</p>

<ul>
<li>空白字符————她们与输入中得零个或多个空白字符匹配，在处理过程中被忽略。</li>
<li>格式代码————她们指定函数如何解释接下来的输入字符。</li>
<li>其它字符————当任何其它字符出现在format字符串时，下一个输入字符必须与它匹配。如果匹配，该输入字符随后就被丢弃。如果不匹配，函数就不再读取直接返回。</li>
</ul>


<p>格式代码的结构是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%[*] [fldwidth] [lenmodifier]convtype</span></code></pre></td></tr></table></div></figure>


<p>针对上面的格式，解释如下：</p>

<ul>
<li>可选<code>*</code>字符：将使转换后的值被丢弃而不是进行存储</li>
<li>fldwith宽度：非负整数，它限制将被读取用于转换的输入字符的个数。如果没有给出宽度，函数就连续读入字符直到遇到输入中的下一个空白符。</li>
<li>lenmodifier限定符：用于修改有些格式代码的含义</li>
</ul>


<blockquote><p>对于限定符，说明：
限定符的目的是为了指定参数的长度。如果整型参数比缺省的整型值更短或更长时，在格式化代码中省略限定符就是一个常见的错误。
对于浮点型也是如此。
如果省略了限定符，可能导致一个较长的变量只有部分被初始化。或者一个较短变量的临近变量也被修改，这都取决于这些类型的相对长度。</p></blockquote>

<p>限定符作用到整型和浮点型的效果如下表：</p>

<table>
<thead>
<tr>
<th>格式代码        </th>
<th style="text-align:center;"> h           </th>
<th style="text-align:center;"> l  </th>
<th style="text-align:center;"> L</th>
</tr>
</thead>
<tbody>
<tr>
<td>d,i,n      </td>
<td style="text-align:center;"> short </td>
<td style="text-align:center;"> long </td>
<td style="text-align:center;">    空 </td>
</tr>
<tr>
<td>o,u,x      </td>
<td style="text-align:center;"> 无符号 short      </td>
<td style="text-align:center;">       无符号 long </td>
<td style="text-align:center;"> 空</td>
</tr>
<tr>
<td>e,f,g </td>
<td style="text-align:center;">     空  </td>
<td style="text-align:center;">    double </td>
<td style="text-align:center;">       long double</td>
</tr>
</tbody>
</table>


<p>转换符</p>

<p>看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nfields = fscanf(input, "%4d %4d %4d", &a, &b, &c)</span></code></pre></td></tr></table></div></figure>


<p>上面程序，宽度参数把整数值限制为4个数字或者更少的数字，如果是下面的输入：</p>

<p>1 2</p>

<p>则a的值是1，b的值是2，c没有改变。而nfields值为2.</p>

<p>如果是下面的输入：</p>

<p>12345 67890</p>

<p>则a的值是1234， <strong>b的值是5</strong>。c的值是6789，nfield的值是3。</p>

<p>转换符表格：</p>

<table>
<thead>
<tr>
<th>代码        </th>
<th style="text-align:center;"> 参数类型           </th>
<th style="text-align:left;"> 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c </td>
<td style="text-align:center;"> char *</td>
<td style="text-align:left;"> 读取和存储单个字符。如果给定了宽度，则读取和存储这个数目的字符（因此参数类型是char *），参数必须指向一个足够大的字符数组</td>
</tr>
<tr>
<td>i,d</td>
<td style="text-align:center;">int * </td>
<td style="text-align:left;"> 一个可选的有符号整数倍转换，d把输入解释为十进制；i根据它的第一个字符决定值的基数</td>
</tr>
<tr>
<td>u,o,x</td>
<td style="text-align:center;"> unsigned *</td>
<td style="text-align:left;"> 无符号，分别是u无符号十进制，o无符号八进制，x无符号十六进制</td>
</tr>
<tr>
<td>e，f，g</td>
<td style="text-align:center;"> float *</td>
<td style="text-align:left;">浮点数</td>
</tr>
<tr>
<td>s</td>
<td style="text-align:center;"> char * </td>
<td style="text-align:left;"> 字符串</td>
</tr>
<tr>
<td>p </td>
<td style="text-align:center;"> void * </td>
<td style="text-align:left;"> 指向void的指针。输入预期为一串字符，诸如那些有printf函数的%p格式代码所产生的输出。</td>
</tr>
<tr>
<td>n </td>
<td style="text-align:center;"> int * </td>
<td style="text-align:left;">到目前为止通过这个scanf函数的调用从输入读取的字符数被返回。%n转换的字符不被计算在内。它本身并不耗费任何输入。</td>
</tr>
<tr>
<td>% </td>
<td style="text-align:center;"> 无</td>
<td style="text-align:left;"> %</td>
</tr>
</tbody>
</table>


<h2>printf函数</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int fprintf(FILE *stream, char const *format, ...);
</span><span class='line'>
</span><span class='line'>int printf(char const *format, ...);
</span><span class='line'>
</span><span class='line'>int sprintf(char *buffer, char const *format, ...);
</span></code></pre></td></tr></table></div></figure>


<p>printf，结果输出送到标准输出，fprintf可以指定输出流。sprintf把结果作为一个NUL结尾的字符串存储到指定的buffer缓冲区中。</p>

<blockquote><p>注意：
sprintf有潜在的错误，缓存区大小不是一个参数，因此，如果输出结果长于缓冲区，会改写缓冲区后面的内存位置中得数据。</p></blockquote>

<p>printf中得format构成是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>%[flags] [fldwidth] [precision] [lenmodifier]convtype
</span></code></pre></td></tr></table></div></figure>


<h3>flags字符</h3>

<table>
<thead>
<tr>
<th>标志 </th>
<th> 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-   </td>
<td> 值在字段中左对齐，默认是右对齐</td>
</tr>
<tr>
<td>0   </td>
<td>当数值为右对齐时，却僧情况下使用空格填充左边未使用的列。使用这个标志，则用零来填充，它可用于d,i,u,o,x,X,e,E,f,g和G代码。</td>
</tr>
<tr>
<td>+   </td>
<td> 正值前有加号</td>
</tr>
<tr>
<td>空格</td>
<td> 只用于转换有符号值的代码。当值非负时，这个标志把一个空格添加到它开始的位置。注意这个标志和+互斥。</td>
</tr>
</tbody>
</table>


<p>代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; print '%0.5f' % 1.1
</span><span class='line'>1.10000
</span><span class='line'>&gt;&gt;&gt; print '%0.5d' % 1.1
</span><span class='line'>00001</span></code></pre></td></tr></table></div></figure>


<h3>fldwidth 宽度</h3>

<p>字段宽度是一个十进制整数，用于指定将要出现在结果中得最小字符数。如果字符数少于字段宽度，就对它进行填充以增加长度。flags字段决定填充
使用空白还是零。</p>

<h3>precision 精度</h3>

<p>精度字段以一个句点开头，后面跟着一个可选的十进制整数，如果没有给出，则精度为0.</p>

<ul>
<li>如果作用的是d、i、u、o、x和X类型转换符，精度字段指定将出现在结果中的最小数子个数。如果转换后的值的位数小于宽度，就在它签名插入零。如果值为零，精度也为零，则不输出数字。</li>
<li>如果作用于e，E和f类型转换符，精度决定将要出现在小数点后的数字位数</li>
<li>如果作用于s，精度指定将被转换的最多字符数。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(文件和目录)]]></title>
    <link href="http://baren.github.io/blog/2014/03/03/file-and-dir/"/>
    <updated>2014-03-03T23:06:23+08:00</updated>
    <id>http://baren.github.io/blog/2014/03/03/file-and-dir</id>
    <content type="html"><![CDATA[<h1>stat系列函数</h1>

<p>3个stat函数，位于sys/stat.h头文件中，其声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/stat.h&gt;
</span><span class='line'>
</span><span class='line'>int stat(const char *restrict path, struct stat *restrict buf);
</span><span class='line'>int lstat(const char *restrict path, struct stat *restrict buf);
</span><span class='line'>int fstat(int fildes, struct stat *buf);
</span></code></pre></td></tr></table></div></figure>


<p>stat函数返回path指定的文件信息，fstat与stat一样，只是接收fd作为参数。
lstat如果参数是符号链接，返回符号链接的信息，而不是返回符号链接引用的文件的信息。</p>

<p>结构体struct stat成员类型是基本系统数据类型（定义了某些与实现相关的数据），其中字段的定义位于sys/types.h中。</p>

<!-- more -->


<p>一般struct stat的定义是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dev_t     st_dev     Device ID of device containing file. 
</span><span class='line'>ino_t     st_ino     File serial number. 
</span><span class='line'>mode_t    st_mode    文件类型和mode（权限） 
</span><span class='line'>nlink_t   st_nlink   指向这个文件的链接数
</span><span class='line'>uid_t     st_uid     文件的uid. 
</span><span class='line'>gid_t     st_gid     文件的组id. 
</span><span class='line'>[XSI][Option Start]
</span><span class='line'>dev_t     st_rdev    Device ID (if file is character or block special). 
</span><span class='line'>[Option End]
</span><span class='line'>off_t     st_size    For regular files, the file size in bytes. 
</span><span class='line'>                     For symbolic links, the length in bytes of the 
</span><span class='line'>                     pathname contained in the symbolic link. 
</span><span class='line'>[SHM][Option Start]
</span><span class='line'>                     For a shared memory object, the length in bytes. 
</span><span class='line'>[Option End]
</span><span class='line'>[TYM][Option Start]
</span><span class='line'>                     For a typed memory object, the length in bytes. 
</span><span class='line'>[Option End]
</span><span class='line'>                     For other file types, the use of this field is 
</span><span class='line'>                     unspecified. 
</span><span class='line'>time_t    st_atime   Time of last access. 
</span><span class='line'>time_t    st_mtime   Time of last data modification. 
</span><span class='line'>time_t    st_ctime   Time of last status change. 
</span><span class='line'>[XSI][Option Start]
</span><span class='line'>blksize_t st_blksize A file system-specific preferred I/O block size for 
</span><span class='line'>                     this object. In some file system types, this may 
</span><span class='line'>                     vary from file to file. 
</span><span class='line'>blkcnt_t  st_blocks  Number of blocks allocated for this object. </span></code></pre></td></tr></table></div></figure>


<h1>mode_t    st_mode字段</h1>

<p>mode_t    st_mode成员包含：
 * 文件类型
 * 文件权限</p>

<h2>st_mode判断文件类型</h2>

<p>unix文件类型包括：</p>

<ul>
<li>普通文件、目录文件（stat.h中的宏S_ISREG()和S_ISDIR()判断）</li>
<li>块特殊文件，提供对设备（磁盘）带缓冲的访问，每次以固定长度为单位访问（S_ISBLK()）</li>
<li>字符特殊文件，提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备，要么是块特殊文件，要么是字符特殊文件。S_ISCHR()</li>
<li>FIFO，命名管道，用于进程间通信S_ISFIFO()</li>
<li>符号链接，S_ISLINK()</li>
</ul>


<h2>文件权限信息</h2>

<p>每个文件有9个权限位，分成三类：</p>

<ul>
<li>用户（读、写、执行）</li>
<li>组（读、写、执行）</li>
<li>其它（读、写、执行）</li>
</ul>


<p>chmod命令可以修改文件权限，其中u、g、o分别代表用户、组和其它。</p>

<p>可以使用宏来判断是否有某种权限：
* S_I(R|W|X)USR
* S_I(R|W|X)GRP
* S_I(R|W|X)OTH</p>

<h1>进程相关ID</h1>

<p>介绍进程相关ID，主要用于内核对进程进行权限验证使用。</p>

<p>进程相关联ID有6个或者更多：</p>

<ul>
<li>实际用户ID和组ID

<blockquote><p>标识究竟是谁，曲子登陆时口令文件的登陆项</p></blockquote></li>
<li>有效用户ID和组ID

<blockquote><p>内核使用这两个来进行权限验证；一般等于实际用户ID和实际组ID</p></blockquote></li>
<li>保存的设置用户（组）ID

<blockquote><p>执行一个程序时，保存了有效用户和组ID的副本，一般用在执行文件时，文件设置了set-user-id和set-group-id位时，保存有效用户ID和组ID
方便进程在两个用户之间切换权限
对于set-user-id和set-group-id位，stat结构体中的st_mode包含了这两位。
如果设置了文件的set-uid和set-gid，则进程的有效用户ID设置为文件的用户ID（组类似）</p></blockquote></li>
</ul>


<p>对文件的“设置用户ID”和“设置组ID”，可以使用S_ISUID和S_ISGID进行测试</p>

<h1>文件权限验证规则</h1>

<h2>对文件进行权限测试</h2>

<p>这几个文件权限，验证规则是：</p>

<ul>
<li>使用名字打开一个文件时，路径中的所有目录（包括隐含的当前目录），都应该具有执行权限（目录的执行权限位通常称为搜索位）

<blockquote><p>目录读权限和执行权限是不一样的，读权限允许读取目录中的文件列表。当一个目录是访问路径中的组成部分时，具有执行权限可通过该目录找到文件。</p></blockquote></li>
<li>文件读权限决定了我们可以打开文件进行读操作</li>
<li>文件写权限决定了我们可以打开文件进行写操作</li>
<li>如果open函数指定了O_TRUNC,必须具有写权限</li>
<li>删除一个文件，需对文件所在目录具有写和执行权限，对删除的文件本身，则不需要</li>
<li>6个exec函数中任何一个执行某个文件，都必须对文件有执行权限</li>
</ul>


<p>以上权限验证发生在每当进程打开、创建和删除一个文件时，内核就进行文件访问权限测试，这种验证涉及到</p>

<ul>
<li>文件所有者（st_uid, st_gid，属于文件性质）</li>
<li>进程有效ID（有效用户和组ID，属于进程性质）</li>
<li>进程附加组ID（如果支持，属于进程性质）</li>
</ul>


<h2>对进程进行权限测试</h2>

<ul>
<li>进程是超级用户（有效用户ID是0），允许访问</li>
<li>进程有效ID等于文件所有者ID，则进行上面的文件权限验证（若<em>所有者</em>适当的权限位被设置，则允许；否则拒绝）</li>
<li>进程有效组ID等于文件的组ID，则进行上面的文件权限验证（若<em>组</em>适当的权限位被设置，则允许；否则拒绝）</li>
<li>若文件其它用户适当权限位被设置，则允许；否则拒绝</li>
</ul>


<p>以上按顺序进行验证。</p>

<h1>以上，基本讲述了stat结构中的st_mode字段涉及到的知识。</h1>

<h1>文件所有权相关</h1>

<h2>新文件和目录所有权</h2>

<p>在对进程进行权限验证时，用到了文件的用户ID和组ID，这里讲一下，创建一个新文件，赋予文件的用户ID和组ID是什么。
创建文件夹和创建文件一样。</p>

<ul>
<li>新文件的用户ID设置为进程的有效用户ID</li>
</ul>


<p>对于组ID，可以选择下列之一作为组ID：</p>

<ul>
<li>新文件的组ID可以是进程的有效用户ID</li>
<li>新文件的组ID可以是它所在的目录的组ID</li>
</ul>


<blockquote><p>对于FreeBSD 和Mac OS X，使用的是目录组ID作为新文件的组ID
对于linux 2.4.22，新文件的组ID取决于它所在的目录的设置组ID是否设置，
如果设置组ID设置了，则为组ID，如果没设置，则为进程的有效组ID。</p></blockquote>

<h2>修改文件所有权</h2>

<p>下面这几个函数修改文件的用户ID和组ID</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int chown(const char *pathname, uid_t owner, gid_t group);
</span><span class='line'>int fchown(int filedes, uid_t owner, gid_t group);
</span><span class='line'>int lchown(const char * pathname, uid_t owner, gid_t group);
</span></code></pre></td></tr></table></div></figure>


<h2>access函数</h2>

<p>操作文件时，默认是按照进程的有效用户ID和有效组ID进行权限验证。也可以对进程实际用户ID和实际组ID进行验证，使用access函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int access(const char * pathname, int mode);</span></code></pre></td></tr></table></div></figure>


<p>其中，mode参数常量，取自unistd.h</p>

<p>R_OK 测试读权限
W_OK 测试写权限
X_OK 测试执行权限
F_OK 测试文件是否存在</p>

<h1>文件权限位相关</h1>

<h2>文件屏蔽字</h2>

<p>创建文件时，文件默认的权限是多少，是由文件屏蔽字来确定的。</p>

<p>文件屏蔽字是与文件模式一样的，只不多，屏蔽字的权限位为1的，创建文件时，文件的对应权限位为0（关闭对应权限）。</p>

<p>可以使用umask函数设置进程的文件屏蔽字</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/stat.h&gt;
</span><span class='line'>
</span><span class='line'>mode_t umask(mode_t cmask);
</span></code></pre></td></tr></table></div></figure>


<p>cmask是</p>

<ul>
<li>S_I(R|W|X)USR</li>
<li>S_I(R|W|X)GRP</li>
<li>S_I(R|W|X)OTH</li>
</ul>


<p>这九个常量的若干个按位“或”构成的。</p>

<p>对于屏蔽字，有以下几点：</p>

<ul>
<li>进程创建一个文件或目录时，一定会使用屏蔽字</li>
<li>对于任何屏蔽字中为1的位，文件相应的权限位一定会被关闭（即使在open、create函数中指定了响应权限位也会被关）</li>
</ul>


<p>同时，还需注意：</p>

<ul>
<li>unix系统一般不处理umask的值，在登陆是，有shell的启动文件设置一次，然后从不改变。</li>
<li>但是当创建文件时，如果想确保文件的某种权限，必须在运行时修改umask的值。</li>
<li>shell的umask命令可以查看和修改shell的umask的值</li>
<li>子进程修改屏蔽字的值，不影响父进程的屏蔽字的值</li>
</ul>


<p>shell的umask命令的值，三位八进制值，从左到右，分别代表用户、组和其它权限位。4表示读，2表示写，1表示执行。
三个权限经过“或”操作，最大值是7，表示读写执行权限都有。</p>

<p>最常用的是002、022和027等。</p>

<p>umask命令可以使用-S选项打印符号形式的屏蔽字。</p>

<h2>修改文件权限</h2>

<p>除了创建文件时，根据屏蔽字和指定的权限位为文件赋予特定权限外，还可以使用修改权限函数动态修改文件权限：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;sys/stat.h&gt;
</span><span class='line'>
</span><span class='line'>int chmod(const char *pathname, mode_t mode);
</span><span class='line'>int fchmod(int fileds, mode_t mode);
</span></code></pre></td></tr></table></div></figure>


<p>chmod中的mode参数取值于<code>sys/stat.h</code>中，除了上面那九种权限，还有两个设置ID常量（S_ISUID和S_ISGID）,保存正文常量（S_ISVTX）
以及三个组合常量（S_IRWX(U|G|O)），一共15种：</p>

<ul>
<li>S_I(R|W|X)(USR|GRP|OTH)
——九种</li>
<li>S_IRWX(U|G|O)  ——三种</li>
<li>S_ISUID，S_ISGID，S_ISVTX ——三种</li>
</ul>


<h2>粘住位</h2>

<p>如果一个执行文件设置了粘住位(sticky bit)，则该程序在第一次执行并结束时，其程序正文部分（机器指令部分）的一个副本仍被保存在交换区。</p>

<p>这样的好处是：</p>

<ul>
<li>该程序下次执行时，可快速装入内存。</li>
</ul>


<p>这么做的原因是：
* 交换区占用连续磁盘空间，可以认为是连续文件（而一般文件是分散放在磁盘各处的）
* 因此程序的正文也是连续存放的</p>

<p>粘住位也被称为<em>保存正文位（saved-text bit）</em>，因此也就有了S_ISVTX常量。</p>

<p>随着现代系统进化，这个粘住位的功能也被扩展了使用范围。</p>

<p>Single UNIX Specification允许设置目录的粘住位，如果对目录设置了粘住位，则只有对该目录具有写权限的用户，在满足下列条件之一时，才能
删除或更名该目录下的文件：</p>

<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>超级用户</li>
</ul>


<p>/tmp目录是设置粘住位的典型候选。</p>

<h1>文件长度</h1>

<p>结构体stat中，st_size表示的是文件长度，单位是字节，这个字段只对普通文件、目录文件和符号链接有意义。</p>

<p>对于文件大小：</p>

<ul>
<li>对于目录，文件长度通常是一个数（16或512）的倍数</li>
<li>对于符号链接，文件长度是文件名中的实际字节数，比如lib
&ndash;> usr/lib,lib的长度是7</li>
</ul>


<p>除了st_size字段外，还有st_blksize和st_blocks两个字段。其中：</p>

<ul>
<li>st_blksize：是读写这个文件的最佳的块大小，用这个块大小来读文件时，所用的时间最小，标准I/O也尝试一次读写st_blksize个字节。</li>
<li>st_blocks: 所分配的实际的512（系统依赖）的数量</li>
</ul>


<h2>文件空洞</h2>

<p>普通文件可以包含空洞，造成文件空洞的原因是：</p>

<ul>
<li>设置文件偏移量超过文件尾端</li>
<li>并写了数据</li>
</ul>


<p>这两个会导致文件空洞。</p>

<p>如果文件有空洞存在，则ll和du显示的文件大小是不一样的。</p>

<h1>文件截短</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int truncate(const char *pathname, off_t length);
</span><span class='line'>int ftruncate(int filedes, off_t length);
</span></code></pre></td></tr></table></div></figure>


<h1>link,unlink,remove和rename函数</h1>

<p>任何一个文件可以有多个目录项指向其i节点，创建一个指向现有文件的链接的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int link(const char *existingpath, const char *newpath);
</span></code></pre></td></tr></table></div></figure>


<p>这是创建一个硬链接的方法。</p>

<ul>
<li>link这个函数包括两个步骤：1），创建新目录项；2）增加链接计数，这两个操作原子操作</li>
<li>现在大多数的实现都不支持跨文件系统创建硬链接，也即这两个目录项应在同一个文件系统内</li>
<li>大部分实现也不支持创建目录的硬链接</li>
</ul>


<p>为了删除一个现有的目录项，使用unlink函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int unlink(const char *pathname); // 如果pathname是一个符号链接，则取消符号链接</span></code></pre></td></tr></table></div></figure>


<p>这个<code>unlink</code>函数删除此目录项，并将pathname所引用的文件的链接数减1.</p>

<p>当链接计数达到0，该文件内容才可被删除，若有进程打开了文件，即使其计数为0，内容也不能删除，进程退出后，才可删除。</p>

<p>关闭一个文件时，内核：</p>

<ul>
<li>先检查打开文件的进程数</li>
<li>若进程为0，再检查链接数，若为0，则删除</li>
</ul>


<h2>解释i节点、目录项等</h2>

<p>i-node节点包含了大部分文件信息，比如类型、权限什么的，单并没有包含文件名，因此</p>

<p>一个普通文件，具有 ：一个i-node项，一个目录项（包含文件名和i-node编号）和n个数据块。
如图：</p>

<p><img src="http://baren.github.io/images/assets/file.png" title="file system file detail" alt="alt text" /></p>

<p>一个目录，则包含一个数据块，其数据库实际上是一个目录块，目录块中包含目录下的文件的目录项信息（目录项包括i节点和文件名）
如图：
<img src="http://baren.github.io/images/assets/dir.png" title="file system dir detail" alt="alt text" /></p>

<h1>符号链接</h1>

<p>符号链接是指向一个文件的间接指针，主要是避开硬链接的一些限制：</p>

<ul>
<li>硬链接要求链接和文件位于一个文件系统中</li>
<li>只有超级用户才能创建指向目录的硬链接</li>
</ul>


<p>符号链接则无此限制。</p>

<blockquote><p>注意：
当使用以名字引用文件的函数时，应当了解函数是否处理符号链接，也就是是否会自动跟随符号链接到达它所指向的文件。
若open函数参数是一个符号链接，open会跟随符号链接到达指向的文件，若符号链接指向的文件不存在，则返回错误。</p></blockquote>

<p>创建一个符号链接：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int symlink(const char *actualpath, const char *sympath);</span></code></pre></td></tr></table></div></figure>


<p>open函数打开文件时，会跟随符号链接，若想打开符号链接本身，则使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);</span></code></pre></td></tr></table></div></figure>


<p>解除一个符号链接，可以使用unlink函数。因为unlink不跟随符号链接。</p>

<h1>文件时间</h1>

<p>与文件相关的三个时间值：</p>

<ul>
<li>st_atime. 文件数据的最后访问时间 比如read函数
， ls命令用-u选项查看</li>
<li>st_mtime。文件数据的最后修改时间 比如write函数， ls的默认选项就是查看这个时间</li>
<li>st_ctime。文件i节点状态的最后更改时间 比如chmod，chown函数， ls的-c选项查看这个时间</li>
</ul>


<h1>utime函数</h1>

<p>对文件访问和修改时间，可以用utime函数进行修改</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int utime(const char *pathname, const struct utimebuf * times);
</span><span class='line'>
</span><span class='line'>struct utimebuf{
</span><span class='line'>time_t actime; /*访问时间*/
</span><span class='line'>time_t modtime; /*修改时间*/
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
utime并不修改st_ctime时间，当调用utime时，会自动更新</p></blockquote>

<h1>目录相关</h1>

<h2>mkdir和rmdir函数</h2>

<p>mkdir创建目录，rmdir删除目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int mkdir(const char *pathname, mode_t mode);
</span><span class='line'>int rmdir(const char *pathname);</span></code></pre></td></tr></table></div></figure>


<p>对于mkdir，常见的错误是忘记设置其执行权限位，以便能访问目录中的文件名。
rmdir函数只删除空目录，空目录只包含.和..两个目录</p>

<blockquote><p>注意：
创建目录时，目录的用户ID和组ID与文件创建时的规则一样。</p></blockquote>

<h2>读目录</h2>

<ul>
<li>对目录具有访问权限的用户都可读目录</li>
<li>但只有内核才能写目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不代表能否写目录本身</li>
</ul>


<p>虽然目录的实际格式依赖于具体文件系统的实现。但posix.1定义了读目录的相关接口，一般系统实现都组织read函数读目录内容</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;dirent.h&gt;
</span><span class='line'>
</span><span class='line'>DIR *opendir(const char *pathname);
</span><span class='line'>
</span><span class='line'>struct dirent *readdir(DIR * dp);
</span><span class='line'>int clostdir(DIR *dp)</span></code></pre></td></tr></table></div></figure>


<p>dirent.h中定义的dirent结构与实现相关，但至少会包含下列两个成员：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct dirent{
</span><span class='line'>ino_t d_ino;  /*i-node数*/
</span><span class='line'>char d_name[NAME_MAX+1];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，NAME_MAX依赖于具体实现，并没有规定一个常量。</p>

<p>opendir函数返回的指向DIR结构的指针，由另外其它函数使用。
opendir执行初始化操作，使第一个readdir读目录中的第一个目录项，目录项的顺序与实现有关，通常不按照字母顺序排列。</p>

<h2>工作目录</h2>

<p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。</p>

<p>进程可以通过chdir和fchdir函数更改当前工作目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int chdir(const char *pathname);
</span><span class='line'>int fchdir(int fd);</span></code></pre></td></tr></table></div></figure>


<p>当前工作目录是进程的一个属性，所以调用chdir只影响当前进程本身，不影响其它进程。</p>

<p>内核保持有当前工作目录的信息，按理应该能取其当前值，但是，内核为进程保存了指向该目录v节点的指针等目录信息，并不保存完整的路径名。</p>

<p>有个函数提供了获取工作目录的功能：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>char *getcwd(char *buf, size_t size);</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linxu 文件系统笔记]]></title>
    <link href="http://baren.github.io/blog/2014/02/10/linux-file-system/"/>
    <updated>2014-02-10T19:33:17+08:00</updated>
    <id>http://baren.github.io/blog/2014/02/10/linux-file-system</id>
    <content type="html"><![CDATA[<h1>设备特殊文件</h1>

<p>设备可以划分成两种类型：</p>

<ul>
<li>字符设备。一个字符一个字符的处理数据，终端和键盘就是例子。</li>
<li>块设备。一次处理一块数据。块大小依赖于设备类型。一般都是512字节的倍数。磁盘就是这种设备。</li>
</ul>


<!-- more -->


<h2>设备ID</h2>

<p>每一个设备文件都有一个主ID号和副ID号。主ID号标记设备的一般类型，内核使用这个主ID来寻找这种类型设备对应的驱动。副ID号唯一的标记这个设备类型下得特殊设备了。ls -l可以显示主ID和副ID</p>

<h1>磁盘和分区</h1>

<ul>
<li>一个磁盘可以分成多个分区。</li>
<li>信息都放在磁盘的磁道上，磁道被划分成扇区，每一个扇区都由一系列的物理块组成。物理块的大小一般时512或者其倍数个字节，代表了最小的信息单元。</li>
</ul>


<h2>分区</h2>

<p>一个分区可以包含以下信息：</p>

<ul>
<li>文件系统，也即每个分区可以包含一个文件系统</li>
<li>数据区域</li>
<li>swap区域</li>
</ul>


<h1>文件系统</h1>

<p>linux支持广泛的文件系统，包括
* 传统的ext2文件系统
* 原生的unix文件系统，包括 Minix, System V和 BSD文件系统
* 微软的FAT, FAT32, 和 NTFS
* apple的HFS
* 网络文件系统，包括sun的NFS等
* 一系列日志文件系统，包括xt3, ext4, Reiserfs, JFS, XFS, 和 Btrfs</p>

<p>以ext2文件系统为例，介绍文件系统，ext2文件系统源代码很小，大约5000行c程序（<a href="http://e2fsprogs.sourceforge.net/ext2.html.%EF%BC%89">http://e2fsprogs.sourceforge.net/ext2.html.%EF%BC%89</a></p>

<h2>文件系统结构</h2>

<p>磁盘分成多个逻辑分区，每一个分区可拥有一个文件系统，比如：
<img src="http://baren.github.io/images/assets/Figure14-1.png" title="layout of disk partitions and a file system" alt="alt text" /></p>

<ul>
<li>boot块，总是文件系统的第一个块，文件系统不会使用这个块，boot块是用来重启操作系统的。虽然每个分区的文件系统都有一个boot块，但只有一个会被使用。</li>
<li><p>superblock，紧随boot块后的一个单一块，包含如下信息</p>

<blockquote><ul>
<li>i-nod表的大小</li>
<li>此文件系统的逻辑块大小</li>
<li>文件系统的大小</li>
</ul>
</blockquote></li>
<li><p>inode表。文件系统的每一个文件或者目录都在inode表中对应一个唯一的表项。这个表项记录了文件的各种信息。</p></li>
<li>数据块，磁盘的最主要的文件数据存储区域。</li>
</ul>


<h2>i-node</h2>

<p>对于所有的文件系统内的文件，文件系统的i-node表都有一个唯一的i-node表项与之对应。i-node使用i-node在表中的顺序号来引用（数组实现？）。
<em>i-node number</em>是ls -li命令的第一个字段.</p>

<p>i-node包含的信息有：</p>

<ul>
<li>文件类型，比如目录、普通文件、符号链接等</li>
<li>拥有者</li>
<li>所属组</li>
<li>访问权限</li>
<li>三个文件相关时间（最后读时间、最后修改内容时间和最后修改i-node时间）</li>
<li>指向这个文件的硬链接数</li>
<li>文件大小</li>
<li>分配的块数</li>
<li>指向数据块的指针</li>
</ul>


<h2>ext2的i-node的数据块指针</h2>

<p>为了满足一下需求：</p>

<ul>
<li>i-node结构是固定大小的，同时又文件大小是任意的（因此，i-node的数据指针是任意的）</li>
<li>允许文件的数据库不是连续存储的，同时又允许文件数据任意的通过lseek()访问</li>
</ul>


<p>基于以上几点，ext2设计了i-node的指针结构:</p>

<p><img src="http://baren.github.io/images/assets/Figure14-2.png" title="Structure of file blocks for a file in an ext2 file system" alt="alt text" /></p>

<p>每一个i-node包含十五个pointer。前12个指针指向文件数据块的前十二个块。下一个指针指向一个指针块，指针块中指针的个数依赖块的大小。
每个指针需要4个字节，如果块大小是1024字节，则存放256个指针，如果是4096字节，则存放1024个指针。
为了能容纳更大数据，第13个指针，是一个双重间接指针（double indirect pointer），它指向一个指针块，块中的指针又指向一个指针块。
如果需要真正大的文件，还可以使用最后一个triple-indirect pointer。</p>

<p>这样设计的一个好处是，允许文件存在黑洞。对于具有hole的文件，他可以仅仅把指针赋值为0，而不需要为其分配数据位null的块。</p>

<h1>虚拟文件系统（vfs）</h1>

<p>linux支持各种文件系统，文件系统实现各不一样，但是对文件的操作，不会涉及到具体的文件系统实现，而是可以跨文件系统的。这是因为linux定义了一个抽象层，各种文件系统需要实现的。一般称为Virtual File System（vfs）。</p>

<p>vfs是linux的内核特征，定义一个抽象的文件操作层，也就是一系列操作文件的接口。一般包括：open(), read(), write(), lseek(), close(), truncate(), stat(), mount(), umount(), mmap(), mkdir(), link(), unlink(), symlink(), and rename().</p>

<p>如图所示：</p>

<p><img src="http://baren.github.io/images/assets/Figure14-3.png" title="he virtual file system" alt="alt text" /></p>

<h1>日志文件系统（ournaling File Systems）</h1>

<p>ext2文件系统是典型的传统unix文件系统的例子，也遭受经典的这种文件系统的限制：当down机后，在重启后需要进行一致性检查，来确保文件系统的完整性。这是因为，当系统崩溃时，文件系统的更新有可能只完成了部分操作。文件系统的元数据，包括目录下，i-node信息和数据库指针，可能会处于不一致状态。
如果不进行修复，文件系统会进一步被破坏。</p>

<p>但是一致性检查需要扫描所有文件，如果文件系统很大，花费时间也会大。</p>

<p>日志文件系统消除了当系统挂了后的漫长的一致性检查。日志文件系统在进行实际的操作时，先把更新的元数据记录到一个日志文件的磁盘文件中。
写入元数据到日志文件是事务性写入相关的数据。一旦系统崩溃，在重启后，只需要快速的重做未完成的更新，是系统进入一个一致性状态。</p>

<p>这有个缺点是延长了更新文件的时间。</p>

<p>linux的日志文件系统包括：</p>

<ul>
<li>Reiserfs是第一个整合到linux内核的日志文件系统（2.4.1）。</li>
<li>ext3是在ext2上增加了日志功能的系统。</li>
<li>JFS系统是IBM开发的，在2.4.20上整合到内核</li>
<li>ext4，在2.6.19加入到内核</li>
<li>Btrfs，通常发音是butter FS。提供了一些现代的系统功能。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型和对象(PER4 chapter 3)]]></title>
    <link href="http://baren.github.io/blog/2014/02/10/per4-chapter3-type-and-object/"/>
    <updated>2014-02-10T19:33:16+08:00</updated>
    <id>http://baren.github.io/blog/2014/02/10/per4-chapter3-type-and-object</id>
    <content type="html"><![CDATA[<h1>对象身份和类型</h1>

<p>内置函数 <em>id()</em> 以整数的方式返回对象的身份。这个整数通常指的是内存的位置，但并不保证，这依赖于实现。</p>

<p><em>is</em> 操作符用来比较两个对象的<em>身份</em>的。</p>

<p><em>type()</em> 返回对象的类型。</p>

<p>使用例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># Compare two objects </span>
</span><span class='line'><span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># a和b是同样的对象，也就是身份相同 </span>
</span><span class='line'>        <span class="n">statements</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># a和b具有同样的值，身份可以不一样，只要值一样 </span>
</span><span class='line'>        <span class="n">statements</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'>      <span class="c"># a和b具有同样的类型 </span>
</span><span class='line'>      <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>对象的类型：</p>

<p>对象的类型本身就是一个对象。这个类型对象被称为对象的类。这个类型对象是被唯一定义的，并且给定类型的所有实例的类型都是一样的。因此类型对象之间进行比较，可以使用操作符 <em>is</em> 进行比较。</p>

<p>所有的类型对象都赋予一个名字，可以用来进行类型检查。大多数这种名字都是内置的，比如list、dict等。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
</span><span class='line'>  <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
</span><span class='line'>  <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个比较好的判断类型的方式是使用内置的<code>isinstance(object, type)</code>函数，因为这个函数是可以识别继承的。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
</span><span class='line'>  <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
</span><span class='line'>  <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>引用计数和垃圾回收</h1>

<p>所有的对象都是引用计数的。</p>

<p>只要把对象赋给一个新名字，或者存放在容器中（list、dict等），都会使引用数增加。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">37</span> <span class="c"># Creates an object with value 37 </span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="c"># Increases reference count on 37 </span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c"># Increases reference count on 37</span>
</span></code></pre></td></tr></table></div></figure>


<p>当a赋值给b的时候，值为37的对象的引用数加1；当b存放在容器c中，值为37的对象的引用数加1.</p>

<p>整个例子中，只有一个对象保存了37的值，其它的操作仅仅是创建了一个新的指向这个对象的引用。</p>

<p>这就是引用计数的概念。在考虑引用计数，一定要记住，所有都是对象。</p>

<p>还可以通过操作来减少引用，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">del</span> <span class="n">a</span> <span class="c"># Decrease reference count of 37 </span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span> <span class="c"># Decrease reference count of 37 </span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="c"># Decrease reference count of 37</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以通过函数来查看对象的引用情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">37</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="mi">7</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
</span><span class='line'><span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<p>当对象的引用计数到0的时候，就会被垃圾回收。</p>

<p>对于循环引用，其引用计数不为零，但是已经不被使用的对象，解释器会定期执行循环引用检查。发现就会回收。</p>

<h1>引用和拷贝</h1>

<p>拷贝分浅拷贝和深拷贝。</p>

<p>copy模块提供了浅拷贝和深拷贝操作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="n">Return</span> <span class="n">a</span> <span class="n">shallow</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">x</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="n">Return</span> <span class="n">a</span> <span class="n">deep</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">x</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>浅拷贝和深拷贝的区别只与组合对象相关（包含其它对象的对象，比如list等）</p>

<ul>
<li>浅拷贝构建了一个新的组合对象，然后把从原对象中发现的引用插入到新组合对象中</li>
<li>深拷贝构建了一个新的组合对象，然后递归的把原对象的拷贝插入到新对象中</li>
</ul>


<p>浅拷贝创建一个引用，包含的元素是原对象包含的元素的引用。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span>
</span><span class='line'><span class="bp">False</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">100</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">100</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>对dict的浅拷贝，可以使用 dict.copy()，对于list的浅拷贝，可以使用<code>copied_list = original_list[:]</code></p>

<p>深拷贝可以使用copy模块下的deepcopy函数实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">copy</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="c"># Notice that a is unchanged [1, 2, [3, 4]]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个类想定义自己的浅拷贝和深拷贝实现，可以实现特殊方法<code>__copy__() and __deepcopy__()</code>。前者是在浅拷贝的时候调用（copy.copy(x)）。后者是在深拷贝的时候调用(copy.deepcopy(x))。</p>

<h1>第一类对象</h1>

<p>第一类对象是指可以在执行期创造并作为参数传递给其他函数或存入一个变量的实体。一般第一类对象具有的特征是：</p>

<ul>
<li>可以被存入变量或其他结构</li>
<li>可以被作为参数传递给其他函数</li>
<li>可以被作为函数的返回值</li>
<li>以在执行期创造，而无需完全在设计期全部写出</li>
</ul>


<p>在python中，所有的对象都是第一类对象。</p>

<p>所有对象都是第一类对象的好处是可以写出很紧凑简洁的代码。</p>

<h1>表示数据的内置类型</h1>

<p>略</p>

<h1>表示程序结构的内置类型</h1>

<h2>可调用类型</h2>

<p>可调用类型表示对象支持函数调用操作。包括用户定义函数，内置函数、实例方法和<strong>类</strong>。</p>

<h3>用户定义函数</h3>

<p>在模块级别创建的，通过def或者lambda操作符创建的用户定义的函数，是可调用的对象。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></code></pre></td></tr></table></div></figure>


<p>用户定义函数的属性包括：</p>

<table>
<thead>
<tr>
<th>描述        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>f.<em> </em>dict_ _ </td>
<td style="text-align:center;"> 包含函数属性的dict</td>
</tr>
<tr>
<td>f.<em> </em>defaults_ _ </td>
<td style="text-align:center;"> 包含默认参数的元组</td>
</tr>
</tbody>
</table>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="o">.</span><span class="n">__defaults__</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>用户定义的函数的类型是<code>types.FunctionType</code></p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">types</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span>
</span><span class='line'><span class="bp">True</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span>
</span><span class='line'><span class="bp">False</span>
</span></code></pre></td></tr></table></div></figure>


<h3>方法</h3>

<p>方法是定义在类内部的函数。有三种方法：</p>

<ul>
<li>实例方法——对对象实例上操作的函数</li>
<li>类方法——类本身作为一个对象，类方法是在类本身操作的函数</li>
<li>静态方法——仅仅是个函数，不接收类本身或类的实例作为参数</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="c"># 实例方法，第一个参数self</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">instance_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span class='line'>      <span class="n">statements</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># 类方法， 第一个参数cls</span>
</span><span class='line'>  <span class="nd">@classmethod</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">class_method</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
</span><span class='line'>      <span class="n">statements</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># 静态方法，没有self或cls的参数</span>
</span><span class='line'>  <span class="nd">@staticmethod</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">static_method</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
</span><span class='line'>      <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p>实例方法和类方法都由types.MethodType来表示。</p>

<p>详细了解对象查询属性操作（.）是如何工作的，对理解这种特殊类型是有好处的。</p>

<p>在一个对象上查询什么（.）与函数调用总是分开的，当调用方法时，两个操作都会发生，只是步骤差别。</p>

<ol>
<li>在实例上查询</li>
</ol>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">f</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span> <span class="c"># 创建一个实例</span>
</span><span class='line'>
</span><span class='line'><span class="n">meth</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">instance_method</span> <span class="c"># 查询方法，注意，后面没有括号&quot;()&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">meth</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span> <span class="c"># 现在调用函数</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面例子中，meth被称为<strong>绑定方法</strong>。绑定函数是一个可调用对象，它包括了函数（method）和相关的实例。</p>

<p>当调用绑定函数时，相关实例会作为第一个参数传递给函数（self）。</p>

<ol>
<li>在类上查询</li>
</ol>


<p>接上面例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">umeth</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="n">instance_method</span> <span class="c"># 在Foo上查询instance_method</span>
</span><span class='line'>
</span><span class='line'><span class="n">umeth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">37</span><span class="p">)</span> <span class="c"># 明确提供self，并且调用</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，umeth被称为未绑定方法。未绑定方法只包含了方法函数，但是需要明确传递正确类型的实例对象作为第一个参数。</p>

<p>在这个例子中，传了Foo的实例f作为第一个参数。</p>

<p>对用户定义的类，绑定方法和未绑定方法都是作为types.MethodType的对象。</p>

<p>下面是方法对象的属性</p>

<table>
<thead>
<tr>
<th>描述        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.<strong>class</strong> </td>
<td style="text-align:center;"> 函数定义的类</td>
</tr>
<tr>
<td>m.<strong>func</strong> </td>
<td style="text-align:center;"> 实现方法的函数对象</td>
</tr>
<tr>
<td>m.<strong>self</strong> </td>
<td style="text-align:center;"> 与方法相关的实例，如果没有，返回None</td>
</tr>
</tbody>
</table>


<h3>内置函数和方法</h3>

<p>对象types.BuiltinFunctionType用来描述用c或c++实现的函数和方法。属性和上面类似。</p>

<h3>类和实例作为可调用对象</h3>

<p>类对象和实例也可以作为可调用对象。一个类对象被<code>class</code>创建，可以作为一个函数来调用，用来创建类的实例。这种情况下，传递的参数会传递给<strong>init</strong>方法中，用来初始化实例对象。</p>

<p>如果一个实例实现了<strong>call</strong>方法，那么这个实例也可以模拟函数调用。如果对象x定义了<strong>call</strong>函数，那么x(args)会调用x.<strong>call</strong>(args)。</p>

<h2>类、类型和实例</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python词法约定和语法(PER4 chapter 2)]]></title>
    <link href="http://baren.github.io/blog/2014/02/08/per4-chapter2-lexical-conventions-and-syntax/"/>
    <updated>2014-02-08T10:33:00+08:00</updated>
    <id>http://baren.github.io/blog/2014/02/08/per4-chapter2-lexical-conventions-and-syntax</id>
    <content type="html"><![CDATA[<h1>行结构和缩进</h1>

<p>python中，每一行用换行符来结束，如果一行太长，可以使用<em>行继续操作符“\”</em>来分割，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">n</span><span class="p">))</span> <span class="o">+</span> \
</span><span class='line'>  <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>在(&hellip;), [&hellip;], {&hellip;}, &ldquo;&rdquo;&ldquo;&hellip;&rdquo;&ldquo;&#8221;和&#8217;&lsquo;&rsquo;&hellip;&lsquo;&rsquo;&lsquo;之间的代码，如果跨越多行，可以不用这个操作符。</p>

<p>如果函数、条件、循环或者类的代码体只有一行语句，可以放在同一行中，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="n">a</span><span class="p">:</span> <span class="n">statement1</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>   <span class="n">statement2</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果多个语句放在一行，可以使用&#8221;;&ldquo;来分割。</p>

<!-- more -->


<h1>标识符</h1>

<ul>
<li>以下划线开头的标识符是不会被导入语句<code>from module import *</code>导入的。</li>
<li>前后有两个下划线的标识符（比如<code>__init__</code>），是为特殊方法保留的。</li>
<li>前面有两个下划线的标识符（比如<code>__bar</code>），为了实现私有的类成员。</li>
</ul>


<h1>数字字面量</h1>

<p>有四种数字类型：</p>

<ul>
<li>布尔</li>
<li>整数</li>
<li>浮点数</li>
<li>复数</li>
</ul>


<p>作为布尔值的True和False被解释成1和0.</p>

<p>除了十进制，还可以把整数指定为八进制、十六进制和二进制，分别用前缀0、0x和0b（比如：0644, 0x100fea8, or 0b11101010）</p>

<p>python的整数没有限制，可以任意写。</p>

<h1>字符串字面量</h1>

<p>字符串字面常量使用单引号（&#8217;）、双引号（&#8221;）或者三个引号（&#8217;&lsquo;&#8217;或者&#8221;&ldquo;&#8221;）括起来。</p>

<p>在字面常量内，反斜线（\）字符可以被用来特殊字符比如换行，反斜线自己，引号和不能打印的字符。如果转义字符不能识别，则保留原样。</p>

<p>除了\r \n等常用的转移字符外，几个不常用的列到下：</p>

<ul>
<li>\OOO              八进制值，后面三个数字。（\000 到 \377，\377的十进制值是255）</li>
<li>\uxxxx            Unicode字符，x是十六进制字符（\u0000到\uffff）</li>
<li>\Uxxxxxxxx        Unicode字符（\U00000000到\Uffffffff）</li>
<li>\xhh              十六进制值（\x00到\xff，\xff的值是255）</li>
</ul>


<p>\OOO和\xhh的用法是在字符串内嵌入不能够容易的打出的字符（控制字符，不能打印字符，符号和国际化字符等）。比如：</p>

<p>如果写字符串“Jalapeño”，可以&#8221;Jalape\xf1o&#8221; \xf1就是字符ñ。</p>

<p>在python 2中，字符串字面量对应的是8-bit的字符或者说面向字节的数据。为了能够使用国际化字符集，需要在字符串前面前缀一个字符“u”</p>

<p>不管使用哪种字符串，可以使用\u或者\U来嵌入一个国际化字符到字符串中。</p>

<p>原始字符串，在字符串前缀一个“r”字符。原始字符串中，所有的反斜线字符串都不转义，原样保存。这种字符串，多用在正则表达式中。</p>

<p>如果一个字符串前缀既有u又有r，则r必须在u之后。比如<code>ur"\\u1234"</code></p>

<p>注意：</p>

<blockquote><p>当使用utf-8和utf-16对字符串字面量进行编码时，不能够使用原始的byte的数据，比如直接写一个utf-8编码的字符串字面量&#8217;Jalape\xc3\xb1o&#8217;，以为简单的表示9个字符。
但是实际上可能不是想的那样。因为在utf-8编码中，多个byte序列\xc3\xb1表示单一字符U+00F1。而不是这两个字符U+00C3 和 U+00B1。
为了能让这样的字符串进行编码，需要在字符串前面前缀一个字符“b”，比如：b&#8221;Jalape\xc3\xb1o&#8221;。</p>

<p>正常情况下，很少用到这种（byte literals）字符串字面常量</p></blockquote>

<h1>文档字符串</h1>

<p>模块、类和函数的第一行语句是个字符串，那这个字符串变成这个对象的文档字符串。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>  <span class="s">&quot;This function computes a factorial&quot;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">fact</span><span class="o">.</span><span class="n">__doc__</span>
</span><span class='line'><span class="n">This</span> <span class="n">function</span> <span class="n">computes</span> <span class="n">a</span> <span class="n">factorial</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h1>源代码编码</h1>

<p>为了让python的源代码以不同的编码方式编码，需要在源代码的前面两行包含：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python </span>
</span><span class='line'><span class="c"># -*- coding: UTF-8 -*-</span>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Jalapeño&quot;</span> <span class="c"># String in quotes is directly encoded in UTF-8.</span>
</span></code></pre></td></tr></table></div></figure>


<p>当这样指定后，注释、字符串字面量，可以直接在识别unicode的编辑器中输入。但是其它的，包括标识符，都必须是ascii的字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程凭据(chapter 9 linux programming interface)]]></title>
    <link href="http://baren.github.io/blog/2014/01/26/chapter-9-linux-programming-interface/"/>
    <updated>2014-01-26T10:33:32+08:00</updated>
    <id>http://baren.github.io/blog/2014/01/26/chapter-9-linux-programming-interface</id>
    <content type="html"><![CDATA[<p>每一个进程，都有一组与之关联的数字的用户ID和组ID。有时候这些ID被成为进程凭据（process credentials），这些ID包含：</p>

<ul>
<li>实际用户ID和实际组ID</li>
<li>有效用户ID和有效组ID</li>
<li>保存的设置用户ID和保存的设置组ID</li>
<li>文件系统用户ID和组ID（linux特定的）</li>
<li>补充组ID（supplementary group IDs）</li>
</ul>


<!-- more -->


<h2>实际用户ID和实际组ID</h2>

<p>实际用户和组ID标记了进程属于哪个用户或者组ID。其值是登陆用户的id和组id。作为登陆进程的一部分，shell读取登陆口令中的用户ID和组ID。同时在shell执行的程序会继承这个实际用户ID和组ID。</p>

<h2>有效用户ID和有效组ID</h2>

<p>在大多数的Unix实现中，当进程执行这种操作时，有效用户id和有效组id加上补充的组id（supplementary group IDs）联合起来决定进程所具有的权限（linux稍微不同）。</p>

<ul>
<li>如果进程有效用户ID是0（root的id），拥有所有超级用户权限。这种进程被称为特权进程，许多系统进程只能被特权进程调用</li>
<li>正常情况下，进程有效用户id和有效组id与实际用户id和实际组id是一样的。</li>
</ul>


<p>有两种方式可以修改进程的有效用户（组）id：</p>

<ul>
<li>通过系统调用。</li>
<li>执行set-user-ID和set-group-ID的程序。</li>
</ul>


<h2>set-user-ID和set-group-ID的程序</h2>

<p>通过把进程的有效用户id和有效组id设置为可执行文件的用户id和组id，可以使进程拥有正常情况下没有的权限。</p>

<p>一般文件，除了表示文件拥有关系的用户id和组id外，还有两个特殊的权限位：<em>set-user-ID</em> 和 <em>set-group-ID</em>。可以通过chmod来修改这两个位：</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># ls -l prog
</span><span class='line'>-rwxr-xr-x 1 root root 
</span><span class='line'># chmod u+s prog  打开set-user-ID权限位
</span><span class='line'># chmod g+s prog  打开set-group-ID权限位
</span><span class='line'># ls -l prog
</span><span class='line'>-rwsr-sr-x 1 root root 302585 Jun 26 15:05 prog</span></code></pre></td></tr></table></div></figure>


<p>修改密码程序passwd，mount和Unmount等都设置色set-user-id权限位。</p>

<h2>保存的Set-User-ID和保存的Set-Group-ID</h2>

<p>保存的Set-User-ID和保存的Set-Group-ID被设计成让设置了Set-User-ID和Set-Group-ID的程序用的。执行步骤：
1. 如果执行文件的Set-User-ID和Set-Group-ID权限位被设置了。则进程有效用户id和有效组id改成改文件的用户id和组id。如果这个权限位没有设置，则没有任何改变。
2. 保存的Set-Group-ID和保存的Set-User-ID值，拷贝自进程的有效用户id和有效组id。不管Set-User-ID和Set-Group-ID权限位设不设置，拷贝过程都会执行。</p>

<p>如果一个进程的实际用户id、有效用户id和保存的设置用户id都是1000.当它执行了一个root拥有的set-user-ID的程序，执行后，进程的实际、有效和保存的设置用户id分别是：</p>

<p>1000、0、0</p>

<p>许多系统调用允许set-user-ID的程序在实际用户id和保存用户id之间进行切换。这时，程序可以临时性的获取或者抛弃与可执行文件相关联的用户id的特殊权限。这是一种安全的编程实践。</p>

<h2>文件系统用户id和文件系统组id</h2>

<p>在linux系统上，操作文件的权限，不是根据进程的有效用户（组）id来确定的，而是根据文件系统的用户（组）id判断，其它操作，仍然用有效用户（组）id来进行权限判断。</p>

<p>正常情况下，文件系统用户（组）id与进程的有效用户（组）id是一样的。当进程的有效用户（组）id被修改时，不管是通过系统调用或者是通过执行set-user（group）-ID的程序，文件系统的用户（组）id也会跟着修改成同样的值。这意味着，linux与其它unix的实现，在行为上市一致的，除了在明确调用setfsuid() and setfsgid()两个系统调用的时候。</p>

<p>由于在表现上，文件系统用户（组）id与进程有效的用户id和组id是一样的，因此虽然在底层，操作文件时，linux是用文件系统的用户（组）id来判断权限的，我们只关心进程的有效用户（组）id即可。</p>

<h2>补充的组ids（Supplementary Group IDs）</h2>

<p>补充的组ids是一个额外的进程所属于的组的集合。</p>

<p>新进程会从父进程中继承这些组ids。一个登录shell进程从系统组文件（system group file）获取其补充组ids。这些ids与有效用户（组）id来检查进程的操作权限。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux文件io进一步描述]]></title>
    <link href="http://baren.github.io/blog/2013/12/30/fileio-further-details/"/>
    <updated>2013-12-30T13:15:19+08:00</updated>
    <id>http://baren.github.io/blog/2013/12/30/fileio-further-details</id>
    <content type="html"><![CDATA[<h2>原子性和条件竞争</h2>

<p>所有系统调用都是原子执行的。原子执行避免了条件竞争。所谓条件竞争，指的是两个进程，在共享资源上操作，产生的结果依赖于两个进程的执行顺序。</p>

<h3>排他性创建文件</h3>

<p>在调用open系统调用函数时，如果文件存在，则如果指定O_EXCL和O_CREAT会导致open失败。这就为进程提供了一种确保是他创建了文件的方式。
如果没有这个选项，则一般是先检查文件存在不存在，如果不存在，就创建一个文件。由于是check-if-absent方式，产生条件竞争。</p>

<!-- more -->


<h3>追加文件内容</h3>

<p>如果多个进程往一个文件中追加数据（比如一个全局日志文件），通常的做法是lseek到文件末尾，然后write，比如：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;lseek&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> 
        <span class="n">fatal</span><span class="p">(</span><span class="s">&quot;Partial/failed write&quot;</span><span class="p">);</span></code></pre></div>


<p>这也产生了条件竞争。</p>

<p>解决这个问题的方法，就是使用open函数的O_APPEND设置。</p>

<h2>fcntl()文件控制操作</h2>

<p>函数定义：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;fcntl.h&gt;</span>
    <span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span></code></pre></div>


<h3>获得打开文件的状态标记（flag）</h3>

<p>open函数的定义是：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span></code></pre></div>


<p>使用fcntl系统调用，可以获取文件或者修改文件的状态标记（标记的值是在open时由参数设置的）。</p>

<p>比如下面代码：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">accessMode</span><span class="p">;</span>
<span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span> <span class="cm">/* Third argument is not required */</span> 
<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span></code></pre></div>


<p>获得flags后，可以检查是否具有某种标记：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_SYNC</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;writes are synchronized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></code></pre></div>


<p>但是，对于O_RDONLY (0), O_WRONLY (1), and O_RDWR (2)，使用上面这种方式判断就不行（O_RDONLY的值是0，怎么&amp;，都是0；写功能，两个值wronly和rdwr都具有写功能，读功能，rdonly和rdwr都具有读功能）。</p>

<p>为了判断，可以使用O_ACCMODE(3),比如下面代码：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">accessMode</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">accessMode</span> <span class="o">==</span> <span class="n">O_WRONLY</span> <span class="o">||</span> <span class="n">accessMode</span> <span class="o">==</span> <span class="n">O_RDWR</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;file is writable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></code></pre></div>


<p>还可以使用F_SETFL来修改已打开文件的标记。可修改的标记为：O_APPEND, O_NONBLOCK, O_NOATIME, O_ASYNC, and O_DIRECT，试图修改其它会被忽略。</p>

<p>设置标记的办法是先获取标记，再设置，比如：</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>
<span class="n">flags</span> <span class="o">|=</span> <span class="n">O_APPEND</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span></code></pre></div>


<h2>文件描述符和打开文件的关系</h2>

<p>内核维护的三个数据结构：</p>

<ul>
<li>一个进程一个文件描述符表(<a href="http://en.wikipedia.org/wiki/Array_data_structure">Array data type</a>)</li>
<li>系统级别的打开的文件描述符的表</li>
<li>文件系统的i-node表</li>
</ul>


<p>对于每一个进程，内核都维护了这个进程打开的文件描述符表。每一个表项包含的信息是：</p>

<ul>
<li>控制操作文件描述符的标记集。其实就是一个标记close-on-exec</li>
<li>一个指向打开的文件描述符（存储在open file table中的记录，也就是系统级别的打开的文件描述符的表项）的引用。</li>
</ul>


<p>内核维护了一个系统级别的所有的打开文件描述符（通常叫做<em>open file table</em>，其表项一般被称做open file handles）的表。
一个打开文件描述符存储了关于打开文件的所有信息，包括：</p>

<ul>
<li>当前文件的偏移（read()和write()会更新这个值，或者通过lseek()指定）</li>
<li>当打开文件指定的状态标记（比如open()函数的flags参数）</li>
<li>文件访问模式（read-only，write-only或者read-write）</li>
<li>一个指向这个文件的i-node对象的引用</li>
</ul>


<blockquote><p> #include &lt;sys/stat.h></p>

<p> #include &lt;fcntl.h></p>

<p> int open(const char <em>pathname, int flags, &hellip; /</em> mode_t mode */);</p>

<table>
<thead>
<tr>
<th>Access mode </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY    </td>
<td style="text-align:center;"> Open the file for reading only</td>
</tr>
<tr>
<td>O_WRONLY    </td>
<td style="text-align:center;"> Open the file for writing only</td>
</tr>
<tr>
<td>O_RDWR      </td>
<td style="text-align:center;"> Open the file for both reading and writing</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>File creation flags </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_CLOEXEC    </td>
<td style="text-align:center;"> Set the close-on-exec flag (since Linux 2.6.23)</td>
</tr>
<tr>
<td>O_CREAT      </td>
<td style="text-align:center;"> Create file if it doesn’t already exist </td>
</tr>
<tr>
<td>O_DIRECT     </td>
<td style="text-align:center;"> File I/O bypasses buffer cache</td>
</tr>
<tr>
<td>O_DIRECTORY  </td>
<td style="text-align:center;"> Fail if pathname is not a directory </td>
</tr>
<tr>
<td>O_EXCL       </td>
<td style="text-align:center;"> With O_CREAT: create file exclusively </td>
</tr>
<tr>
<td>O_LARGEFILE  </td>
<td style="text-align:center;"> Used on 32-bit systems to open large files </td>
</tr>
<tr>
<td>O_NOATIME    </td>
<td style="text-align:center;"> Don’t update file last access time on read() (since Linux 2.6.8) </td>
</tr>
<tr>
<td>O_NOCTTY     </td>
<td style="text-align:center;"> Don’t let pathname become the controlling terminal </td>
</tr>
<tr>
<td>O_NOFOLLOW   </td>
<td style="text-align:center;"> Don’t dereference symbolic links </td>
</tr>
<tr>
<td>O_TRUNC      </td>
<td style="text-align:center;"> Truncate existing file to zero length </td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th> file status flags </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_APPEND    </td>
<td style="text-align:center;"> Writes are always appended to end of file</td>
</tr>
<tr>
<td>O_ASYNC    </td>
<td style="text-align:center;"> Generate a signal when I/O is possible</td>
</tr>
<tr>
<td>O_DSYNC     </td>
<td style="text-align:center;"> Provide synchronized I/O data integrity (since Linux 2.6.33)</td>
</tr>
<tr>
<td>O_NONBLOCK      </td>
<td style="text-align:center;"> Open in nonblocking mode</td>
</tr>
<tr>
<td>O_SYNC      </td>
<td style="text-align:center;"> Make file writes synchronous</td>
</tr>
</tbody>
</table>
</blockquote>

<p>每一个文件的i-node包含的信息有：</p>

<ul>
<li>文件类型（正常文件、socket或者FIFO）和文件权限</li>
<li>一个指向加在这个文件上的锁列表的指针</li>
<li>各种文件属性，包括文件大小，和不同操作相关的时间。</li>
</ul>


<blockquote><p>i-node在磁盘上的描述和在内存中的描述不一样。如果在磁盘上，则记录了一个文件的持久化属性。比如类型、大小和权限等。
i-node在内存的描述，记录了打开的文件描述符指向这个i-node节点的数目、这个i-node所在的磁盘的主要（major）和次要（minor）的ID，还记录的一些短暂的属性，比如加在文件上的锁等。</p></blockquote>

<p>如图：
<img src="http://baren.github.io/images/assets/Figure5-2.png" title="Relationship between file descriptors, open file descriptions, and i-nodes" alt="alt text" /></p>

<p>根据上面描述，得出下面几个隐含的意思来：</p>

<ul>
<li>两个不同的文件描述符引用同一个文件，则他们共享同一个文件偏移量。</li>
<li>同样规则也适用于使用fcntl()函数获取或者修改文件状态标记（上面表格中的file status flags,比如O_APPEND, O_NONBLOCK, O_ASYNC）</li>
<li>文件描述符标记（close-on-exec）则是私有的，修改它不会影响到其他的。</li>
</ul>


<h2>dup文件描述符</h2>

<p>使用shell的I/O重定向语法 <em>2>&amp;1</em> 时，会通知shell，我们想要标准错误输出，输出到与标准输出到同一个地方。shell是从左到右计算I/O导向的。因此，下面的shell：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./myscript &gt; results.log 2&gt;&1
</span></code></pre></td></tr></table></div></figure>


<p>会将标准输出输出到与标准输出同一个位置，也即results.log。</p>

<p>为了实现这个效果，使用dup和dup2两个函数。</p>

<blockquote><p>如果不使用这两个函数，简单的打开results.log两次，一次使用文件描述符1，一次使用文件描述符2.这是不够的。因为从上面图可以看出，打开两次文件，这两个文件描述符并不共享同一个文件的offset，因此两个会相互覆盖。另一个原因是打开文件不一定是磁盘文件，比如$ ./myscript  2>&amp;1 | less</p></blockquote>

<p>下面是dup的声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int dup(int oldfd);
</span></code></pre></td></tr></table></div></figure>


<p>dup函数接收一个已经打开的文件描述符oldfd，返回一个指向同一个文件的新的文件描述符。如果失败，则返回-1.返回的新的文件描述符保证使用最小的未使用的文件描述符。</p>

<p>为了实现上面shell的命令，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*前提是文件描述符0已经被使用*/
</span><span class='line'>close(2);
</span><span class='line'>int newfd = dup(1)
</span></code></pre></td></tr></table></div></figure>


<p>为了方便实现这个功能，还有个dup2函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int dup2(int oldfd, int newfd);
</span></code></pre></td></tr></table></div></figure>


<p>dup2函数使用给定的newfd来复制已经打开的旧的文件描述符oldfd。返回的是新的文件描述符。</p>

<p>还可以使用fcntl函数来完成dup命令，保证使用的新文件描述符大于等于指定的文件描述符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>newfd = fcntl(oldfd, F_DUPFD, startfd);</span></code></pre></td></tr></table></div></figure>


<p>这在保证在特定范围内dup文件描述符是有用的。</p>

<h2>pread()和pwrite()在指定offset进行I/O操作</h2>

<p>使用pread和pwrite，可以在指定的offset完成读和写操作，而不会影响文件的原始offset的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>/*返回读得字节数，如果到EOF，为0；如果错误，返回-1*/
</span><span class='line'>ssize_t pread(int fd, void *buf, size_t count, off_t offset);
</span><span class='line'>
</span><span class='line'>/*返回写入的字节数，-1表示错误*/
</span><span class='line'>ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>使用pread和pwrite函数，传入的文件描述符必须是可seek的。</p>

<p>注意：
使用pread和pwrite在多线程环境下，可以避免条件竞争。如果使用lseek、write这种方式写文件，会产生条件竞争。使用pwrite，则多个线程会避免条件竞争。</p></blockquote>

<h2>Scatter-Gather I/O: readv() 和 writev()</h2>

<p>readv和writev函数定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/uio.h&gt;
</span><span class='line'>
</span><span class='line'>ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
</span><span class='line'>
</span><span class='line'>ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
</span></code></pre></td></tr></table></div></figure>


<p>与read只读取数据到一个buffer不同，readv可以一次性把读取的数据分散（scatter）到多个buffer中。iov是一个数组，数组的每个元素是一个结构，结构类型是struct iovec。buffer的个数有iovcnt指定。</p>

<p>struct iovec的定义是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct iovec {
</span><span class='line'>  void *iov_base; /* 缓存的起始地址 */
</span><span class='line'>  size_t iov_len; /* Number of bytes to transfer to/from buffer */
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<p>下图描述了iov参数和iovcnt参数的关系：
<img src="http://baren.github.io/images/assets/Figure5-3.png" title="Relationship between readv iov and iovcnt parameter" alt="alt text" /></p>

<h3>分散输入（scatter input）</h3>

<p>readv系统调用完成了<em>scatter input</em>，读取由fd指定的文件的持续的字节序列，然后顺序的把这些数据写入到由iov参数指定的buffer中。所有的这些buffer，从iov[0]开始，会被完全的写满之后，才会继续写入下一个buffer。</p>

<p>注意：
一个readv的重要的属性是，这些都是完全自动的。从调用者角度，内核会把一连续的字节序列写入到buffer中。意味着，如果从一个文件中读取数据时，能够确保读入的数据是连续的，即使在这其间，有其它线程试图修改同一个文件的offset，也不会影响。</p>

<p>readv返回读取的数据的字节数。调用者需要自己检查一下。</p>

<h3>聚集输出（gather output）</h3>

<p>writev系统调用完成了<em>gather output</em>。参数意义与readv类似。</p>

<p>与write一样，writev也可能只写入部分，因此需要检查是否请求的数据全部被写入了。</p>

<h3>writev和readv的原因</h3>

<p>主要原因还是</p>

<pre><code>1. 易用性
2. 性能
</code></pre>

<p>使用场景，比如：
    * 如果需要调用一系列的write函数来输出buffer数据时</p>

<h2>截断一个文件truncate()和ftruncate()</h2>

<p>截断一个文件，两个函数定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int truncate(const char *pathname, off_t length); 
</span><span class='line'>
</span><span class='line'>int ftruncate(int fd, off_t length);</span></code></pre></td></tr></table></div></figure>


<p>这两个函数不会对文件的offset有影响。</p>

<h2>非阻塞I/O</h2>

<p>当打开一个文件，指定O_NONBLOCK标记时，主要有两种目的：</p>

<ul>
<li>如果文件不能立即被打开，open()函数会返回错误，而不是一直阻塞着。</li>
<li>如果open()打开成功，随后的I/O操作仍然是非阻塞的。</li>
</ul>


<p>非阻塞模式可以用于设备、FIFO（命名管道，用于Linux进程通信）、socket。由于管道和socket的文件描述符
不能够通过open()获得，因此我们必须使用 fcntl() F_SETFL操作来使这个标记可用。</p>

<p>注意：</p>

<blockquote><p>O_NONBLOCK对于普通文件是忽略的。因此linux的内核的buffer确保了普通文件的I/O是非阻塞的。</p></blockquote>

<h2>I/O大文件</h2>

<p>linux使用off_t数据类型来存储文件的offset，off_t使用有符号的长整型来描述（之所以有符号，是方便用-1表示失败）。
因此在32位机器上，一个文件的最大限制是2<sup>31</sup>-1 byte。</p>

<p>为了在32位机器上实现大文件操作，厂商提供了Large File Summit (LFS)概念。linux自从2.4开始支持LFS。为了支持大文件，文件系统也需要支持。大部分linux文件系统都支持（微软的VFAT and NFSv2都不支持）</p>

<p>为了在linux操作大文件，有两种方法：</p>

<ul>
<li>采用支持大文件的替换的API，也就是ransitional LFS API。</li>
<li>在编译我们代码时，定义宏_FILE_OFFSET_BITS的值为64.这种方式是推荐的方式。</li>
</ul>


<h3>使用LSF API</h3>

<p>采用过渡的LFS API时，在编译时，需要测试_LARGEFILE64_SOURCE的宏（命令行或者源文件）。这组API可以处理64位的文件大小和offset。这组api的函数名字后面都有64.比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fopen64(), open64(), lseek64(), truncate64(), stat64(), mmap64(), and setrlimit64()</span></code></pre></td></tr></table></div></figure>


<h3>使用_FILE_OFFSET_BITS</h3>

<p>推荐的方式是定义_FILE_OFFSET_BITS宏的值为64.
这会自动的替换32位函数和数据类型到64位的函数和数据类型。这意味这，我们可以重新编译以前写好的文件来支持大文件。</p>

<p>只遗留了一个问题，就是打印off_t 的值的时候，需要使用lld%来正确的显示off_t的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define _FILE_OFFSET_BITS 64
</span><span class='line'>
</span><span class='line'>off_t offset; /* Will be 64 bits, the size of 'long long' */ 
</span><span class='line'>
</span><span class='line'>/* Other code assigning a value to 'offset' */
</span><span class='line'>printf("offset=%lld\n", (long long) offset);</span></code></pre></td></tr></table></div></figure>


<h2>/dev/fd 目录</h2>

<p>对于每一个进程，内核提供了一个虚拟目录/dev/fd ，这个目录包含的文件形式是<em>/dev/fd/n</em>。n对应的进程中的打开的文件描述符。因此使用/dev/fd/n或者fd都可以指向一个文件。</p>

<p>但是在程序内很少使用这种方式，一般只在shell中使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FiFe I/O 通用的I/O模型]]></title>
    <link href="http://baren.github.io/blog/2013/12/23/the-universal-io-model/"/>
    <updated>2013-12-23T14:36:16+08:00</updated>
    <id>http://baren.github.io/blog/2013/12/23/the-universal-io-model</id>
    <content type="html"><![CDATA[<h2>总述</h2>

<p>所有完成IO的系统调用，都是使用文件描述符（file descriptor）来引用一个文件。文件描述符用来引用打开的所有类型文件，包括管道、socket、设备等。每个进程都有自己的文件描述符集。</p>

<p>根据惯例，大多数的应用程序都希望打开三个标准的文件描述符（标准输入、输出和错误）。这三个文集描述符，一般是由在程序启动之前启动的shell程序打开的。</p>

<table>
<thead>
<tr>
<th> 文件描述符        </th>
<th style="text-align:center;"> POSIX 名称（在unistd.h头文件中定义）           </th>
<th style="text-align:right;"> 描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td> 0      </td>
<td style="text-align:center;"> STDIN_FILENO </td>
<td style="text-align:right;"> 标准输入 </td>
</tr>
<tr>
<td> 1     </td>
<td style="text-align:center;"> STDOUT_FILENO      </td>
<td style="text-align:right;">   标准输出 </td>
</tr>
<tr>
<td> 2 </td>
<td style="text-align:center;"> STDERR_FILENO     </td>
<td style="text-align:right;">    标准错误 </td>
</tr>
</tbody>
</table>


<p>在程序中，既可以使用数字，也可以使用posix的名称来指向这几个文件描述符。</p>

<p>下面是四个关键的完成IO的系统调用：
* fd = open(pathname, flags, mode) 。通过制定flags参数，open函数既可以打开文件，也可以创建文件。如果创建文件，mode参数用来指定创建文件的访问权限。如果不是用来创建文件，可以忽略mode这个文件。SUSv3规定，如果open成功，他保证使用这个进程的最小的没有使用的文件描述符。
* numread = read(fd, buffer, count)。读取fd引用的文件，最多读取count个字节，返回的是实际读取的字节数，如果到了文件末尾，返回0。
* numwritten = write(fd, buffer, count)。从buffer中，写入count个字节数据到fd所指向的文件中。返回的是实际写入的字节数，有可能小于count。
* status = close(fd) 。释放文件描述符，以及相关的内核资源</p>

<!-- more -->


<h2>I/O通用性</h2>

<p>所谓通用性，是指这四个函数可以作用于所有的类型文件，来完成IO操作。这些文件包括管道、设备、socket等。</p>

<p>如果需要使用特定类型文件特有的功能，可以使用ioctl系统调用，它提供了所有通用功能以外的特定功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux最大文件描述符设置]]></title>
    <link href="http://baren.github.io/blog/2013/12/17/linux-open-max-fd-num/"/>
    <updated>2013-12-17T14:36:20+08:00</updated>
    <id>http://baren.github.io/blog/2013/12/17/linux-open-max-fd-num</id>
    <content type="html"><![CDATA[<p>在linux中，所有都是文件，也就是说一个连接也是一个文件。每打开一个文件，内核会分配一个文件描述符，因此一个进程可打开的最大文件描述符决定了可支持的最大连接数。这是一个重要的参数。</p>

<p>linux有两个限制：</p>

<pre><code>1、系统级限制。限制了整个系统可打开的最大文件描述符

2、每个进程的限制。一个应用可打开的最大文件描述符
</code></pre>

<!-- more -->


<p>对于系统限制，可以通过这个查看：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>cat /proc/sys/fs/file-max
131072
<span class="nv">$ </span>cat /proc/sys/fs/file-nr 
<span class="m">510</span>     <span class="m">0</span>       131072</code></pre></div>


<p>其中，file-nr返回结果意思是：
    510，已打开的文件句柄
    0，已分配但是没有用的文件句柄
    131072，系统支持最大的文件句柄数</p>

<p>其中，系统支持的最大的文件句柄数还可以用</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">cat /proc/sys/fs/file-max（或者sysctl fs.file-max）</code></pre></div>


<p>来查看。</p>

<p>修改系统限制，可以这样修改：</p>

<p>修改文件/etc/sysctl.conf 中的</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">fs.file-max <span class="o">=</span> 100000</code></pre></div>


<p>一行，保存后，让用户重新登录一下，即可永久生效；或者执行sysctl -p命令。</p>

<p>对于用户级限制，可以通过下面命令查看：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">ulimit</span> -Hn
65536

<span class="nv">$ </span><span class="nb">ulimit</span> -Sn
20240</code></pre></div>


<p>其中，
-H是硬限制. -S是软限制。区别是软限制，任何进程都可以修改，但是硬限制，只允许root权限用户修改。</p>

<p>如果要修改默认的用户级限制，可以编辑文件/etc/security/limits.conf
比如：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># End of file</span>
    * soft nproc 20240
    * hard nproc 16384
    * soft nofile 20240
    * hard nofile 65536</code></pre></div>


<p>解释如下：
第一列的意思是设置针对哪些用户生效，* 表示针对所有用户，但是，它不包含root，因此，如果要对root用户有效，需要增加root用户，也就是后面两行。</p>

<p>第二列，要么是soft，要么是hard，hard只允许root修改，soft允许普通用户修改，最大是hard设定的值。</p>

<p>第三列，包含了要被限制的资源的类型。nofile表示打开的文件数，nproc表示进程数。</p>

<p>第四列，表示设置的值。</p>

<p>临时设置：</p>

<p>如果不想永久设置，还可以使用下面命令临时设置：</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">ulimit</span> -n 65536</code></pre></div>


<p>这样，只影响当前登录用户，下次重新登录后失效</p>
]]></content>
  </entry>
  
</feed>
