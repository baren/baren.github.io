<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Baren Blog]]></title>
  <link href="http://baren.github.io/atom.xml" rel="self"/>
  <link href="http://baren.github.io/"/>
  <updated>2015-03-30T20:49:23+08:00</updated>
  <id>http://baren.github.io/</id>
  <author>
    <name><![CDATA[enwu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[yield（generator和coroutine）]]></title>
    <link href="http://baren.github.io/blog/2015/03/22/python-yield/"/>
    <updated>2015-03-22T15:32:01+08:00</updated>
    <id>http://baren.github.io/blog/2015/03/22/python-yield</id>
    <content type="html"><![CDATA[<p>主要介绍python中yield的用法。在python中，与yield关键字相关的语法有generator和coroutine，这里会分别介绍这两种语法。</p>

<!-- more -->


<h1>generator</h1>

<p>一个函数，正常情况下，会返回一个值，但是generator，返回的是值的序列，而不是一个值。在python中，用yield来实现，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Counting down from </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>        <span class="k">yield</span> <span class="n">n</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&#39;after yield&#39;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数内使用yield关键字的函数，跟普通函数不一样，函数的调用并不会执行函数体，而是返回一个generator对象，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># 没有执行第一行的print语句</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">countdown</span> <span class="n">at</span> <span class="mh">0x10695ba00</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>要想执行函数体，可以使用</p>

<ul>
<li>generator的next()函数或者</li>
<li>for语句，sum()或者其它消费集合的操作。</li>
</ul>


<h2>next()函数</h2>

<p>generator的调用过程：</p>

<ol>
<li>当在generator上调用next()函数，会执行函数体，直到遇到yield关键字。然后</li>
<li>yield生成一个值，</li>
<li>并且在这点，函数被挂起，直到下一个next()函数调用。然后，</li>
<li>函数继续从yield语句后面执行。</li>
</ol>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">countdown</span> <span class="n">at</span> <span class="mh">0x10695ba00</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<p>当generator返回时（return），迭代停止，这时候，再调用next()函数，抛出StopIteration异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'><span class="ne">StopIteration</span>
</span></code></pre></td></tr></table></div></figure>


<h2>迭代generator</h2>

<p>还可以使用for语句迭代generator，比如：</p>

<p>for n in countdown(10):
    print n</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">n</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="mi">9</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="o">.</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="n">after</span> <span class="n">yidle</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>停止generator</h2>

<p>停止一个generator，通过：</p>

<ul>
<li>return语句返回</li>
<li>抛出一个StopIteration异常</li>
</ul>


<p>如果generator停止了，继续调用next()函数，会抛出StopIteration异常。</p>

<h2>close()函数</h2>

<p>为了防止一个generator没有停止，提供了close()函数来主动停止generator，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span><span class='line'>        <span class="k">break</span>
</span><span class='line'>    <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面程序中，for循环在生成2的时候停止了，这时候countdown并没有完全执行完成，当生成器不再调用时，调用close关闭它。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Counting</span> <span class="n">down</span> <span class="kn">from</span> <span class="mi">10</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</span><span class='line'><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
</span><span class='line'>  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
</span><span class='line'><span class="ne">StopIteration</span>
</span></code></pre></td></tr></table></div></figure>


<p>在generator内部，close函数调用会导致在yield语句上抛出GeneratorExit异常，因此可以在generator内部捕获这个异常，来做一些清理工作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Counting down from </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>            <span class="k">yield</span> <span class="n">n</span>
</span><span class='line'>            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Only made it to </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>协程和yield表达式</h1>

<h1>参考资料</h1>

<ol>
<li><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">http://www.dabeaz.com/coroutines/Coroutines.pdf</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0342/">https://www.python.org/dev/peps/pep-0342/</a></li>
<li><a href="http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/">http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/</a></li>
<li>python essential reference chapter 5</li>
<li><a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python/231855#231855">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python/231855#231855</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared libraries简介]]></title>
    <link href="http://baren.github.io/blog/2014/12/08/process-ipc/"/>
    <updated>2014-12-08T19:55:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/12/08/process-ipc</id>
    <content type="html"><![CDATA[<p>本篇主要说明进程间通信，也就是IPC（interProcess Communication）。UNIX系统IPC是各种进程通信方式的统称。这里主要讲PIPE和FIFO两种进程间通信的方式。</p>

<h1>PIPE</h1>

<p>PIPE是UNIX一开始就支持的进程间通信的方式，有以下限制：</p>

<ul>
<li>半双工的，通道的一端，要么写，要么读，不能支持读和写两个操作（虽然现代系统有的支持全双工，但是不可移植）</li>
<li>管道是字节流，这意味着没有消息块或者消息边界的概念。可以读或者写任意大小的数据。</li>
<li>使用PIPE进行进程通信的条件是“只能在具有公共祖先的进程之间使用”</li>
<li>PIPE的容量是有限的。PIPE的实现实际上就是内核在内核空间开辟了一块内存，因此是有容量限制的。一旦空间满了，后续写入的就会被阻塞。</li>
</ul>


<h2>创建和使用管道</h2>

<p>使用这个函数创建一个pipe。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数会通过参数filedes返回两个文件描述符。一个filedes[0]用来读，一个filedes[1]用来写。</p>

<p>因为是文件描述符，因此可以使用read()和write()系统调用来完成正常的I/O操作。</p>

<p>为了实现进程间通信，需要在调用pipe函数之前，调用fork来创建子进程，图示：</p>

<p><img src="http://baren.github.io/images/assets/pipe-1.png" title="linux" alt="alt text" /></p>

<p>典型例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">filedes</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;pipe&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
</span><span class='line'>    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fork&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">case</span> <span class="mi">0</span><span class="o">:</span>  <span class="cm">/* Child */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* Child now reads from pipe */</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span> <span class="cm">/* Parent */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* Parent now writes to pipe */</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>管道在不使用的时候需要关掉，这对正确使用管道来说是非常必要的。</p>

<p>当管道的一端关闭后，下列两条规则起作用：</p>

<ul>
<li>当读一个写端已被关闭的管道时，在所有数据被读取后，read返回0，表示到达文件末尾。</li>
<li>如果写一个读端已关闭的管道，则产生信号SIGPIPE，如果忽略或者捕捉改信号并从其处理程序返回，则write返回-1，errno设置为EPIPE。</li>
</ul>


<h2>与shell打交道的popen()函数</h2>

<p>常见的操作是创建一个管道连接到另一个进程，然后读其输出或向其输入端发送数据，为此，标准IO库提供了两个函数popen和pclose</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="n">FIFE</span> <span class="o">*</span><span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdstring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="n">FIFE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>FIFO</h1>

<p>FIFO被称为命名管道，PIPE只能是具有共同祖先的进程之间的通信。通过FIFO，不相关进程也可以通信。</p>

<p>FIFO是一种文件类型，可以通过stat结构成员st_mode来指示是否是FIFO类型，可以用宏S_ISFIFO对此进行测试。</p>

<p>创建一个FIFO：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;sys/stat.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数mode与open函数的mode相同。</p>

<p>一旦创建了FIFO文件，就可以用open打开，一般的文件I/O函数（close、write、read、unlink）都可用。</p>

<p>当打开一个FIFO时，非阻塞标志（O_NONBLOCK）产生下列影响：</p>

<ul>
<li>如果没有指定O_NONBLOCK，只读open要阻塞到某个其它进程为写而打开此FIFO。类似，只写open要阻塞到某个其他进程为读而打开。</li>
<li>如果指定了O_NONBLOCK，则只读open立即返回。但是如果没有进程已经为读而打开一个FIFO，则open将出错并返回-1，error是ENXIO。</li>
</ul>


<p>FIFO有两种用途：</p>

<ul>
<li>FIFO由shell命令使用，以便将数据从一条管道线传送到另一条，为此无需创建中间临时文件</li>
<li>FIFO用于客户进程-服务器进程应用程序中。</li>
</ul>


<p>FIFO可以被用于复制串行管道命令之间的输出流，于是也就不需要写数据到中间磁盘文件。管道只能用于进程间的<em>线性连接</em>。因为FIFO具有名字，因此可以用于非线性连接。</p>

<p>比如：</p>

<pre><code>            |-------------&gt;prog3
            |
</code></pre>

<p>输入文件&mdash;&ndash;> prog1
                |
                |&mdash;&mdash;&mdash;&mdash;->prog2</p>

<p>实现这种过程，而不需要使用临时文件，可以使用FIFO以及tee命令（tee程序将其标准输入同时复制到其标准暑促以及其命令行中包含的文件名中）。</p>

<p>mkfifo  fifo1
prog3 &lt; fifo1 &amp;
prog1 &lt; infile | tee fifo1 | prog2</p>

<h1>XSI IPC</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared libraries简介]]></title>
    <link href="http://baren.github.io/blog/2014/11/19/shared-libraries/"/>
    <updated>2014-11-19T21:09:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/11/19/shared-libraries</id>
    <content type="html"><![CDATA[<p>共享库是把库函数放到一个单元里，在运行时供多个进程共享的一种技术。可以节省磁盘空间和内存。</p>

<p>主要讲静态链接和动态链接。</p>

<!-- more -->


<h1>目标库（Object Libraries）</h1>

<p>平常，编译一个程序，就是用gcc，后面罗列这所有用到的单个文件来生成一个可执行程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -c prog.c mod1.c mod2.c mod3.c
</span><span class='line'>$ cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o</span></code></pre></td></tr></table></div></figure>


<p>缺点：
* 需要在后面指定大量文件，在生产环境不适用</p>

<p>为了避免这个问题，可以把一些共用对象文件归到一个单一单元中，叫做目标库（object library）。</p>

<p>目标库（object library）有两种类型：静态（static）的和共享（shared）的。相对来说，共享的更现代，也更具有优点。</p>

<h1>静态库（static library）</h1>

<p>静态库也叫archive，是unix最开始的库类型。优点：</p>

<ul>
<li>可以把预先编译好的文件放到一个单元中，避免了每次编译</li>
<li>简化了链接命令</li>
</ul>


<h2>创建静态库</h2>

<p>使用ar命令来生成静态库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ar options archive object-file...</span></code></pre></td></tr></table></div></figure>


<h2>使用静态库</h2>

<p>两种使用静态库的方式：</p>

<ol>
<li>直接放到link的命令行里：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -c prog.c
</span><span class='line'>$ cc -g -o prog prog.o libdemo.a
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>静态库放到标准目录（比如/usr/lib）中，在命令行中使用“–l”选项：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -o prog prog.o -ldemo
</span></code></pre></td></tr></table></div></figure>


<p>如果静态库没有在标准目录中，可以指定目录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cc -g -o prog prog.o -Lmylibdir -ldemo</span></code></pre></td></tr></table></div></figure>


<h2>缺点</h2>

<ul>
<li>浪费内存，每个进程都会存有一份静态库的副本。</li>
<li>如果静态库中的某个文件变动了，所有依赖这个静态库的程序，都需要重新编译。</li>
</ul>


<h1>共享库（Shared Libraries）</h1>

<p>共享库解决了静态库的缺点，核心是所有依赖这个库的进程都共享同一份程序内存。当第一个依赖这个库程序运行时，会把这个库加载到内存；其它依赖这个库的程序运行时，它就已经加载到内存了。</p>

<p>优点：</p>

<ul>
<li>由于程序小了，因此加载程序时快了</li>
<li>库不是拷贝到每个进程，因此节省了内存</li>
</ul>


<p>不利点：</p>

<ul>
<li>比静态库复杂</li>
<li>共享库必须被编译成位置无关代码（position-independent code）</li>
<li>Symbol relocation必须在运行时定位，因此要稍微慢一点比静态库</li>
</ul>


<h1>创建和使用共享库</h1>

<p>只考虑ELF类型的共享库</p>

<h2>创建共享库</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
</span><span class='line'>$ gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o
</span><span class='line'>
</span><span class='line'># 或者一条命令
</span><span class='line'>
</span><span class='line'>$ gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so
</span></code></pre></td></tr></table></div></figure>


<p>–fPIC 知道位置无关代码；</p>

<p>-shared指定创建共享库。</p>

<p>注意：
* 按照惯例，共享库前缀是lib，后缀是.so</p>

<h3>位置无关代码（Position-Independent Code ）</h3>

<p>gcc -fPIC 指示编译器生成位置无关代码（<em>position-independent code</em>）。</p>

<p>这对某些操作来说会改变编译器生成代码的方式。这些操作包括：访问全局、静态或者外部变量；访问字符串常量；获取函数地址等。</p>

<p>这些改变允许可以在运行时在任意虚拟地址定位代码。这对于共享库来说是必要的，因为在链接时刻，是不知道共享库代码在内存的具体地址的。</p>

<h2>使用共享库</h2>

<p>要使用共享库，比起静态库来，额外需要两个步骤：</p>

<ul>
<li>由于最后的可执行文件，没有包含锁依赖的目标文件的拷贝，必须有个机制来在运行时标记它所依赖的共享库。这通过在链接阶段，把共享库的名字嵌入到可执行文件中。这个依赖的共享库列表叫做：dynamic dependency list。</li>
</ul>


<p>嵌入共享库名字到可执行文件，在链接阶段是自动的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -Wall -o prog prog.c libfoo.so</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在运行时，必须有个机制来解决嵌入的共享库名字，也就是根据名字找到共享库的文件，然后加载到内存。</li>
</ul>


<p>根据可执行文件中嵌入的共享库名字，来寻找共享库文件，需要动态链接（dynamic linking）步骤，这是通过动态链接器（dynamic linker）来实现。动态链接器本身就是一个共享库，名字是/lib/ld-linux.so.2，这个链接器也会被嵌入到使用共享库的执行文件中。</p>

<p>动态链接器的任务是：根据一定预先定义的规则在文件系统中寻找共享库文件。这些规则指定了一些存放共享库的标准目录，比如，一般放在/lib和/usr/lib目录下。</p>

<h3>LD_LIBRARY_PATH 环境变量</h3>

<p>除了标准目录，还可以使用环境变量LD_LIBRARY_PATH指定其它目录来通知动态链接器去这些目录寻找共享库文件。如果指定了这个共享库，则动态链接器会先从这几个目录寻找，然后再去标准目录去寻找。</p>

<h2>共享库的Soname</h2>

<p>实际上，一般不会直接让共享库的实际名字嵌入到可执行文件中，而是，在创建一个共享库的时候，会创建一个共享库的soname（在ELF中的DT_SONAME标签）。</p>

<p>一旦一个共享库创建了一个别名soname，那么在链接阶段，共享库的soname会被嵌入到可执行文件中。随后动态链接器会根据这个soname在运行时来寻找共享库的实际文件。</p>

<p>soname的目的是：</p>

<ol>
<li>允许在运行时，可以使用一个与编译时不同的共享库版本</li>
</ol>


<h3>创建一个具有soname的共享库：</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c
</span><span class='line'>$ gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o
</span><span class='line'>
</span><span class='line'># 共享库的soname是libbar.so</span></code></pre></td></tr></table></div></figure>


<p>一旦共享库有了soname，那么使用共享库时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gcc -g -Wall -o prog prog.c libfoo.so</span></code></pre></td></tr></table></div></figure>


<p>即使使用的是共享库的真实文件名，链接器也会发现，这个共享库实际上有soname，因此，会使用soname来替代。</p>

<p>一旦创建了一个soname的共享库，还有一个重要步骤是创建一个soname到实际共享库的软链：</p>

<blockquote><p>注意：
这个软链必须创建在动态链接器的查找目录中</p></blockquote>

<p>编译步骤图示：
<img src="http://baren.github.io/images/assets/gcc-dl.png" title="linux" alt="alt text" /></p>

<p>使用步骤图示：
<img src="http://baren.github.io/images/assets/gcc-dl-u.png" title="linux" alt="alt text" /></p>

<h1>共享库相关的工具</h1>

<h2>ldd</h2>

<p>ldd命令展示一个程序需要依赖的共享库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ldd prog
</span><span class='line'>libdemo.so.1 =&gt; /usr/lib/libdemo.so.1 (0x40019000) libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4017b000) /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span></code></pre></td></tr></table></div></figure>


<h1>共享库版本和命名规范</h1>

<ul>
<li><p>minor versions：一般来说，如果如果随后的共享库的版本与上一个共享库的版本是兼容的，比如函数签名没有变，这种版本不一样但是兼容的情况，叫做共享库的 * minor versions *。</p></li>
<li><p>如果共享库的两个版本是不兼容的，则是 * major version*。</p></li>
</ul>


<p>为了处理这两种差异，为共享库命名定义了一些规范。</p>

<ul>
<li>共享库的每一个不兼容版本，用唯一的major version 标识符标记，这是共享库实际名字的一部分。按照约定，使用数字累加来当做major version。</li>
<li>共享库的兼容版本，使用minor version标识符来标记，minor version可以是任意字符串，但是，约定也是数字，也可以是两个数字，用句点隔开的。</li>
</ul>


<p>根据上面约定，一个共享库的名字组成是：</p>

<p>libname.so.major-id.minor-id.</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libdemo.so.1.0.1
</span><span class='line'>libdemo.so.1.0.2  # Minor version, compatible with version 1.0.1 
</span><span class='line'>libdemo.so.2.0.0  # New major version, incompatible with version 1.* libreadline.so.5.0</span></code></pre></td></tr></table></div></figure>


<h2>soname命名规范</h2>

<p>共享库的soname的命名规范，包括它对应的共享库实际文件的major version标识符，而不包括minor version标识符，因此soname的名字组成是：</p>

<p>libname.so.major-id</p>

<p>soname在共享库实际文件同一个目录下创建一个软链。</p>

<p>一般情况下，因为共享库的minor version标记这是兼容版本，因此soname一般指向最新的最小版本文件。假如libdemo.so.1这个版本下的小版本最新的是0.2，那么：</p>

<p>libdemo.so.1  -> libdemo.so.1.0.2</p>

<h2>linker name</h2>

<p>除了这两个外，还有个linker name，这个名字只包括主要名字，不包括版本，比如：</p>

<p>libdemo.so -> libdemo.so.2</p>

<p>libreadline.so -> libreadline.so.5</p>

<p>linker name 既可以指向一个实际的共享库，也可以指向soname的软链。一般是指向soname</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[daemon简介]]></title>
    <link href="http://baren.github.io/blog/2014/10/20/daemon/"/>
    <updated>2014-10-20T21:09:01+08:00</updated>
    <id>http://baren.github.io/blog/2014/10/20/daemon</id>
    <content type="html"><![CDATA[<p>要理解daemon，需要了解</p>

<ul>
<li>进程组</li>
<li>会话</li>
<li>控制终端</li>
<li>SIGHUP信号（kill -HUP）</li>
<li>fg和bg命令</li>
<li>使用nohup使进程变为后台进程</li>
<li>一个命令后采用“&amp;”使之在后台执行</li>
</ul>


<p>等这些相关知识。</p>

<!-- more -->


<h1>外围知识</h1>

<h2>进程组</h2>

<p>进程组是一个或多个具有共同进程组ID的进程集。
进程组的特点是：</p>

<ul>
<li>进程组的首进程是创建了进程组的进程，并且进程组的进程ID与进程组ID相等</li>
<li>子进程会继承父进程的进程组ID</li>
<li>进程组有生命周期，从进程创建进程组开始，到最后一个进程离开进程组结束</li>
</ul>


<h2>会话</h2>

<p>一个会话是进程组的集合。</p>

<p>一个进程是否属于一个会话是靠进程的进程会话ID，</p>

<ul>
<li>一个会话头进程是创建会话的进程，会话ID与进程的进程ID一样</li>
<li>子进程继承父进程的会话ID</li>
</ul>


<h2>进程组、会话与控制终端</h2>

<ul>
<li>所有的会话中的进程共享一个控制终端。</li>
<li>控制终端的建立是当会话的首进程第一次打开控制终端时。</li>
<li>如果一个会话有控制终端，那么在一个时刻，一个会话中，只有一个进程组是前台进程。其它进程组都是后台进程组</li>
<li>只有前台进程组中的进程可以从控制终端中读取输入。</li>
<li>当在控制终端输入终端字符（Control-C）生成SIGINT信号，并发送给前台进程组中的所有进程</li>
<li>会话首进程对于控制终端来说是控制进程，如果与控制终端断开，内核会给控制进程发送SIGHUP信号。</li>
</ul>


<p>会话进程组控制终端之间关系的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $$
</span><span class='line'>400
</span><span class='line'>$ find / 2&gt; /dev/null | wc -l & 
</span><span class='line'>[1] 659
</span><span class='line'>$ sort &lt; longlist | uniq -c</span></code></pre></td></tr></table></div></figure>


<p>图示：
<img src="http://baren.github.io/images/assets/session_crt.png" title="linux" alt="alt text" /></p>

<h2>SIGHUP信号</h2>

<p>当控制进程与控制终端连接断开时，内核会发送SIGHUP信号给控制进程。SIGHUP的默认动作是终止进程。</p>

<p>会发生以下事情：</p>

<ul>
<li>如果控制进程是shell，他会建立处理SIGHUP信号的函数，在终止之前，会发送SIGHUP信号给它自己创建的每一个作业。</li>
<li>控制终端的控制进程停止时，内核断开会话内的所有进程与控制终端的连接。</li>
</ul>


<h1>daemon进程</h1>

<p>一个daemon是一个进程，具有以下特征：</p>

<ul>
<li>长时间运行的</li>
<li>在后台运行，并没有控制终端。没有控制终端，保证了内核不会为daemon进程生成任何作业控制或者终端相关信号（SIGINT, SIGTSTP, 和 SIGHUP）</li>
</ul>


<p>系统的一些daemon进程：</p>

<ul>
<li>cron：在指定时间执行任务的后台进程</li>
<li>sshd: secure shell进程</li>
<li>inetd：后台进程，监听在特定TCP/IP端口进来的网络连接，并启动相应的程序处理连接</li>
</ul>


<h2>创建一个daemon</h2>

<p>创建一个daemon有一些固定的步骤和流程。</p>

<ol>
<li>fork，然后父进程退出。

<blockquote><p>这样的好处是：</p></blockquote></li>
</ol>


<blockquote><p>1 fork后的子进程的父进程的父进程就成了init。</p>

<p>2 如果该守护进程是从shell启动，父进程退出，会让shell认为这条命令执行完成</p>

<p>3 保证子进程不是组长进程</p></blockquote>

<ol>
<li>进程独立，调用setsid函数</li>
</ol>


<blockquote><p>因为所有会话中的进程会共享同一个控制终端，（控制进程的子进程，都会继承这个控制终端），具有控制终端的进程都会收到控制终端发出的信号，因此，必须让daemon与控制终端分离。</p>

<p>调用setsid()函数使daemon独立，这会让进程处在一个新的会话和进程组中，并与控制终端分离</p></blockquote>

<ol>
<li>关闭不需要的文件描述符。

<blockquote><p>根据函数确认进程可拥有的最大进程描述符的值，一个个关闭，比如：</p></blockquote></li>
</ol>


<blockquote><p>for (i=getdtablesize();i>=0;&ndash;i) close(i); /<em> close all descriptors </em>/</p>

<p>有些标准库程序会读或者写入标准IO，可能会发生在终端或者文件中，因此最好也重定向标准IO无害设备上，比如/dev/null。</p>

<p>i=open(&ldquo;/dev/null&rdquo;,O_RDWR); /<em> open stdin </em>/</p>

<p>dup(i); /<em> stdout </em>/</p>

<p>dup(i); /<em> stderr </em>/</p></blockquote>

<ol>
<li>修改创建文件屏蔽字</li>
</ol>


<blockquote><p>有时候daemon会保护他创建的文件，因此会回收组写和其它写功能，</p>

<p>umask(027)</p></blockquote>

<ol>
<li>将当前工作目录改成根目录</li>
</ol>


<blockquote><p>好处方便查到程序的一些配置文件等</p>

<p>如果进程的工作目录是“/”，那么将不能使用unmount来卸载文件系统，因为unmount两种条件下出错：有打开的文件和在有执行的后台进程，其工作目录处于文件系统中</p>

<p>比如：chdir(&ldquo;/servers/&rdquo;);</p></blockquote>

<ol>
<li>设置排他性，只有一个进程运行</li>
</ol>


<blockquote><p>比如cron进程，肯定只需要一个就够了。</p>

<p>文件锁方法对于排他性执行是个好方法。</p></blockquote>

<ol>
<li>捕获信号</li>
</ol>


<blockquote><p>进程可以从用户和进程收到信号，最好是捕获信号并做处理。</p>

<p>子进程终止时，会给父进程发送SIGCHLD信号，daemon要么忽略要么处理这个信号</p>

<p>许多服务进程使用hang-up信号来重启服务。用这个信号来重启是哥不错的主意。</p></blockquote>

<ol>
<li>记录日志

<blockquote><p>可以指定一个日志文件</p></blockquote></li>
</ol>


<blockquote><p>使用log服务（syslogd守护进程提供）</p></blockquote>

<p>参考：<a href="http://www.enderunix.org/docs/eng/daemon.php">http://www.enderunix.org/docs/eng/daemon.php</a></p>

<h2>使用SIGHUP重新初始化daemon进程</h2>

<p>大部分daemon都是一直执行直到系统关闭。
但是，如果想重新初始化进程而又不想停止进程再重启（重新读取配置文件）。可以使用SIGHUP信号来实现。通过捕获这个信号来完成相应初始化逻辑。</p>

<p>SIGHUP信号是当控制进程与控制终端断开时，发送给控制进程的。由于daemon没有控制终端，因此内核不会给daemon进程发送SIGHUP信号。因此daemon可以使用这个信号来完成这个处理功能。</p>

<h2>daemon的日志</h2>

<p>只需要记住这个图就可以。</p>

<p><img src="http://baren.github.io/images/assets/daemon-log.png" title="linux" alt="alt text" /></p>

<p>/etc/syslog.conf文件控制的syslogd的日志控制。格式是：</p>

<hr />

<p>facility.level  action</p>

<hr />

<p>其中facility和level是选择器，action决定的消息被发送到的地方。</p>

<p>facility可以是：</p>

<table>
<thead>
<tr>
<th> facility        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_AUTH     </td>
</tr>
<tr>
<td> LOG_AUTHPRIV     </td>
</tr>
<tr>
<td> LOG_CRON     </td>
</tr>
<tr>
<td> LOG_DAEMON     </td>
</tr>
<tr>
<td> LOG_FTP     </td>
</tr>
<tr>
<td> LOG_MAIL     </td>
</tr>
<tr>
<td> LOG_NEWS     </td>
</tr>
<tr>
<td> LOG_SYSLOG     </td>
</tr>
<tr>
<td> LOG_USER     </td>
</tr>
<tr>
<td> LOG_KERN     </td>
</tr>
<tr>
<td> 等     </td>
</tr>
</tbody>
</table>


<p>level可以是：</p>

<table>
<thead>
<tr>
<th> level        </th>
</tr>
</thead>
<tbody>
<tr>
<td> LOG_EMERG     </td>
</tr>
<tr>
<td> LOG_ALERT     </td>
</tr>
<tr>
<td> LOG_CRIT     </td>
</tr>
<tr>
<td> LOG_ERR     </td>
</tr>
<tr>
<td> LOG_WARNING     </td>
</tr>
<tr>
<td> LOG_NOTICE     </td>
</tr>
<tr>
<td> LOG_INFO     </td>
</tr>
<tr>
<td> LOG_DEBUG     </td>
</tr>
</tbody>
</table>


<p>比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*.LOG_ERR                        /dev/tty10 所有的错误发到控制终端
</span><span class='line'>auth.notice                   root # 发送到root登陆的控制台或终端
</span><span class='line'>*.debug;mail.none;news.none   -/var/log/messages</span></code></pre></td></tr></table></div></figure>


<p>一行可以包含多个选择器，用分号分割。*.debug;mail.none;news.</p>

<p>none表示所有的debug信息，但是拍出mail和news的信息。-/var/log/messages前面有个“-”表示不需要每次写入都同步到磁盘，这使的写入速度快。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread 进一步细节]]></title>
    <link href="http://baren.github.io/blog/2014/09/28/pthread-further-details/"/>
    <updated>2014-09-28T20:43:21+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/28/pthread-further-details</id>
    <content type="html"><![CDATA[<h1>线程和信号</h1>

<p>信号的设计实现早于线程，导致线程与信号之间有许多冲突。冲突的地方主要在于：</p>

<ul>
<li>既要维护传统的在单线程进程环境下的信号语义</li>
<li>同时又要开发符合多线程进程环境下的信号程序</li>
</ul>


<!-- more -->


<h2>信号模式怎样映射到线程</h2>

<p>需要弄清楚信号的哪些方面是进程级别的，哪些方面是针对特定线程的。说明：</p>

<ul>
<li>信号动作是<em>进程</em>级别的。这意味着一个默认动作是终止进程的信号被内核递送到进程的任意线程，所有的进程内的线程都会终止。</li>
<li>信号处理是<em>进程</em>级别的。进程内的所有线程都共享同一个信号处理器。如果一个线程使用sigaction()建立的信号处理器，进程内的任意线程如果收到这个信号，都会调用这个处理器；如果一个线程设置了忽略某个信号，其它线程也自动忽略</li>
<li>如果信号递送给一个多线程的进程时，内核会随机选取一个线程，用来递送信号和执行信号处理程序。</li>
<li>屏蔽信号是基于线程的。线程可以使用pthread_sigmask()来屏蔽某些信号。</li>
<li>内核维护了针对进程的一个全局的阻塞（pending）的信号集；也维护了针对每个线程的阻塞的信号集。sigpending()函数会返回进程的全局阻塞的信号集和调用这个函数的线程的阻塞信号集的并集。一个新创建的线程，阻塞的信号集是空。如果一个线程阻塞了一个信号，这个信号一直被阻塞，直到线程取消阻塞或者线程停止。</li>
<li>如果一个信号处理中断了pthread_mutex_lock()调用，这个调用总是会自动启动。如果中断了pthread_cond_wait()，也会自动重启。</li>
</ul>


<p>以下几种情况，信号会递送给特定线程：</p>

<ul>
<li>在某个线程上下文中，执行了一个特定的硬件指令的直接结果，生成信号</li>
<li>线程试图写入到一个终端的pipe文件时，生成一个SIGPIPE</li>
<li>使用pthread_kill() 或 pthread_sigqueue()可以允许同一进程的线程给另一个线程发信号</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;signal.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_kill</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_sigmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">oldset</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>线程和进程控制</h1>

<p>就像信号一样exec(), fork(), and exit()也是早于线程。</p>

<h5>线程和exec()</h5>

<p>当任意线程调用exec()函数时，调用的程序会被完全取代。所有的线程，除了调用线程外，都会被终止。不会去执行线程的终止处理函数，属于进程的锁和条件变量都会消失。</p>

<h5>线程和fork()</h5>

<p>多线程环境的进程调用fork()函数，只有调用进程在子进程中复制。其它线程在子进程中会消失，线程特定的析构或者清理函数都不会执行。这会导致严重问题：</p>

<ul>
<li><p>虽然只有调用线程被复制了，但是进程全局状态，还有pthread对象（比如锁和条件变量）等全局对象，都会被复制到子进程。这会导致，如果在fork的同时，有个线程锁住了mutex，并且部分更新了全局数据结构，这种情况下，子进程中的线程将不能够解锁这个mutex。更进一步，子进程中的全局状态可能处于不一致状态。</p></li>
<li><p>由于线程的析构或者清理函数没有被调用，有可能导致子进程的内存泄露。</p></li>
</ul>


<p>由于在多线程环境下调用fork有这么多严重问题，通常的建议是：</p>

<ul>
<li>只有在后续立即调用exec函数的情况下，才会调用fork函数。否则不要调用。</li>
</ul>


<p>如果必须调用fork函数，但是后面不跟着调用exec函数，linux提供了一个这种情况下的解决办法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_atfork</span><span class="p">(</span><span class="n">prepare_func</span><span class="p">,</span> <span class="n">parent_func</span><span class="p">,</span> <span class="n">child_func</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>线程实现模式</h1>

<p>有许多线程实现方式，主要的区别是线程和内核的调度实体（kernel scheduling entities）之间映射的不同。</p>

<p>内核调度实体（kernel scheduling entities）是内核分配CPU和其他资源的单元。在传统的UNIX系统下，内核调用实体与进程是同义的。</p>

<h2>Many-to-one (M:1) 实现，用户级别线程</h2>

<p>在M:1线程实现模式下，所有的线程创建、调度和同步细节都在用户空间下的线程lib包实现。内核不知道关于线程的任何细节。</p>

<p>这种实现有以下几种好处：</p>

<ul>
<li>最大的好处是线程操作非常快速，因为这些全部在用户空间实现，不用切换到内核空间。</li>
<li>移植性好，由于是在用户空间实现的，可以很容易从一个系统移植到另一个系统</li>
</ul>


<p>不好处是：</p>

<ul>
<li>当一个线程调用了一个系统调用（比如read()），控制从用户空间的线程包转到内核，这意味着read()被阻塞了，那么其它线程就全部被阻塞了。</li>
<li>内核不能够调度线程。由于内核不知道线程的存在，因此内核不能调度线程到其它cpu上。</li>
</ul>


<h2>One-to-one (1:1)实现方式</h2>

<p>在1:1实现方式下，一个线程对应一个内核的调度实体。内核单独的处理每个线程的调度。这样，就解决了M:1的重大调度问题。</p>

<p>但是这种实现方式下，也有其它问题：</p>

<ul>
<li>线程的创建同步等操作就比较慢，因为需要切换到内核空间下。</li>
<li>一对一的关系，内核需要为每一个线程维护一个内核调度实体，如果有大量的线程，会降低整体性能。</li>
</ul>


<p>尽管如此，1:1的方式是大多数pthread线程实现的方式。两个linux的pthread实现都是采用1:1的方式</p>

<h2>linux的pthread实现方式</h2>

<p>linux有两种pthread的实现：</p>

<ul>
<li>LinuxThreads: 这是linux的最初实现。Xavier Leroy开发</li>
<li>NPTL (Native POSIX Threads Library): 新的linux下的pthread实现。Ulrich Dreppe（gun c也叫libc的管理者） 和 Ingo Molnar实现。性能比LinuxThreads好，也更符合pthread的规范。</li>
</ul>


<p>在glibc 2.4及其后续版本，不再支持LinuxThreads了。</p>

<h3>LinuxThreads实现细节</h3>

<ul>
<li>使用clone() 系统调用创建一个线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</p>

<p>这意味着LinuxThreads线程共享虚拟内存、文件描述符、文件相关信息（umask, root directory, and current working directory）和信号处理。</p>

<ul>
<li><p>除了由应用创建的线程，LinuxThreads还创建了额外的管理线程，来处理线程的创建的销毁。</p></li>
<li><p>实现采用了信号来进行内部的操作。</p></li>
</ul>


<p>当内核支持实时信号（Linux 2.2及其以后），前三个实时信号被使用；如果是老的内核，使用 SIGUSR1 and SIGUSR2，这样，应用不能够使用这几个信号。</p>

<p>关于实时信号，参考：
<a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7">http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7</a></p>

<h3>NPTL</h3>

<ul>
<li>使用clone() 创建线程，复制的资源是</li>
</ul>


<p>CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</p>

<ul>
<li><p>使用了前两个实时信号</p></li>
<li><p>不像LinuxThreads，NPTL没有实现管理线程</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[取消线程]]></title>
    <link href="http://baren.github.io/blog/2014/09/25/pthread-cancel/"/>
    <updated>2014-09-25T20:56:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/25/pthread-cancel</id>
    <content type="html"><![CDATA[<p>主要描述POSIX线程的取消机制和更进一步的线程细节，包括线程和信号，线程栈等。</p>

<!-- more -->


<h1>取消一个线程</h1>

<p>使用pthread_cancel函数取消特定的线程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 返回0表示成功</span>
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cancel只是发送取消请求，然后立即返回。这意味着调用线程不用等待线程停止。目标线程什么时候停止，取决于目标线程的状态和类型。</p>

<h1>取消状态和类型</h1>

<p>使用pthread_setcancelstate()设置线程的取消状态；使用pthread_setcanceltype()设置线程的取消类型。这两个状态设置线程如何响应取消操作的。</p>

<p>pthread_setcancelstate()函数可设置的状态是：</p>

<ul>
<li>PTHREAD_CANCEL_DISABLE。 线程是不可取消的。这种线程如果接收到一个取消请求，会保持未决（pending）状态直到成为可取消状态</li>
<li>PTHREAD_CANCEL_ENABLE。线程是可取消的，这个状态也是默认的状态。</li>
</ul>


<p>线程在执行一段必须执行完的代码时，设置为不可取消状态，是非常有用的。</p>

<p>pthread_setcanceltype()函数可以设置两种类型：</p>

<ul>
<li>PTHREAD_CANCEL_DEFERRED。线程一直执行直到遇到取消点（特殊函数）。默认类型。</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS。线程可以在任意时间点取消，一般不大永。</li>
</ul>


<h1>取消点</h1>

<p>当一个线程是可取消的并且是延迟的（PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DEFERRED）。取消操作会在线程执行到下一个取消点时起作用。</p>

<p>SUSv3 定义了一组必须是取消点的函数，还定义了一组是可选取消点的函数。</p>

<p>可取消函数列表（略）</p>

<p>对于一个不是分离的线程，必须由其它函数调用pthread_join函数等待这个线程结束。如果这个线程接收了取消请求，并到达了一个取消点，则pthread_join返回的值是PTHREAD_CANCELED.</p>

<p>取消线程的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="nf">threadFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New thread started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Loop %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* NOTREACHED */</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">thr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_create&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>      <span class="cm">/* Allow new thread to run a while */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cancel&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_join&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">PTHREAD_CANCELED</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread was canceled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread was not canceled (should not happen!)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>测试取消点</h1>

<p>如果线程没有调用这些取消点函数（纯计算线程），为了也能够响应取消请求，可以使用pthread_testcancel()来当取消点。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_testcancel</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>清理处理器</h1>

<p>如果一个线程接收到取消请求，执行到一个取消点，则会停止。有可能会导致共享的变量和pthread对象（比如锁）处在不一致状态，可能会导致剩下的线程死锁等异常状态。</p>

<p>为了避免这个问题，需要定义线程结束的清理函数。</p>

<p>每一个线程都有一个线程处理函数栈。当线程被取消时，从上到下依次开始执行清理处理程序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_cleanup_push</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">routine</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">pthread_cleanup_pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">execute</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
当线程正常执行完成，不会触发清理处理函数。</p></blockquote>

<p>一般来说，一个清理操作只有在执行一段特殊的代码时被取消时，才会用到。</p>

<p>下面例子在主main函数中创建了一个线程，他分配了一块内存，并锁住了一个互斥锁mtx。因为线程有可能被取消，因此使用pthread_cleanup_push()来安装清理处理函数，这个清理函数主要作用是释放分配的内存，并对互斥锁解锁。</p>

<p>安装完清理处理器后，线程进入所谓的特殊代码段（如果取消，需要走清理处理函数的）。</p>

<p>如果特殊代码段正常执行完成，则调用pthread_cleanup_pop()去掉处理函数。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="n">mtx</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">glob</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Predicate variable */</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>        <span class="cm">/* Free memory pointed to by &#39;arg&#39; and unlock mutex */</span> <span class="n">cleanupHandler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cleanup: freeing block at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cleanup: unlocking mutex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="n">threadFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Buffer allocated by thread */</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10000</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread: allocated memory at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>  <span class="cm">/* Not a cancellation point */</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">cleanupHandler</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">glob</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>   <span class="cm">/* A cancellation point */</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>      
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cond_wait&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread: condition wait loop completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="n">thr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_create&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>      <span class="cm">/* Give thread a chance to get started */</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>      <span class="cm">/* Cancel thread */</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: about to cancel thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cancel&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>       <span class="cm">/* Signal condition variable */</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: about to signal condition variable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>      <span class="n">glob</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_cond_signal&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span><span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">thr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_join&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">PTHREAD_CANCELED</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;main: thread was canceled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>      <span class="nf">printf</span><span class="p">(</span><span class="s">&quot;main: thread terminated normally</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>  
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
注意上面例子对pthread_cleanup_push()函数的的典型使用</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread control]]></title>
    <link href="http://baren.github.io/blog/2014/09/17/pthread-control/"/>
    <updated>2014-09-17T21:19:03+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/17/pthread-control</id>
    <content type="html"><![CDATA[<h1>线程属性</h1>

<p>在使用pthread_create函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建线程时，第三个参数attr是线程属性。可以使用pthread_attr_t结构来修改线程默认属性。</p>

<p>pthread_attr_t变量需要初始化，需要使用pthread_attr_init函数进行初始化。调用初始化函数后，pthread_attr_t结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p>

<!-- more -->


<p>pthread_attr_t属性的初始化和销毁接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_init</span><span class="p">(</span><span class="kt">ptread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_destory</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>POSIX.1支持的线程属性包括：</p>

<ul>
<li>线程的分离状态属性</li>
<li>线程栈末尾的警戒缓冲区大小</li>
<li>线程栈的最低地址</li>
<li>线程栈的大小</li>
</ul>


<p>如果创建的线程不需要知道线程的终止状态，可以在创建的时候，以分离状态启动。通过设置pthread_attr_t的值为分离状态。设置pthread_attr_t的函数是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_getdetachstate</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">detachstate</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_attr_setdetachstate</span><span class="p">(</span><span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">detachstate</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>设置分离状态的属性值是：PTHREAD_CREATE_DETACHED</p>

<h1>同步属性</h1>

<p>互斥量、读写锁和条件变量的属性</p>

<h2>互斥量属性</h2>

<p>主要讲互斥量属性的类型属性。类型属性有以下几种：</p>

<ul>
<li>PTHREAD_MUTEX_NORMAL——不检查死锁错误，如果一个线程试图去lock一个他已经锁住的互斥量，则发生死锁。</li>
<li>PTHREAD_MUTEX_ERRORCHECK——提供错误检查</li>
<li>PTHREAD_MUTEX_RECURSIVE——允许同一个线程多同一个互斥量多次加锁。会维持一个加锁计数量。</li>
</ul>


<p>对互斥量，属性初始化和销毁函数是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以通过下面函数设置互斥量属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutexattr_gettype</span><span class="p">(</span><span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutexattr_settype</span><span class="p">(</span><span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>读写锁属性</h2>

<p>支持进程共享属性</p>

<h2>条件变量属性</h2>

<p>支持进程共享属性</p>

<h1>重入</h1>

<p>在信号处理时，可重入的函数是指函数没有访问静态数据结构，或者没有调用malloc和free等。在线程处理时，函数同样也有重用的概念。</p>

<p>在多线程环境下，一个函数是可重入的，意思是：一个函数在同一时刻可以被多个线程安全调用。</p>

<p>注意与信号的区别
* 一个函数对多线程来说是可重入的，意思是这个函数是线程安全的。
* 但并不意味着对信号处理程序来说该函数是可重入的（比如标准io函数，是线程安全的，会对流加锁保证，但是对信号处理是不可重入的，因为会修改全局数据结构）。</p>

<p>有一个列表，列出了posix.1中不能保证线程安全的函数：</p>

<p><img src="http://baren.github.io/images/assets/pthread-1.png" title="linux" alt="alt text" /></p>

<p>如果操作系统实现线程安全这一特性时，会同时提供一个对应的线程安全版本。</p>

<p>比如asctime，对应的就是asctime_r，后缀是_r表示可重入。</p>

<p>posix.1还提供了以线程按方式管理FILE对象的方法。</p>

<p>标准IO流的实现，会对流加锁解锁操作，如果频繁调用getc函数，会有性能下降，因为会有频繁的加锁解锁。</p>

<p>为了解决这个问题，posix1.c引入非可重入版本的流函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">getchar_unlocked</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">getc_unlocked</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">putchar_unlocked</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">putc_unlocked</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时提供了线程安全的方式管理FILE对象的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">ftrylockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">flockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">funlockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用非线程安全的流函数版本时，需要用flockfile和funlockfile包围，否则会出现不可预测的问题（因为是非线程安全的）。</p>

<p>好处：</p>

<ul>
<li>一旦对FILE对象进行加锁，就可以在释放锁之前对这些函数进行多次调用。这样就可以在多次数据读写上分摊总的加解锁开销。</li>
</ul>


<h1>线程私有数据</h1>

<p>让一个函数是线程安全的最有效的方式就是让函数是可重入的。新的函数最好这么实现。尽管如此，
一些老的函数，不是线程安全的，如果要将其改造成线程安全函数，需要满足：</p>

<ul>
<li>实现线程安全的</li>
<li>不能改变函数的签名，也就是不需要调用这个函数的程序去修改</li>
</ul>


<p>使用线程私有（thread-specific）数据可以实现。</p>

<blockquote><p>注意：
要理解线程私有数据，以函数的角度考虑问题。</p></blockquote>

<p>线程私有数据允许函数为每一个线程维持一个单独的数据拷贝。如图所示：</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd.png" title="linux" alt="alt text" /></p>

<p>线程A调用函数myfunc时，myfunc函数为线程A维持一个单独数据，线程B调用myfunc函数时，myfunc为线程B维持一个线程B单独的数据。</p>

<p>线程私有数据有个特点：</p>

<ul>
<li>存储的数据是持久化的，每一份数据会一直存在，这允许函数间共享数据（虽然不推荐）。</li>
</ul>


<h2>从函数角度考虑线程私有数据</h2>

<p>为了更好的理解线程私有数据，需要从函数角度（实现角度）考虑如何使用线程私有数据</p>

<ul>
<li>在线程第一次调用函数时，函数为线程分配独立的存储块。存储块只分配一次，就是在线程第一次调用此函数时。</li>
<li>同一个线程对这个函数的随后的调用，函数能够获取这个第一次调用而分配存储块。因此不能用局部变量存储指向存储块的key；也不能用static变量存储，因为在进程内，只有一个static的实例。</li>
<li>不同的函数可能都需要线程私有数据，因此每个函数都得需要自己的线程私有数据key</li>
<li>当线程停止时，函数不需要控制私有数据，因为停止时，代码有可能已经执行到函数外了。因此需要有个地方来执行清理操作。</li>
</ul>


<h2>线程私有数据 API</h2>

<h3>创建私有数据key</h3>

<p>创建一个key，两个用处：</p>

<ul>
<li>用来获取函数分配的存储块</li>
<li>用来区分其它函数的线程私有数据对应的key</li>
</ul>


<p>使用pthread_key_create函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_key_create</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>destructor指向一个清理函数，用来释放函数内分配的存储块。</p>

<p>其签名是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">dest</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="cm">/* Release storage pointed to by &#39;value&#39; */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>线程停止时，并且这个key关联的数据不是NULL时，就会自动调用这个函数来清理。</p>

<p>一般，线程私有数据的实现，使用一个全局数组来存储这个key，这个key有两个状态：</p>

<ul>
<li>是否使用的标记</li>
<li>清理函数指针</li>
</ul>


<p>如图：</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd-key.png" title="linux" alt="alt text" /></p>

<p>根据图，pthread_key_create()返回的一般是全局数组的索引，数组元素包含两个字段，是否使用字段和清理函数地址字段。</p>

<h3>关联函数分配内存与key</h3>

<p>使用函数pthread_setspecific函数来关联函数分配的存储和pthread_key_create创建的key。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_setspecific</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="c1">// value参数是一个分配的内存的指针</span>
</span><span class='line'><span class="c1">// 当线程停止时，这个值会传给create函数指定的清理函数。</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">pthread_getspecific</span><span class="p">(</span><span class="kt">pthread_key_t</span> <span class="n">key</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了维护线程私有数据，Pthreads API 为每一个线程维护了一个指针数组，数据元素是函数分配的存储的指针。</p>

<p>如下图，假设pthread_keys[1]是函数myfunc分配的key，对于每一个线程，pthread api维护了一个指针数组，
数组元素指向函数内分配的内存，</p>

<p><img src="http://baren.github.io/images/assets/pthread-psd-key-2.png" title="linux" alt="alt text" /></p>

<h2>例子</h2>

<h3>非线程安全的</h3>

<p>下面是一个非线程安全的strerror()的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define _GNU_SOURCE  </span><span class="cm">/* Get &#39;_sys_nerr&#39; and &#39;_sys_errlist&#39; declarations from &lt;stdio.h&gt; */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;   </span><span class="cm">/* Get declaration of strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#define MAX_ERROR_LEN 256  </span><span class="cm">/* Maximum length of string returned by strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span><span class="p">];</span>  <span class="cm">/* Statically allocated return buffer */</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="nf">strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="n">_sys_nerr</span> <span class="o">||</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAX_ERROR_LEN</span><span class="p">,</span> <span class="s">&quot;Unknown error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">],</span> <span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* Ensure null termination */</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>线程安全例子</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define _GNU_SOURCE        </span><span class="cm">/* Get &#39;_sys_nerr&#39; and &#39;_sys_errlist&#39; declarations from &lt;stdio.h&gt; */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;        </span><span class="cm">/* Get declaration of strerror() */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;tlpi_hdr.h&quot;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_once_t</span> <span class="n">once</span> <span class="o">=</span> <span class="n">PTHREAD_ONCE_INIT</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">pthread_key_t</span> <span class="n">strerrorKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#define MAX_ERROR_LEN 256        </span><span class="cm">/* Maximum length of string in per-thread buffer returned by strerror() */</span><span class="cp"></span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">destructor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>     <span class="cm">/* Free thread-specific data buffer */</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">createKey</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>     <span class="cm">/* One-time key creation function */</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* Allocate a unique thread-specific data key and save the address of the destructor for thread-specific data buffers */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strerrorKey</span><span class="p">,</span> <span class="n">destructor</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_key_create&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="nf">strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Make first caller allocate key for thread-specific data */</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once</span><span class="p">,</span> <span class="n">createKey</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_once&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">buf</span> <span class="o">=</span> <span class="n">pthread_getspecific</span><span class="p">(</span><span class="n">strerrorKey</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* If first call from this thread, allocate buffer for thread, and save its location */</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MAX_ERROR_LEN</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>            <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;malloc&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">strerrorKey</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_setspecific&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="n">_sys_nerr</span> <span class="o">||</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MAX_ERROR_LEN</span><span class="p">,</span> <span class="s">&quot;Unknown error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">_sys_errlist</span><span class="p">[</span><span class="n">err</span><span class="p">],</span> <span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">buf</span><span class="p">[</span><span class="n">MAX_ERROR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="cm">/* Ensure null termination */</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python decorator 深入理解]]></title>
    <link href="http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator/"/>
    <updated>2014-09-14T11:38:09+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/14/per4-checpter6-decorator</id>
    <content type="html"><![CDATA[<h1>装饰器介绍</h1>

<p>装饰器是一个函数，其主要目的是包装另一个函数或类，来透明的修改或者增强被包装对象的功能。语法上，装饰器用<em>@</em>表示，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nd">@trace</span>
</span><span class='line'><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面装饰器，类似于这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class='line'>
</span><span class='line'><span class="n">square</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<h1>不带参数的装饰器</h1>

<p>装饰器不带参数，被装饰的函数可以带参数，也可以不带，</p>

<h2>被装饰函数不带参数</h2>

<p>不带参数的装饰器，比较简单，只需要接收一个函数作为参数即可。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">time</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">timing_function</span><span class="p">(</span><span class="n">some_function</span><span class="p">):</span>  <span class="c"># 装饰器，接收一个函数作为参数</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    Outputs the time a function takes</span>
</span><span class='line'><span class="sd">    to execute.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class='line'>        <span class="n">some_function</span><span class="p">()</span>
</span><span class='line'>        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;Time it took to run the function: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@timing_function</span>
</span><span class='line'><span class="k">def</span> <span class="nf">my_function</span><span class="p">():</span>
</span><span class='line'>    <span class="n">num_list</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">num_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Sum of all the numbers: &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">num_list</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">my_function</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>被装饰函数带参数</h2>

<p>如果被装饰的函数带参数，让包装函数带着参数就可以。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># It’s not black magic, you just have to let the wrapper </span>
</span><span class='line'><span class="c"># pass the argument:</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">a_decorator_passing_arguments</span><span class="p">(</span><span class="n">function_to_decorate</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">a_wrapper_accepting_arguments</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;I got args! Look:&quot;</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span>
</span><span class='line'>        <span class="n">function_to_decorate</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a_wrapper_accepting_arguments</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Since when you are calling the function returned by the decorator, you are</span>
</span><span class='line'><span class="c"># calling the wrapper, passing arguments to the wrapper will let it pass them to </span>
</span><span class='line'><span class="c"># the decorated function</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@a_decorator_passing_arguments</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_full_name</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;My name is&quot;</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span>
</span><span class='line'>
</span><span class='line'><span class="n">print_full_name</span><span class="p">(</span><span class="s">&quot;Peter&quot;</span><span class="p">,</span> <span class="s">&quot;Venkman&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c"># outputs:</span>
</span><span class='line'><span class="c">#I got args! Look: Peter Venkman</span>
</span><span class='line'><span class="c">#My name is Peter Venkman</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了函数通用，可以让包装器接收参数设置为(*args, **kwargs)的形式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">common_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">    Limits how fast the function is</span>
</span><span class='line'><span class="sd">    called.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># 处理代码</span>
</span><span class='line'>        <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 处理代码</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nd">@common_decorator</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_number</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">num</span>
</span></code></pre></td></tr></table></div></figure>


<h1>装饰器需要参数</h1>

<p>有时候为了装饰器的功能性，需要装饰器本身也需要接收参数，但是装饰器应该接收一个函数作为参数，为了达到让装饰器也能接收参数，需要：</p>

<ul>
<li>多套一层函数，最外层函数接收装饰器用到的参数</li>
<li>在打装饰器时，把参数传给装饰器，也就是在<em>@</em>后面是一个函数调用，而不是仅仅是装饰器的名字。</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">decorator_maker_with_arguments</span><span class="p">(</span><span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;I make decorators! And I accept arguments:&quot;</span><span class="p">,</span> <span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># The ability to pass arguments here is a gift from closures.</span>
</span><span class='line'>        <span class="c"># If you are not comfortable with closures, you can assume it’s ok,</span>
</span><span class='line'>        <span class="c"># or read: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;I am the decorator. Somehow you passed me arguments:&quot;</span><span class="p">,</span> <span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Don&#39;t confuse decorator arguments and function arguments!</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">)</span> <span class="p">:</span>
</span><span class='line'>            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;I am the wrapper around the decorated function.</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;I can access all the variables</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;</span><span class="se">\t</span><span class="s">- from the decorator: {0} {1}</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;</span><span class="se">\t</span><span class="s">- from the function call: {2} {3}</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>                  <span class="s">&quot;Then I can pass them to the decorated function&quot;</span>
</span><span class='line'>                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decorator_arg1</span><span class="p">,</span> <span class="n">decorator_arg2</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">))</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">wrapped</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">my_decorator</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decorator_maker_with_arguments</span><span class="p">(</span><span class="s">&quot;Leonard&quot;</span><span class="p">,</span> <span class="s">&quot;Sheldon&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">decorated_function_with_arguments</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;I am the decorated function and only knows about my arguments: {0}&quot;</span>
</span><span class='line'>           <span class="s">&quot; {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">function_arg1</span><span class="p">,</span> <span class="n">function_arg2</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">decorated_function_with_arguments</span><span class="p">(</span><span class="s">&quot;Rajesh&quot;</span><span class="p">,</span> <span class="s">&quot;Howard&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c">#outputs:</span>
</span><span class='line'><span class="c">#I make decorators! And I accept arguments: Leonard Sheldon</span>
</span><span class='line'><span class="c">#I am the decorator. Somehow you passed me arguments: Leonard Sheldon</span>
</span><span class='line'><span class="c">#I am the wrapper around the decorated function. </span>
</span><span class='line'><span class="c">#I can access all the variables </span>
</span><span class='line'><span class="c">#   - from the decorator: Leonard Sheldon </span>
</span><span class='line'><span class="c">#   - from the function call: Rajesh Howard </span>
</span><span class='line'><span class="c">#Then I can pass them to the decorated function</span>
</span><span class='line'><span class="c">#I am the decorated function and only knows about my arguments: Rajesh Howard</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意上面的例子：
1、打装饰器的时候，其实是一个函数调用：@decorator_maker_with_arguments(&ldquo;Leonard&rdquo;, &ldquo;Sheldon&rdquo;)。
2、装饰器返回的包装函数，实际上是一个闭包，它引用了装饰器的参数（decorator_arg1和decorator_arg2）。</p>

<h1>functools模块用于装饰器</h1>

<p>functools在python2.5引入的，他包含了函数functools.wraps()，这个函数的作用是拷贝被包装的函数的名字、模块和docstring到它的包装器上。
functools。wraps()实际上也是个装饰器。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># For debugging, the stacktrace prints you the function __name__</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: foo</span>
</span><span class='line'>
</span><span class='line'><span class="c"># With a decorator, it gets messy    </span>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;bar&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@bar</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: wrapper</span>
</span><span class='line'><span class="c"># 输出的信息是包装器的信息，而不是原始函数的信息。</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用&quot;functools&quot; 来解决上面问题</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">functools</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># We say that &quot;wrapper&quot;, is wrapping &quot;func&quot;</span>
</span><span class='line'>    <span class="c"># and the magic begins</span>
</span><span class='line'>    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;bar&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapper</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@bar</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;foo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">foo</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'><span class="c">#outputs: foo</span>
</span><span class='line'><span class="c"># 输出的信息是实际的foo函数的信息</span>
</span></code></pre></td></tr></table></div></figure>


<h1>类作为装饰器</h1>

<p>装饰器除了使用函数的方式外（大部分都是用函数来实现装饰器），还可以使用类的形式。</p>

<p>对于装饰器来说，唯一的约束是：<em>装饰器返回的对象必须可以被当成函数使用，也就是它可以被调用</em>。</p>

<p>如果类被当成装饰器，那么，类必须实现<strong>call</strong>函数。</p>

<p>需要注意的点：</p>

<ul>
<li>类的初始化函数（<strong>init</strong>）需要接受一个函数作为参赛</li>
<li>在给函数打装饰器时，<strong>init</strong>会执行</li>
<li>在调用被装饰的函数时，类的<strong>call</strong>被调用</li>
</ul>


<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">myDecorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>             <span class="k">print</span> <span class="s">&quot;inside myDecorator.__init__()&quot;</span>
</span><span class='line'><span class="o">...</span>             <span class="n">f</span><span class="p">()</span>
</span><span class='line'><span class="o">...</span>     <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>             <span class="k">print</span> <span class="s">&quot;inside myDecorator.__call__()&quot;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="nd">@myDecorator</span>
</span><span class='line'><span class="o">...</span> <span class="k">def</span> <span class="nf">aFunction</span><span class="p">():</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="s">&quot;inside aFunction()&quot;</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="n">inside</span> <span class="n">myDecorator</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
</span><span class='line'><span class="n">inside</span> <span class="n">aFunction</span><span class="p">()</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">aFunction</span><span class="p">()</span>
</span><span class='line'><span class="n">inside</span> <span class="n">myDecorator</span><span class="o">.</span><span class="n">__call__</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>被装饰函数带参数</h2>

<p>如果使用类来作为装饰器，如果被装饰函数需要参数，则定义在<strong>call</strong>函数上。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">decoratorWithoutArguments</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are no decorator arguments, the function</span>
</span><span class='line'><span class="sd">        to be decorated is passed to the constructor.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __init__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c"># 传给被装饰器的参数，传递给__call__()</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        The __call__ method is not called until the</span>
</span><span class='line'><span class="sd">        decorated function is called.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __call__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;After self.f(*args)&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decoratorWithoutArguments</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;sayHello arguments:&#39;</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After decoration&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Preparing to call sayHello()&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;say&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;argument&quot;</span><span class="p">,</span> <span class="s">&quot;list&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After first sayHello() call&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;different&quot;</span><span class="p">,</span> <span class="s">&quot;set of&quot;</span><span class="p">,</span> <span class="s">&quot;arguments&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After second sayHello() call&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># 函数定义的执行结果
</span><span class='line'>Inside __init__()
</span><span class='line'>After decoration
</span><span class='line'>
</span><span class='line'>Preparing to call sayHello()
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside __call__()
</span><span class='line'>sayHello arguments: say hello argument list
</span><span class='line'>After self.f(*args)
</span><span class='line'>
</span><span class='line'>After first sayHello() call
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside __call__()
</span><span class='line'>sayHello arguments: a different set of arguments
</span><span class='line'>After self.f(*args)
</span><span class='line'>
</span><span class='line'>After second sayHello() call
</span></code></pre></td></tr></table></div></figure>


<h2>装饰器带参数</h2>

<p>如果类作为装饰器，装饰器如果带参数，则需要注意的比较多：</p>

<ul>
<li>参数传递给<strong>init</strong>函数。</li>
<li><strong>call</strong>函数需要返回一个包装函数（因为装饰器有参数，所有打装饰器的地方，实际上是个函数调用，这会导致class的<strong>call</strong>调用）。</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">decoratorWithArguments</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are decorator arguments, the function</span>
</span><span class='line'><span class="sd">        to be decorated is not passed to the constructor!</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __init__()&quot;</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span> <span class="o">=</span> <span class="n">arg1</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span> <span class="o">=</span> <span class="n">arg2</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">arg3</span> <span class="o">=</span> <span class="n">arg3</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
</span><span class='line'>        <span class="sd">&quot;&quot;&quot;</span>
</span><span class='line'><span class="sd">        If there are decorator arguments, __call__() is only called</span>
</span><span class='line'><span class="sd">        once, as part of the decoration process! You can only give</span>
</span><span class='line'><span class="sd">        it a single argument, which is the function object.</span>
</span><span class='line'><span class="sd">        &quot;&quot;&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Inside __call__()&quot;</span>
</span><span class='line'>        <span class="k">def</span> <span class="nf">wrapped_f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Inside wrapped_f()&quot;</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;Decorator arguments:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg3</span>
</span><span class='line'>            <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span> <span class="s">&quot;After f(*args)&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">wrapped_f</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@decoratorWithArguments</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">sayHello</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">):</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&#39;sayHello arguments:&#39;</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;After decoration&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Preparing to call sayHello()&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;say&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;argument&quot;</span><span class="p">,</span> <span class="s">&quot;list&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;after first sayHello() call&quot;</span>
</span><span class='line'><span class="n">sayHello</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;different&quot;</span><span class="p">,</span> <span class="s">&quot;set of&quot;</span><span class="p">,</span> <span class="s">&quot;arguments&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;after second sayHello() call&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>定义输出
</span><span class='line'>Inside __init__()
</span><span class='line'>Inside __call__()  # 因此装饰器是函数调用，因此走到__call__调用
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>After decoration
</span><span class='line'>
</span><span class='line'>Preparing to call sayHello()
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用装饰器调用
</span><span class='line'>Inside wrapped_f()
</span><span class='line'>Decorator arguments: hello world 42
</span><span class='line'>sayHello arguments: say hello argument list
</span><span class='line'>After f(*args)
</span><span class='line'>
</span><span class='line'>after first sayHello() call
</span><span class='line'>
</span><span class='line'># 下面结果是一次函数调用
</span><span class='line'>Inside wrapped_f()
</span><span class='line'>Decorator arguments: hello world 42
</span><span class='line'>sayHello arguments: a different set of arguments
</span><span class='line'>After f(*args)
</span><span class='line'>
</span><span class='line'>after second sayHello() call
</span></code></pre></td></tr></table></div></figure>


<h1>总结</h1>

<p>装饰器可以由函数实现，也可以由类实现，由类实现需要类实现<strong>call</strong>函数。
不管用哪种方式，装饰器返回的必须是一个接受一个函数参数的可调用对象。</p>

<h1>实际例子</h1>

<p>关于装饰器的实际例子，可以参考</p>

<p><a href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a></p>

<h1>参考</h1>

<p><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484</a></p>

<p><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845">http://www.artima.com/weblogs/viewpost.jsp?thread=240845</a>
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 作用域规则]]></title>
    <link href="http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming/"/>
    <updated>2014-09-13T17:07:23+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/13/per4-checpter6-function-and-functional-programming</id>
    <content type="html"><![CDATA[<h1>作用域规则</h1>

<p>每当一个函数执行，都会创建一个局部命名空间（local namespace）。这个命名空间代表了一个局部环境，这个环境包含了凡是参数的名字、在函数内定义的局部变量等。当解析一个名字时，解析器会：</p>

<ul>
<li>首先检查局部环境变量</li>
<li>如果在局部命名空间中找不到，然后再往上寻找全局命名空间（global namespace），全局命名空间是函数定义所在的模块。</li>
<li>如果在全局命名空间不存在，解释器会查找内置的命名空间，如果还找不到，则NameError异常抛出</li>
</ul>


<p>python的命名空间的一个特点就是：在函数内处理全局变量。</p>

<p>比如：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="c"># a 还是 42</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，虽然在函数foo内给a赋值为13，但是：<em>当一个变量在函数内赋值时，结果总是把这个变量绑定到局部命名空间中</em>，因此在foo内，a与全局变量的a是不一样的。</p>

<p>如果要在函数内修改全局变量，必须使用<em>global</em>关键字来修饰变量。表示的意思是简单的生命这个名字属于全局命名空间。这只在这个变量需要被修改的情况下。
例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="mi">37</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="k">global</span> <span class="n">a</span>  <span class="c"># &#39;a&#39; 此时在全局命名空间中</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'>  <span class="n">b</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span><span class="p">()</span>
</span><span class='line'><span class="c"># a 是 13. b 仍然是 37.</span>
</span></code></pre></td></tr></table></div></figure>


<h2>嵌套函数中的变量作用域</h2>

<p>python支持嵌套函数定义，也就是在函数内定义函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span> <span class="c"># Nested function definition </span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>当作用域涉及到嵌套函数时，变量的搜寻是按照<em>词法范围（lexical scoping）</em>来查找的。意思是：</p>

<ul>
<li>变量名字受限检查局部范围</li>
<li>然后是函数定义处外围范围，依次往外查找，从最内层到最外层范围</li>
<li>然后就是全局命名空间</li>
<li>最后是内置的命名空间</li>
</ul>


<p>在给变量赋值时，牵扯到嵌套函数，python2有个限制是：</p>

<ul>
<li>只允许在最内层范围的和全局范围的（使用global）的变量可以被赋值。</li>
</ul>


<p>这意味着：</p>

<ul>
<li>内部函数不能够给一个局部变量赋值，这个局部变量是定义在内部函数的外围函数内。</li>
</ul>


<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">decrement</span><span class="p">():</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c"># 在Python 2是错误的，这里不能修改这个值。</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">decrement</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在python3中，可以使用<em>nonlocal</em>关键字来修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">display</span><span class="p">():</span>
</span><span class='line'>      <span class="k">print</span><span class="p">(</span><span class="s">&#39;T-minus </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">decrement</span><span class="p">():</span>
</span><span class='line'>      <span class="n">nonlocal</span> <span class="n">n</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c"># 绑定到外围的 n (Python 3)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">display</span><span class="p">()</span>
</span><span class='line'>      <span class="n">decrement</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个局部变量在赋值前被使用，则会抛出UnboundLocalError的错误，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">i</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>  <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># 导致UnboundLocalError 异常 </span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，变量<em>i</em>被定义为局部变量（在函数内被赋值，并且没有global关键字声明），这样，在执行 i = i +1 语句时，会试图读取变量“i”的值，会导致错误。</p>

<h1>函数作为对象和闭包（closure）</h1>

<h2>函数作为对象</h2>

<p>python中，函数是一级对象（first-class），意思是</p>

<ul>
<li>函数可以作为参数传递给其它函数</li>
<li>放在数据结构中</li>
<li>以及作为结果从函数中返回。</li>
</ul>


<p>注意：</p>

<blockquote><p>当函数作为数据被处理时，需要注意的是：函数隐含的携带了在函数定义处的外围环境信息。这会影响到自由的变量在函数内怎么被绑定。</p></blockquote>

<p>比如下面例子：</p>

<figure class='code'><figcaption><span>foo_test.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">33</span>
</span><span class='line'><span class="k">def</span> <span class="nf">print_x</span><span class="p">():</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在foo.py文件中导入foo_test：</p>

<figure class='code'><figcaption><span>foo.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
</span><span class='line'>    <span class="n">func</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">(</span><span class="n">foo_test</span><span class="o">.</span><span class="n">print_x</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">//</span> <span class="err">输出结果是</span><span class="mi">33</span><span class="err">，而不是此处定义的</span><span class="mi">42</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，需要注意的是print_x使用的x是他所定义处的x的值，而不是在执行处的值，虽然在执行的地方，也定义了同样的变量。</p>

<h2>闭包</h2>

<p>闭包的定义：
组成函数的语句，与执行的环境绑定在一起，产生的对象，被称为闭包。可以简单的认为闭包是一个函数，它在词法上下文中引用了自由变量，所谓自由变量就是除局部变量以外的变量。</p>

<p>闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例</p>

<p>一般有闭包特征的语言有下面这样的特性：</p>

<ul>
<li>函数是第一级对象（first-class）</li>
<li>函数可以嵌套定义。</li>
</ul>


<p>当嵌套函数被使用时，闭包会捕获嵌套函数执行所需要的整个环境。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">foo</span>
</span><span class='line'><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">=</span> <span class="mi">13</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">helloworld</span><span class="p">():</span>
</span><span class='line'>  <span class="k">return</span> <span class="s">&quot;Hello World. x is </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span>
</span><span class='line'>  <span class="n">foo</span><span class="o">.</span><span class="n">callf</span><span class="p">(</span><span class="n">helloworld</span><span class="p">)</span>     <span class="c"># returns &#39;Hello World, x is 13&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>闭包和嵌套函数在你想延迟计算时，比较有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">urlopen</span>
</span><span class='line'><span class="c"># from urllib.request import urlopen (Python 3) </span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">page</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">get</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python_url</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.python.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython_url</span> <span class="o">=</span> <span class="n">page</span><span class="p">(</span><span class="s">&quot;http://www.jython.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">python_url</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x95d5f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jython</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">function</span> <span class="n">get</span> <span class="n">at</span> <span class="mh">0x9735f0</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">pydata</span> <span class="o">=</span> <span class="n">python</span><span class="p">()</span>  <span class="c"># 读取url内容</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">jydata</span> <span class="o">=</span> <span class="n">jython</span><span class="p">()</span>  <span class="c"># 读取url内容</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于上面这个闭包例子，解释如下：</p>

<ul>
<li>两个变量python_url和jython_url实际上是两个不同的get函数的版本（语句与外围环境的绑定）</li>
<li>即使创建这两个变量的函数page不再运行，get函数暗中的携带了get函数使用的外围get函数定义处的变量。</li>
<li>当get调用时，绑定了代码和外围的变量。</li>
</ul>


<p>闭包一个非常有用的方式是：<em>可以用来保存跨越一系列函数调用的状态（函数式编程所用到的状态的保存）</em>，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">next</span><span class="p">():</span>
</span><span class='line'>      <span class="n">nonlocal</span> <span class="n">n</span>  <span class="c"># python3</span>
</span><span class='line'>      <span class="n">r</span><span class="o">=</span><span class="n">n</span>
</span><span class='line'>      <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">r</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">next</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Example use</span>
</span><span class='line'><span class="nb">next</span> <span class="o">=</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>  <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">()</span>  <span class="c"># 获取下一个值</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，闭包被用来保存内部的计数值 n。这样，每次调用next()函数时，都能够更新和返回上一个计数变量的值（感觉就是更新了一个全局变量，但是这个n实际上是一个局部变量）。</p>

<p>假设，语言不支持闭包，那么要实现上面同样的功能，可以这样(基本原则是在函数外定义一个变量，变量的生命周期不随函数调用而结束)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Countdown</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>      <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Example use</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="n">Countdown</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class='line'>  <span class="n">v</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c"># 获取下一个值</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span></code></pre></td></tr></table></div></figure>


<p>总结：</p>

<blockquote><p>闭包可以保存变量的状态，这个变量不随着闭包调用结束而丢失。重要的特性。
闭包可以捕获嵌套函数的环境的特性，在包装一个存在的函数来增加额外的功能的时候，非常有用（装饰器）。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序结构和控制]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow/"/>
    <updated>2014-09-06T21:56:14+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/per4-chapter5-program-structure-and-control-flow</id>
    <content type="html"><![CDATA[<h1>程序结构和执行</h1>

<p>python程序被组织为一个语句序列。所有的语言特性，包括变量赋值、函数定义、类定义和模块导入等，都是语句，都是与其他语句具有相同状态。</p>

<p>因此所有语句都可以放置在程序的任何地方。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
</span><span class='line'>          <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected a float&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当加载文件时，python解释器顺序的执行每一条语句，知道不能执行为止。</p>

<p>这种执行方式对于简单的作为主程序执行，或者经过import进行导入是一致的。</p>

<!-- more -->


<h1>循环和迭代</h1>

<p>如果要迭代一个列表，可以使用常用的for in格式。如果迭代列表，还需要获取索引，可以使用enumerate函数，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>enumerate()函数实际上创建了一个iterator，这个迭代器每次返回一个元组(index, s[index])</p>

<p>如果要迭代两个list，比如对两个list的每项元素相加。可以使用zip函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># s and t are two sequences </span>
</span><span class='line'><span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span class='line'>  <span class="n">statements</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>zip()函数联合了s和t的元素，生成了一个元组序列：s[0],t[0]), (s[1],t[1]), (s[2], t[2]),等，直到最短的list结束。</p>

<p>注意：
* python2中，zip函数全部消耗了序列元素，生成一个序列。如果s和t比较大，那会生成一个大的列表，进而消耗内存资源。
* python3中，zip改进了，一次生成一个元素，而不是一下子生成一个巨大的序列。
* python2中，可以使用itertools.izip()函数来优化，其方式与python3中的zip一致。</p>

<p>例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">itertools</span>
</span><span class='line'><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
</span><span class='line'><span class="o">...</span>     <span class="k">print</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="mi">12</span>
</span><span class='line'><span class="mi">14</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>循环结构，还可以有一个else的语句,for-else或者while-else，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># for-else</span>
</span><span class='line'><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">):</span>
</span><span class='line'>  <span class="n">stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</span><span class='line'>  <span class="k">if</span> <span class="ow">not</span> <span class="n">stripped</span><span class="p">:</span>
</span><span class='line'>      <span class="k">break</span>
</span><span class='line'><span class="c"># process the stripped line ...</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Missing section separator&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>有两种情况下能够执行到else分支：
* 立即执行，既循环条件不满足。
* 迭代执行完毕，这意味着，如果是break语句或异常语句中断了循环，则不会执行else分支。</p>

<p>一般需要用到for-else这种结构的情况是：迭代完数据，并且需要检查或者设置标记时，可以使用。</p>

<h1>异常</h1>

<p>记住几个点：</p>

<ol>
<li>在except语句中，既可以 except Exception as e，也可以except Exception, e，后面一个是老式用法，不推荐</li>
<li>可以一次except捕获多个异常：<em>except (IOError, TypeError, NameError) as e:</em></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">do</span> <span class="n">something</span>
</span><span class='line'><span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c"># Handle I/O, Type, or Name errors</span>
</span><span class='line'>  <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ol>
<li>try也支持else语句，执行else的条件是try块中没有抛出异常：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>  <span class="n">error_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Unable to open foo : </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>上下文管理和with语句</h1>

<p>在遇到异常的情况下，正确地管理系统资源（比如锁、文件、连接等）是比较棘手的。比如异常可能会绕过释放重要系统资源的代码。</p>

<p><em>with</em>语句允许代码在一个运行的上下文中执行代码，这个运行的上下文被一个作为上下文管理器的对象来控制。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># 当控制离开with代码块时，with自动的将打开的文件关闭</span>
</span><span class='line'><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;debuglog&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Debugging</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'>  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">threading</span>
</span><span class='line'><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
</span><span class='line'><span class="c"># 当控制进入和离开with代码块时，自动获取和释放锁。</span>
</span><span class='line'><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
</span><span class='line'>  <span class="c"># Critical section statements</span>
</span><span class='line'>  <span class="c"># End critical section</span>
</span></code></pre></td></tr></table></div></figure>


<p>语法 <em>with obj</em> 允许让对象obj来控制当执行进入和离开代码块时的行为。</p>

<ul>
<li>进入：
当with obj执行时，它执行obj.<strong>enter</strong>()函数来标记正在进入一个新的上下文。</li>
<li>离开：

<blockquote><p>当控制离开上下文时，执行obj.<strong>exit</strong>(type,value,traceback)，此时，如果没有异常发生，<strong>exit</strong>()函数的三个参数都被设置为None，表示无异常。
否则type,value,traceback就会被赋值为与导致控制流离开with代码块的异常相关联的信息。
<strong>exit</strong>() 返回True和False来标记是否产生的异常被处理了。如果返回False，异常会继续向上传递。</p></blockquote></li>
</ul>


<p>with还可以跟着一个as标识符。<em>with obj as var:</em>如果设置了，则obj.<strong>enter</strong>()的返回值会被赋值给as指定的对象。注意，obj可以不等于var的值。</p>

<p>注意：</p>

<blockquote><p>with只能与支持上下文管理协议的对象（实现了<strong>enter</strong>()和<strong>exit</strong>）一块工作。</p></blockquote>

<p>用户可以实现这两个函数来使自己定义的对象支持上下文管理协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">ListTransaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span> <span class="o">=</span> <span class="n">thelist</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>      <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">type</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">tb</span><span class="p">):</span>
</span><span class='line'>      <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
</span><span class='line'>          <span class="bp">self</span><span class="o">.</span><span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">workingcopy</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">False</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用</span>
</span><span class='line'><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span><span class='line'>  <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>  <span class="k">with</span> <span class="n">ListTransaction</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">as</span> <span class="n">working</span><span class="p">:</span>
</span><span class='line'>      <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">working</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</span><span class='line'>      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;We&#39;re hosed!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span> <span class="k">pass</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="c"># Produces [1,2,3,4,5]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以使用contextlib模块来简化上下文对象的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@contextmanager</span>
</span><span class='line'><span class="k">def</span> <span class="nf">ListTransaction</span><span class="p">(</span><span class="n">thelist</span><span class="p">):</span>
</span><span class='line'>  <span class="n">workingcopy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thelist</span><span class="p">)</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">workingcopy</span>
</span><span class='line'>  <span class="c"># Modify the original list only if no errors </span>
</span><span class='line'>  <span class="n">thelist</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">workingcopy</span>
</span></code></pre></td></tr></table></div></figure>


<p>yield生成的对象，就相当于<strong>enter</strong>函数返回的对象。
当执行到<strong>exit</strong>函数时，执行会从yield后继续执行。</p>

<p>如果在上下文中出现了异常，可异常可以在生成器函数中展现（函数内有yield的函数，调用后产生生成器）</p>

<h1>assert</h1>

<p>语法是这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">assert</span> <span class="n">test</span> <span class="p">[,</span> <span class="n">msg</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c"># test表达式生成True或者False，如果为False，assert会生成一个AssertionError异常，并附带msg信息</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于assert，需要知道以下几点：
* 不能使用assert用来为了使程序正确而必须执行的代码（比如检查用户输入是否合法，则不能使用assert），因为有可能不被执行（运行python使用-O参数）
* assert应该被用来事情总是是true的情况，否则就是个bug。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress syntax]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/octopress-syntax/"/>
    <updated>2014-09-06T10:53:04+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/octopress-syntax</id>
    <content type="html"><![CDATA[<h1>代码高亮语法</h1>

<blockquote><p>{ % codeblock [lang:language] [title] [url] [link text] % }
code snippet
{ % endcodeblock % }</p></blockquote>

<p>例子：</p>

<figure class='code'><figcaption><span>Javascript Array Syntax</span><a href='http://j.mp/pPUUmW'>MDN Documentation </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">arrayLength</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">element0</span><span class="p">,</span> <span class="nx">element1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">elementN</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h1>图片语法</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img [class names] /path/to/image [width] [height] [title text [alt text]] %}</span></code></pre></td></tr></table></div></figure>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img /images/assets/linux.png %}
</span><span class='line'>{ % img left /images/assets/linux.png Place Kitten #2 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 Place Kitten #3 %}
</span><span class='line'>{ % img right /images/assets/linux.png 150 250 'Place Kitten #4' 'An image of a very cute kitten' %}</span></code></pre></td></tr></table></div></figure>


<h1>多个分类</h1>

<p>例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>categories:
</span><span class='line'>- CSS3
</span><span class='line'>- Sass
</span><span class='line'>- Media Queries
</span></code></pre></td></tr></table></div></figure>


<h1>显示部分内容</h1>

<p>插入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- more --&gt;</span></code></pre></td></tr></table></div></figure>


<p>会让文章下面的部分不显示，并会提示一个按钮，来查看未显示的内容。</p>

<h1>命令</h1>

<p>生成内容
rake generate</p>

<p>预览
rake preview</p>

<p>提交：
git add .
git commit -m &ldquo;new&rdquo;
git push origin source</p>

<p>发布：
rake deploy</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux performance observability tools]]></title>
    <link href="http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools/"/>
    <updated>2014-09-06T10:42:48+08:00</updated>
    <id>http://baren.github.io/blog/2014/09/06/linux-performance-observability-tools</id>
    <content type="html"><![CDATA[<p><img src="http://baren.github.io/images/assets/linux.png" title="linux" alt="alt text" /></p>

<p>链接：<a href="http://www.brendangregg.com/linuxperf.html">http://www.brendangregg.com/linuxperf.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(线程)]]></title>
    <link href="http://baren.github.io/blog/2014/08/28/pthread/"/>
    <updated>2014-08-28T20:00:53+08:00</updated>
    <id>http://baren.github.io/blog/2014/08/28/pthread</id>
    <content type="html"><![CDATA[<h1>线程概念</h1>

<p>主要是POSIX线程，也就是pthread。</p>

<p>正常情况下，unix的进程包括一个单一的线程执行，从main开始。有了线程后，一个进程可以有多个线程同时执行。</p>

<p>判断系统是否支持pthread，可以使用宏<em>POSIX_THREADS进行测试，还可以把</em>SC_THREADS传递给sysconf函数来运行时判断。</p>

<p>线程可以有多种好处，按照传统的多进程的实现方式，一般是在网络服务器环境下使用，多进程可以同时支持多个客户端的请求。但也有一些限制：</p>

<ul>
<li>进程之间共享数据非常困难</li>
<li>使用fork创建一个进程是耗资源的。即使使用了copy-on-write技术，复制各种进程的属性（page表和fd表等）也意味着是耗时间的。</li>
</ul>


<p>使用线程，解决这上面这些问题：</p>

<ul>
<li>线程之间共享信息是容易和迅速的。仅仅拷贝数据到共享内存（global或heap）的消耗。</li>
<li>线程创建比进程创建迅速多了。大约有10倍。linux创建线程使用clone系统调用，也还是比进程快。</li>
</ul>


<p>除了共享全局内存，线程还共享一些其他属性，包括</p>

<ul>
<li>进程id和父进程id</li>
<li>进程组合session id</li>
<li>控制终端</li>
<li>进程凭证（用户和组id）</li>
<li>打开的文件描述符（比较重要）</li>
<li>信号处理</li>
<li>文件系统相关信息：umask、当前工作目录和根目录</li>
<li>等</li>
</ul>


<p>下面是各个线程不同的属性：</p>

<ul>
<li>线程id</li>
<li>信号mask</li>
<li>线程私有数据</li>
<li>errno变量</li>
<li>等</li>
</ul>


<!-- more -->


<h2>线程和errno</h2>

<p>进程环境下，errno是一个全局整型变量。在线程环境下，为了防止出现竞争条件（每个线程都去更新这个变量），每个线程都有自己的errno。</p>

<p>这样既避免了errno的条件竞争，又兼容了一些使用errno的函数。</p>

<p>注：</p>

<blockquote><p>在线程中，使用函数的返回错误码更为清晰整洁。</p></blockquote>

<h2>线程ID</h2>

<p>进程的编号id是整个系统唯一的。线程的编号是进程内唯一的。进程的编号，使用<code>pid_t</code>来表示；线程的ID，使用<code>pthread_t</code>类型来表示。</p>

<p>为了可移植性，一般调用函数对线程ID进行处理，而不是把它转换成整型（linux使用无符号整数来实现的）。</p>

<p>下面是处理线程ID的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>// 比较两个线程ID
</span><span class='line'>int pthread_equal(pthread_t tid1; pthread_t tid2);  // 相等则返回非零值
</span><span class='line'>
</span><span class='line'>// 获取线程的ID
</span><span class='line'>pthread_t pthread_self(void);
</span></code></pre></td></tr></table></div></figure>


<h1>线程创建</h1>

<p>使用pthread_create函数创建线程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
</span><span class='line'>void *(*start)(void *), void *arg);
</span><span class='line'>
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的参数意义是：</p>

<ul>
<li>thread——线程创建成功后，将线程的ID写入这个指针指向的内存中</li>
<li>attr——创建线程的属性</li>
<li>start——线程执行的函数指针。这个函数接收一个无类型指针参数，如果函数接收的参数是多个，可以定义一个结构体，并作为参数arg传递给此函数</li>
<li>arg——无类型指针参数，作为线程执行函数的参数传入</li>
</ul>


<h1>线程终止</h1>

<ul>
<li><p>进程终止会导致线程终止：</p>

<ul>
<li>任一线程调用了exit，<em>Exit或</em>exit函数，整个进程终止</li>
<li>若信号的默认动作是终止进程，则把信号发送到线程会终止进程</li>
</ul>
</li>
<li><p>单个进程有三种方式退出，在不终止整个进程的情况下停止线程自己的控制流。</p>

<ul>
<li>线程只是从启动程序中返回，返回值是线程的退出码（也就是pthread_create函数的第三个参数start函数的返回值）</li>
<li>线程可以被同一进程中的其它线程取消（pthread_cancel）</li>
<li>线程调用pthread_exit函数退出</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>void pthread_exit(void *retval);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_exit接收的参数，就是线程的返回值。</p>

<p>其它线程可以通过pthread_join获取这个值。</p>

<p>注意：</p>

<blockquote><p>pthread_exit的效果等同于在线程执行函数中通过return返回。不同之处是pthread_exit函数可以在任意被线程执行函数调用的函数中使用
pthread_exit的参数不能是线程栈的数据，因为一旦线程结束，栈就被回收，导致返回值被覆盖。</p></blockquote>

<h2>pthread_join函数</h2>

<p>pthread_join函数会等待终止线程。有两种情况：1）如果线程已经终止，则join函数立即返回；2）如果线程还没有终止，则阻塞，直到线程终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;pthread.h&gt;
</span><span class='line'>int pthread_join(pthread_t thread, void **retval); // 成功，返回0
</span></code></pre></td></tr></table></div></figure>


<p>如果retval是个非空指针，则会获取一份线程终止的返回值的拷贝。这个线程返回值或者通过return返回，或者通过调用pthread_exit。</p>

<p>注意：</p>

<blockquote><p>如果join一个已经被join过的线程，则结果是未定义的。比如有可能会join一个刚刚创建的新线程（重用了之前的线程ID）。</p></blockquote>

<p>如果一个线程是非分离状态，则必须对这个线程进行pthread_join操作，如果不这样，则：
* 线程会变成与僵尸进程类似的状态，除了消耗资源外，如果足够多的这种线程存在，我们将不能再创建新线程</p>

<p>还要注意：
* 线程是平级的：意思是同一个进程内的线程，可以pthread_join任意的其他线程。这与进程不一样，进程只能是父进程wait子进程。
* 线程没有pthread_jion任意线程操作。进程可以通过waitpid(–1, &amp;status, options)); 等待任意进程，线程没有这个操作。</p>

<h2>pthread_detach函数</h2>

<p>默认情况下，线程是可<em>结合的（joinable）</em>，可结合的意思，一旦线程终止，任何其它线程都可以通过pthread_join获取其终止状态。</p>

<p>某些情况下，我们不想获取线程的终止状态，希望系统在线程终止时，自动回收线程资源，可以使用pthread_detach函数设置线程是<em>分离的（detached）</em>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>int pthread_detach(pthread_t thread);
</span><span class='line'>// 成功返回0
</span></code></pre></td></tr></table></div></figure>


<p>注意：
1. 一旦设置线程为可分离的，则不能使用pthread_join获取其返回状态了
2. 设置线程为可分离的，则不能再将其设置为可结合的。</p>

<h1>线程参数传递和返回值</h1>

<p>在创建线程时，可能需要传递参数给线程，并可能在线程结束时获取线程返回状态。</p>

<ul>
<li>在调用pthread_create函数创建线程时，可以使用第四个参数传递参数给线程的执行函数</li>
<li>当线程结束时，可以传递返回结果给调用pthread_join的线程，通过：

<blockquote><ul>
<li>在线程执行函数返回一个指针</li>
<li>调用pthread_exit()，把返回值指针作为pthread_exit的参数</li>
</ul>
</blockquote></li>
</ul>


<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>#include &lt;errno.h&gt;
</span><span class='line'>#include &lt;string.h&gt;
</span><span class='line'>
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>/*  our macro for errors checking                                           */
</span><span class='line'>/* **************************************************************************/
</span><span class='line'>#define COND_CHECK(func, cond, retv, errv) \
</span><span class='line'>if ( (cond) ) \
</span><span class='line'> { \
</span><span class='line'>    fprintf(stderr, "\n[CHECK FAILED at %s:%d]\n| %s(...)=%d (%s)\n\n",\
</span><span class='line'>                __FILE__,__LINE__,func,retv,strerror(errv)); \
</span><span class='line'>                   exit(EXIT_FAILURE); \
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'>#define ErrnoCheck(func,cond,retv)  COND_CHECK(func, cond, retv, errno)
</span><span class='line'>#define PthreadCheck(func,rc) COND_CHECK(func,(rc!=0), rc, rc)
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>void *th_func1(void *arg);
</span><span class='line'>void *th_func2(void *arg);
</span><span class='line'>void test_thread_ret();
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  test_thread_ret();
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void test_thread_ret()
</span><span class='line'>{
</span><span class='line'>  int t_ret;
</span><span class='line'>  // pthread ret
</span><span class='line'>  pthread_t t1, t2;
</span><span class='line'>  void *tret;
</span><span class='line'>  t_ret = pthread_create(&t1, NULL, th_func1, NULL);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>  t_ret = pthread_create(&t2, NULL, th_func2, (void *)2);
</span><span class='line'>  PthreadCheck("pthread_create", t_ret);
</span><span class='line'>
</span><span class='line'>  printf("join t1\n");
</span><span class='line'>  t_ret = pthread_join(t1, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 1 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>  printf("join t2\n");
</span><span class='line'>  t_ret = pthread_join(t2, &tret);
</span><span class='line'>  PthreadCheck("pthread_join", t_ret);
</span><span class='line'>  printf("ret of thread 2 is %d.\n", (int) tret);
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>void *th_func1(void *arg)
</span><span class='line'>{
</span><span class='line'>  printf("thread 1 runing\n");
</span><span class='line'>  return (void *)1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void *th_func2(void *arg)
</span><span class='line'>{
</span><span class='line'>  int * a;
</span><span class='line'>  a = (int *)arg;
</span><span class='line'>  printf("thread 2 arg is %d.\n", (int) a);
</span><span class='line'>  pthread_exit((void *) 2);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>取消线程</h1>

<p>线程可以调用pthread_cancel函数<em>请求</em>取消同一进程中的其它线程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;pthread.h&gt;
</span><span class='line'>
</span><span class='line'>int pthread_cancel(pthread_t tid);
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cancel并不等待线程终止仅仅提出请求。</p>

<p>线程在取消请求发出后还继续运行，直到线程打到某个<em>取消点</em>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>

<h1>线程同步</h1>

<p>有三种同步方式：互斥量、读写锁以及条件变量</p>

<h2>互斥量</h2>

<p>互斥量用pthread_mutex_t数据类型表示，使用互斥量之前必须对其进行初始化
* 初始化为常量PTHREAD_MUTEX_INITIALIZER，前提是pthread_mutex_t为静态分配的
* 调用pthread_mutex_init函数初始化动态分配的pthread_mutex_t变量。</p>

<p>注意：
* 如果pthread_mutex_t是动态分配的（比如通过malloc），则须用pthread_mutex_destory函数来师傅内存。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">mutex</span><span class="p">,</span> <span class="kt">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">pthread_mutex_destory</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对互斥量加锁解锁函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对互斥量要找到平衡点，既不使锁得粒度太粗导致线程阻塞，又不能因为锁得粒度太细导致代码复杂性和过多锁导致性能下降。</p>

<h2>读写锁</h2>

<p>与互斥量类似，但是读写锁具有更高的并行性。读写锁有三种状态：
* 读模式下的锁状态
* 写模式下的加锁状态
* 不加锁状态</p>

<p>对于读写锁，有几个特征：</p>

<ul>
<li>一次只能有一个线程可以占有写锁，但是多个线程可以同时占用读锁。</li>
<li>当处于写锁状态时，所有试图对其进行加读锁的线程，都会被阻塞</li>
<li>当处于读锁状态时，所有试图对齐进行加读锁的线程，都可以立即获得</li>
<li>如果在读锁状态下，线程希望以写锁对此锁进行加锁，必须阻塞直到线程释放获的的读锁才可以加上写锁。</li>
<li>为了防止一直处于读锁中而使写锁一直阻塞，一旦进行加写锁阻塞，会阻塞后续对其进行的增加读锁行为。</li>
</ul>


<p>读写锁也叫共享-独占锁。</p>

<p>对读写锁也需要初始化和销毁操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_init</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">,</span> <span class="kt">pthread_rwlockattr_t</span> <span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_destory</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>读写锁加锁操作</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_rdlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_wrlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_rwlock_unlock</span><span class="p">(</span><span class="kt">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 实现读写锁的时候，可能会对共享模式下可获取的锁进行数量限制，因此要检查pthread_rwlock_rdlock()的返回值。</span>
</span></code></pre></td></tr></table></div></figure>


<h2>条件变量</h2>

<p>mutex阻止了多个线程同时访问共享的变量。
条件变量允许一个线程在共享的变量状态改变的时候通知其他线程这个改变，并允许其它线程等待（block）这个通知。</p>

<p>下面代码，没有使用条件变量，只是使用互斥量来实现，来证明在特定情况下，条件变量的用处。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="n">mtx</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">avail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 表示可消费的数目</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在生产线程中的代码</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">avail</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* 仅仅表示有可用资源，其它步骤省略*/</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在主线程中，主要用来消费生产线程生产的数据</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_lock&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 消耗生产的数据 */</span>
</span><span class='line'>      <span class="cm">/* 用生产的数据做一些其它时期 */</span>
</span><span class='line'>      <span class="n">avail</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">errExitEN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;pthread_mutex_unlock&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面用互斥量实现的生产者消费者同步代码，问题有：</p>

<ol>
<li>空耗CPU，会一直持续循环来检查avail的状态</li>
</ol>


<p>条件变量解决了这个问题，允许消费进程在没有数据的时候挂起（wait），当有数据的时候通知线程。</p>

<p>条件变量通常与互斥量联合使用：</p>

<ul>
<li>互斥量保护共享变量的修改</li>
<li>条件变量则用来通知状态的修改</li>
</ul>


<p>条件变量在使用前必须初始化，跟互斥量一样，既可以静态初始化，也可以动态初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// 静态</span>
</span><span class='line'><span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 动态，pthread_cond_t变量是动态分配的。需要调用下面函数</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_destroy</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>基于条件变量的通知和等待</h2>

<p>条件变量的主要操作就是signal（通知）和wait（等待），通知可以一次给一个线程通知，也可以广播给所有等待线程。
wait操作是等待，直到有通知到来。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="kt">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
</span><span class='line'><span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abstime</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面代码是使用条件变量的典型代码：</p>

<figure class='code'><figcaption><span>消耗线程代码</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>         <span class="cm">/* 锁住互斥量          */</span>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">predicate</span><span class="p">)</span> <span class="p">{</span>                    <span class="cm">/* 检查 predicate      */</span>
</span><span class='line'>  <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condvar</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>   <span class="cm">/* go to sleep - recheck pred on awakening    */</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>pthread_cond_wait() 做了以下事情：</p>

<ul>
<li>释放互斥量的锁</li>
<li>让线程进入休眠状态（sleep）</li>
</ul>


<p>当某个线程进入休眠状态，需要有其它线程唤醒它，这就是生产线程：</p>

<figure class='code'><figcaption><span>生产线程</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>              <span class="cm">/* 锁住互斥量       */</span>
</span><span class='line'><span class="n">predicate</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>                             <span class="cm">/* 设置 predicate    */</span>
</span><span class='line'><span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condvar</span><span class="p">);</span>          <span class="cm">/* 唤醒每一个等待条件变量的线程     */</span>
</span><span class='line'><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>               <span class="cm">/* 解锁互斥量     */</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，重要的调用是pthread_cond_broadcast()，他会唤醒每一个等待条件变量的线程。第一个被唤醒的线程还是处于pthread_cond_wait函数调用中。然后，pthread_cond_wait完成了下面操作：</p>

<ul>
<li>重新获得互斥量锁。</li>
</ul>


<p>然后执行就再次检查predicate。</p>

<h3>条件变量实际例子（join任何终止的线程）</h3>

<p>使用pthread_join仅仅可以等待一个指定的线程，并没办法join任何终止的线程。使用条件变量可以实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(信号)]]></title>
    <link href="http://baren.github.io/blog/2014/06/24/signal/"/>
    <updated>2014-06-24T20:00:20+08:00</updated>
    <id>http://baren.github.io/blog/2014/06/24/signal</id>
    <content type="html"><![CDATA[<h1>信号概念</h1>

<p>信号是软中断，提供了一种处理异步事件的方法</p>

<p>关于信号：</p>

<ul>
<li>每个信号都有一个唯一的整数定义，从1开始（不存在为0的信号，值为0可以利用kill函数有其它作用），顺序递增。并且还为每个信号定义了一个名字，以SIG开头。
这些信号定义在signal.h中</li>
<li>产生信号的条件

<blockquote><ul>
<li>用户按终端键，印发终端产生信号</li>
<li>硬件异常产生信号，比如无效的内存引用，除数为0等</li>
<li>进程调用kill函数，将信号发送给另一个进程（包括自己）或进程组（有权限限制）</li>
<li>用户用kill命令给进程发送信号</li>
<li>当检测到某种条件已经发生，并应将信号通知有关进程时，也产生信号。比如SIGURG（网络连接传来数据），SIGPIPE在管道的读进程终止后，一个进程写此管道时产生。</li>
</ul>
</blockquote></li>
</ul>


<!-- more -->


<p>几种处理信号的方式</p>

<ul>
<li>忽略信号——只有两种信号不能忽略，SIGKILL和SIGSTOP，若忽略硬件产生的信号，行为是未定义的</li>
<li>捕捉信号——需要注册一个信号处理函数</li>
<li>执行默认操作——大多数的信号的默认动作是终止信号</li>
</ul>


<h1>signal函数</h1>

<p>unix系统提供了两个改变信号处理的方式：signal和signalaction函数</p>

<p>现在推荐使用signalaction函数实现信号处理。因为signal的实现与系统有关，在程序的移植方面，可能会有问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void (*signal(int sig, void (*func)(int)))(int)
</span><span class='line'>// 参数 void (*func)(int)是信号处理函数指针，接收int信号值参数，并返回void
</span><span class='line'>// signal函数返回一个函数指针，类型与信号处理函数指针一样，返回的是上一个信号处理函数的地址</span></code></pre></td></tr></table></div></figure>


<p>signal函数太复杂，可以使用typedef类型定义简化一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void Sigfunc(int);
</span><span class='line'>
</span><span class='line'>Sigfunc *signal(int Sigfunc *func);
</span></code></pre></td></tr></table></div></figure>


<p>一般，在singal头文件中，还定义了几个函数指针常量，表示出错、忽略和默认：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define SIG_ERR (void (*)())-1 // 把-1强制转换成一个函数指针
</span><span class='line'>#define SIG_DFL (void (*)())0 // 把0强制转换成一个函数指针
</span><span class='line'>#define SIG_IGN (void (*)())1 // 把-1强制转换成一个函数指针
</span></code></pre></td></tr></table></div></figure>


<p>可以使用这几个预定义函数常量，来判断信号捕获程序。</p>

<p>关于信号处理程序，注意点：</p>

<ul>
<li>只能捕获已定义的信号，不能捕获未定义的，比如signal(100, func)，会返回错误</li>
<li>SIGUSR1和SIGUSR2是用户定义信号，可用于应用程序，在mac上，其值是30和31</li>
<li>kill也只能发送已定义的信号值，不能kill -100 pid，这也是错误的</li>
</ul>


<h1>中断的系统调用</h1>

<h2>中断低速系统调用</h2>

<p>若进程调用了一个低速的系统调用，</p>

<p>并且这个系统调用正在阻塞</p>

<p>此时，</p>

<p>捕捉到一个信号。</p>

<p>结果是：该系统调用就被中断不被执行了。</p>

<p><em>注意</em>：
* 必须区分是系统调用还是程序函数。当捕捉到某个信号时，被中断的是内核中正在执行的系统调用
* 还必须区分是低速系统调用还是其它系统调用</p>

<p>低速系统调用是可能是进程阻塞的系统调用，一般包括</p>

<ul>
<li>读写某些类型的文件（管道、终端设备、网络设备），若数据不存在或者不能够接收数据，则会使调用者永远阻塞</li>
<li>打开某些类型的文件，在某个条件发生之前，也可能被阻塞（打开终端设备）</li>
<li>pause和wait，pause会使调用进程一直休眠，指导捕获一个信号</li>
<li>某些ioctl操作</li>
<li>某些进程间通信函数</li>
</ul>


<p>这个需要注意的是，磁盘IO操作并不是低速系统调用。</p>

<h2>低速系统调用被中断后的处理和重启</h2>

<p>一旦低速系统调用被中断，系统调用就失败了，此时，该系统调用出错，并且，系统会设置全局变量error的值为EINTR。</p>

<p>这样我们就能够处理这种失败。有两种处理方式：</p>

<ul>
<li>系统调用失败时手动检查，并根据信号再次调用系统调用或者其它动作</li>
<li>某些中断的系统调用支持自动重启动</li>
</ul>


<h3>手动检查</h3>

<p>比如可以这样处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>while((cnt=read(fd, buf, BUF_SIZE)) == -1 && errno == EINTR)  // read返回错误，并且全局变量为EINTR，表示被中断
</span><span class='line'>  continue;  // 啥也不做
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<p>如果经常使用这种检查，还可以定义一个宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NO_EINTR(stmt)   while((stmt) == -1 && errno == EINTR);
</span><span class='line'>
</span><span class='line'>// 然后
</span><span class='line'>
</span><span class='line'>NO_EINTR(cnt == read(fd, buf, BUF_SIZE));
</span><span class='line'>
</span><span class='line'>if (cnt == -1)    // read读取错误，而不是被中断
</span><span class='line'>  errExit("read");  </span></code></pre></td></tr></table></div></figure>


<h3>自动重启动</h3>

<p>为了解决以上这种经常性的重复检查问题，4.2BSD系统引物了某些被中断的系统调用的自动重启动。并不是所有的系统调用都支持自动重启动，只有下列函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wait waitpid read write ioctl readv writev
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用系统调用的重启动功能，可以使用sigaction函数，指定flag为SA_RESTART即可。</p>

<h1>可重入函数</h1>

<p>在信号处理程序中，不能调用不可重入函数。</p>

<p>所谓不可重入函数是指：</p>

<ol>
<li>它们使用了静态数据结构或全局变量</li>
<li>调用malloc和free，因为malloc维护了一个全局链表</li>
<li>标准IO函数</li>
</ol>


<p>而可重入函数，一般是指：
* 线程安全函数，既任何一个进程内，多个线程可以同时执行的函数</p>

<p>在标准C函数库中，不可重入函数比较普遍。</p>

<p>比如malloc和free
，在主程序中调用malloc过程中，产生了信号，并在信号处理程序中调用了malloc，有可能会破坏malloc维护的链表，导致不可预料的结果发生。</p>

<h1>可靠信号的术语和语义</h1>

<ul>
<li>递送（delivery）信号：当引发信号的事件<em>发生</em>时，为进程产生一个信号（或向进程产生一个信号）</li>
<li>未决（pending）的信号：在信号产生和递送之间的时间间隔内，称信号是未决的</li>
</ul>


<p>进程可以设置阻塞信号。</p>

<p>若信号被进程设置为阻塞，并且对该信号的动作是系统<strong>默认动作</strong>或<strong>捕捉该信号</strong>，则为该进程将此信号保持为未决状态（产生信号和递送信号之间的状态）。</p>

<p>解除未决状态：
    * 对信号解除了阻塞
    * 或者将此信号的动作改为忽略。</p>

<p>注意：
* 如果信号处理函数不是默认或者捕捉（比如忽略），则信号不会保持为未决状态，
看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>void sig_int(int sig);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t osig;
</span><span class='line'>  sigset_t newsig, o_set;
</span><span class='line'>
</span><span class='line'>  sigemptyset(&newsig);
</span><span class='line'>  sigaddset(&newsig, SIGINT);
</span><span class='line'>  // if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 忽略处理
</span><span class='line'>  if (signal(SIGINT, SIG_DFL) == SIG_ERR) // 默认处理
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &newsig, &osig) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  //pause();
</span><span class='line'>  sleep(4);
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_int) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("signal sigint 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &osig, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask 1 err!\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf(" pause ...\n");
</span><span class='line'>  sigprocmask(0, NULL, &o_set);
</span><span class='line'>  if (sigismember(&o_set, SIGINT))
</span><span class='line'>  {
</span><span class='line'>      printf("is mask\n");
</span><span class='line'>  }
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>void sig_int(int sig)
</span><span class='line'>{
</span><span class='line'>  printf("int sig hand\n");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>执行结果是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果是默认处理，在sleep过程中，产生中断信号，结果是：
</span><span class='line'>$ ./test_pend
</span><span class='line'>^Cint sig hand
</span><span class='line'> pause ...
</span><span class='line'>
</span><span class='line'> 如果改成忽略，在sleep过程中，产生中断信号，结果是：
</span><span class='line'> ./test_pend
</span><span class='line'>^C pause ...</span></code></pre></td></tr></table></div></figure>


<p>注意：
* 在进程解除对某个信号的阻塞之前，信号发生了多次，大多数系统都只递送这种信号一次。</p>

<h1>kill和raise函数</h1>

<p>kill函数将信号发送给进程或进程组
raise函数允许进程向自身发送信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int kill(pid_t pid, int signo);
</span><span class='line'>int raise(int signo);</span></code></pre></td></tr></table></div></figure>


<p>下面是等价的：</p>

<p>raise(signo) == kill(getpid(), signo)</p>

<p>kill函数的pid参数，有四种不同情况：
* pid >0——发送给pid
* pid == 0 ——将信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组ID等于发送进程的进程组ID）（有权限限制）
* pid &lt; 0 ——发送给进程组ID为|pid|的进程（有权限限制）
* pid == -1 —— 将信号发送给发送进程有权限向它们发送信号的系统上的所有进程。</p>

<p>上面提到了，给其它进程发信号需要权限，具体是指：</p>

<ul>
<li>超级用户可以将信号发送给任一进程</li>
<li>非超级用户，规则是发送者的实际或者有效用户ID必须等于接收者的实际或者有效用户ID，若设置了“设置用户权限位”，则检查保存的设置用户ID</li>
</ul>


<p>注意： 若signo为0，定义为空信号，kill扔执行正常的错误检查，但不发送信号。这常被用来：
* 确定一个特定的进程是否仍旧存在，若进程不存在，则返回-1，并将errno设置为ESRCH</p>

<h1>alarm和pause函数</h1>

<p>alarm函数可以设置一个计时器，在将来某个指定的时间，该计时器会超时
* 当计时器超时时，产生SIGALRM信号。
* 若不忽略或者不捕捉此信号，则默认动作是终止调用该alarm函数的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>unsigned int alarm(unsigned int seconds);</span></code></pre></td></tr></table></div></figure>


<p>对于alarm，注意：
* 每个进程只能有个闹钟时钟
* 调用alarm时，以前为该进程设置过闹钟时钟，且没有超时，则将该预留值作为本次alarm调用的值返回，用新值地带旧的
* 之前调用过alarm，并没有超时，本次调用seconds为0，则取消之前设置的</p>

<p>pause函数使调用进程挂起直到捕捉到一个信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>int pause(void)</span></code></pre></td></tr></table></div></figure>


<p>条件：
* 只有执行了一个信号处理程序并从其返回时，pause才返回，此时pause返回-1，并设置errno为EINTR</p>

<h2>使用alarm实现sleep函数，并暴露问题</h2>

<p>使用信号时，需要精细而周到的考虑，下面代码列出几个问题：</p>

<ul>
<li>问题1：竞争条件</li>
</ul>


<p>看下面的sleep1的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unsigned int sleep1(unsigned int nsecs)
</span><span class='line'>{
</span><span class='line'>  if(signal(SIGABRT, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("can't signal alarm!\n");
</span><span class='line'>      return nsecs;
</span><span class='line'>  }
</span><span class='line'>  alarm(nsecs);
</span><span class='line'>  pause();
</span><span class='line'>  return (alarm(0)); // 返回未完成的时间
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  ;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这段代码的实现问题是：
1. 修改了alarm信号的处理函数（如果之前注册过）
2. 如果之前调用过alarm，这个sleep1的实现，在第一次调用alarm会抹掉之前设置
3. 有竞争条件，如果系统繁忙，在alarm后pause之前时间到期，则pause会一直等待。</p>

<ul>
<li>问题2：涉及到其它信号交互时，会产生新的问题，这里的代码产生的问题是回提前终止其它信号的处理程序</li>
</ul>


<p>使用setjmp和longjmp函数来优化上面的sleep1的实现，主要解决第三个问题，也就是竞争条件的问题。</p>

<p>第三个问题，主要是在alarm和pause之间，出现竞争条件。使用setjmp和longjmp，可以绕过这个问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>static jmp_buf env_alrm;
</span><span class='line'>int sleep2(int);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sleep2(2);
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int sleep2(int sec)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sigalarm err!\n");
</span><span class='line'>      return sec;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alrm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(sec);
</span><span class='line'>      pause();
</span><span class='line'>  }
</span><span class='line'>  return (alarm(0));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>  longjmp(env_alrm, 1);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这个实现，有个很难察觉到的问题，涉及到其它信号处理程序：如果alarm处理函数中断了正在执行的其它信号处理程序，则调用longjmp导致其它信号处理程序提早终止了（longjmp跳到sleep2的setjmp地方，而不是继续原来的步骤）。</p>

<h2>除了实现sleep，还可以实现对于可能阻塞的操作设置时间上限</h2>

<p>下面例子，简单使用alarm和pause，模拟实现了一个可以超时的read函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout);
</span><span class='line'>
</span><span class='line'>static jmp_buf env_alarm;
</span><span class='line'>void sig_alarm(int signo);
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  char line[100];
</span><span class='line'>  int n;
</span><span class='line'>  n = read_timeout(STDIN_FILENO, line, 100, 3);
</span><span class='line'>  if(n &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("read timeout\n");
</span><span class='line'>  } else {
</span><span class='line'>      printf("read len %d.\n", n);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span><span class='line'>int read_timeout(int fd, void *buf, size_t size, int timeout)
</span><span class='line'>{
</span><span class='line'>  int n = 0;
</span><span class='line'>  if(signal(SIGALRM, sig_alarm) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig alarm err\n");
</span><span class='line'>      return -1;
</span><span class='line'>  }
</span><span class='line'>  if(setjmp(env_alarm) == 0)
</span><span class='line'>  {
</span><span class='line'>      alarm(timeout);
</span><span class='line'>      if((n=read(fd, buf, size)) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("read err!\n");
</span><span class='line'>          return n;
</span><span class='line'>      }
</span><span class='line'>      alarm(0);
</span><span class='line'>      return n;
</span><span class='line'>  }
</span><span class='line'>  return -1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_alarm(int signo)
</span><span class='line'>{
</span><span class='line'>      longjmp(env_alarm, 1);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>read timeout
</span><span class='line'>user@usertekiMacBook-Pro unix_test$
</span><span class='line'>user@usertekiMacBook-Pro unix_test$ ./read_timeout
</span><span class='line'>dd
</span><span class='line'>read len 3.</span></code></pre></td></tr></table></div></figure>


<p>注意：同样，上面这个简单程序，涉及到其它信号时，也会出现提前中断其它信号处理函数的问题。</p>

<h1>信号集</h1>

<p>可以使用sigset_t 数据结构代表信号集，并定义了下列五个处理信号集的函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigempty(sigset_t *set);
</span><span class='line'>int sigfillset(sigset_t *set);
</span><span class='line'>int sigaddset(sigset_t *set, int signo);
</span><span class='line'>int sigdelset(sigset_t *set, int signo);
</span><span class='line'>  // 四个函数返回值：成功，返回0，失败返回-1
</span><span class='line'>int sigismember(const sigset_t *set, int signo);
</span><span class='line'>  // 若真，返回1，假，返回0，出错，返回-1
</span></code></pre></td></tr></table></div></figure>


<h1>sigpromask函数</h1>

<p>调用sigprocmask函数，可以检测或修改其信号屏蔽字或者一个步骤同时执行测试和修改两个动作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);  // 成功，返回0，失败返回-1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>oset非空，则进程当前信号屏蔽字通过oset返回</li>
<li>set非空，则根据第一个参数how指示如何修改当前信号屏蔽字</li>
<li>set为空，不改变</li>
</ul>


<p>how的值：</p>

<ul>
<li>SIG_BLOCK: 新屏蔽字是当前信号屏蔽字+set的并集</li>
<li>SIG_UNBLOCK: 新屏蔽字是当前信号屏蔽字+set的交集</li>
<li>SIT_SETMASK: 被set指向的值替代</li>
</ul>


<h1>sigpending函数</h1>

<p>sigpending函数返回信号集，其中的各个信号对于调用进程是阻塞的，因此不能diliver，因此是未决的。简单说就是返回未决的信号集。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigpending(sigset_t *set);</span></code></pre></td></tr></table></div></figure>


<p>注意：信号处理函数设置为捕捉函数和默认动作，信号是阻塞的。这是发生的信号都是未决的。被block的信号都会等待，知道解除阻塞信号。</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_quit(int);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>  sigset_t oldset, newset, quitset;
</span><span class='line'>  sigemptyset(&quitset);
</span><span class='line'>  sigaddset(&quitset, SIGINT);
</span><span class='line'>
</span><span class='line'>  // ************这段程序，注释掉，则采用默认值，不注释掉，则采用设置的捕捉函数，可以观察到，信号是如何pending，并在解除后如果递送的。
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  } 
</span><span class='line'>  // ************
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_BLOCK, &quitset, &oldset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  // sleep 5 seconds
</span><span class='line'>  sleep(5);
</span><span class='line'>  if (sigpending(&newset) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("pending err \n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if (sigismember(&newset, SIGINT))
</span><span class='line'>      printf("sigquit is block\n");
</span><span class='line'>
</span><span class='line'>  if (sigprocmask(SIG_SETMASK, &oldset, NULL) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("mask ret sig err!\n");
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  printf("sig int unblock\n");
</span><span class='line'>  sleep(5);
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_quit(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("sigquit catch\n");
</span><span class='line'>
</span><span class='line'>  if (signal(SIGINT, sig_quit) == SIG_ERR)
</span><span class='line'>  {
</span><span class='line'>      printf("sig err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>sigaction函数</h1>

<p>sigaction函数的功能是<em>检查</em>或<em>修改</em>与指定信号相关联的处理动作（或同时执行）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
</span><span class='line'>// 成功，返回0，出错返回-1
</span></code></pre></td></tr></table></div></figure>


<p>对于参数：</p>

<ul>
<li>signo是信号</li>
<li>act非空，则修改信号动作</li>
<li>oact非空，则由oact返回上一个动作</li>
</ul>


<p>结构体struct sigaction的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct sigaction {
</span><span class='line'>  void (*sa_handler)(int); // 信号处理函数的地址，或者SIG_IGN或SIG_DFL
</span><span class='line'>  sigset_t sa_mask; // 额外需要阻塞的信号集
</span><span class='line'>  int sa_flags;  // 信号选项，可以设置这个选项来控制处理函数行为
</span><span class='line'>
</span><span class='line'>  /*替换的处理程序，当指定sa_flags为SA_SIGINFO时，采用这个处理函数，提供了额外的一些信息*/
</span><span class='line'>  void (*sa_sigaction)(int, siginfo_t *, void *);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>若更改信号处理函数，则：
* sa_handler指定处理函数的地址
* sa_mask则是信号集，在调用该信号处理函数之前，会先把这个信号集指定的信号加到进程的信号屏蔽字中。信号处理函数返回时，再复原。在信号处理程序被调用时，操作系统建立的新信号屏蔽字也包括正在被递送的信号，这会保证在当前信号处理时，这个信号再次发生，会一直阻塞，直到处理函数完成。
* sa_flags字段指定对信号处理的各个选项:</p>

<blockquote><ul>
<li>SA_RESTART:由此信号中断的系统调用自动重新启动</li>
<li>SA_INTERRUPT: 由此信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 有此选项对信号，会调用sa_sigaction函数，此函数会给额外提供了附加信息：1）指向siginfo结构的指针；2）指向进程上下文标识符的指针</li>
</ul>
</blockquote>

<p>注意：</p>

<blockquote><p>除了那些为了兼容而继续保留原始的signal函数的语义的系统外，大部分系统都是用sigaction来实现signal函数的。</p></blockquote>

<h1>sigsetjmp和siglongjmp函数</h1>

<p>在捕捉到一个信号时，会进入信号捕捉函数，此时会发生：</p>

<ul>
<li>进入信号处理函数时，当前信号会被自动加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断该信号处理程序</li>
<li>当正常从信号处理函数中返回时，会自动恢复当前信号为非屏蔽</li>
</ul>


<p>但是，当在信号处理函数内，调用了longjmp函数，那么是否恢复这个被屏蔽的当前信号？</p>

<p>FreeBSD 5.2.1 和Mac OS X10.3中，setjmp和longjmp保持和恢复信号屏蔽字</p>

<p>Linux2.4.22和Solaris9 并不执行这种操作。FreeBSD 5.2.1 和Mac OS X10.3提供函数<em>setjmp和</em>longjmp，他们不保存和恢复信号屏蔽字</p>

<p>为了允许两种形式的行为存在， POSIX.1并没有说明setjmp和longjmp对屏蔽字的作用，而是定义了两个新函数sigsetjmp和siglongjmp。在信号处理程序中进行非局部跳转是，使用这两个。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt; // 与setjmp和longjmp一个头
</span><span class='line'>
</span><span class='line'>int sigsetjmp(sigjmp_buf env, int savemask); // 直接调用，返回0，若从siglongjmp调用返回，则返回非0值
</span><span class='line'>
</span><span class='line'>void siglongjmp(sigjmp_buf env, int val);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>若savemask非零，则env保存进程的当前屏蔽字。并在siglongjmp调用时，恢复由env保存进程的当前屏蔽字。</p>

<p>涉及到信号时，使用sigsetjmp和siglongjmp的典型使用模板是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static sigjmp_buf;
</span><span class='line'>static volatile sig_atomic_t canjump;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>// 在主函数中
</span><span class='line'>if (sigsetjmp(jmpbuf, 1)) {
</span><span class='line'>  ....
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>canjump = 1; // 调用sigsetjmp后才设置canjump为非零
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 然后，在信号处理程序中，这样：
</span><span class='line'>void sig_handler(int) {}
</span><span class='line'>
</span><span class='line'>if (canjmp == 0) // 只有非零时，才调用siglongjmp
</span><span class='line'>  return
</span><span class='line'>
</span><span class='line'>....
</span><span class='line'>
</span><span class='line'>siglongjmp(jmpbuf, 1);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<blockquote><p>原因：
之所以使用canjump，主要是保护机制，防止当jmpbuf还没有被sigsetjmp初始化时，就调用了信号处理程序。
在非信号环境下没有问题，但在信号环境下，信号是随时发生的，因此需要保护</p></blockquote>

<h1>sigsuspend函数</h1>

<p>屏蔽进程的信号，使用这种技术，可以保护不希望由信号中断的代码临界区。然后在临界区之后等待以前的信号发生。</p>

<p>但是下面的实现方式有问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sigprocmask(SIG_BLOCK, &newmask, &oldmask);
</span><span class='line'>
</span><span class='line'>// .....临界区代码
</span><span class='line'>
</span><span class='line'>1) sigprocmask(SIG_BLOCK, &oldmask, NULL);
</span><span class='line'>2) pause(); // 等待之前阻塞的信号发生
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，1）和2）代码出有问题，会有竞争条件，在sigprocmask和pause之间有可能信号会发生，这会导致pause无法返回，永远阻塞。</p>

<p>解决这个竞争条件的办法就是让这两个操作合并成一个原子操作。这就是sigsuspend函数的由来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>
</span><span class='line'>int sigsuspend(const sigset_t * sigmask);
</span></code></pre></td></tr></table></div></figure>


<p>用sigsuspend实现临界区代码，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;signal.h&gt;
</span><span class='line'>#include &lt;sys/signal.h&gt;
</span><span class='line'>
</span><span class='line'>void sig_int(int signo);
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>  sigset_t newsigset, oldsigset, waitsigset;
</span><span class='line'>  sigemptyset(&newsigset);
</span><span class='line'>  sigaddset(&waitsigset, SIGUSR1);
</span><span class='line'>  struct sigaction act;
</span><span class='line'>  act.sa_handler = sig_int;
</span><span class='line'>
</span><span class='line'>  if(sigaction(SIGINT, &act, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("siganction err.\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(sigprocmask(SIG_BLOCK, &newsigset, &oldsigset) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("sigprocmask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  // code procted
</span><span class='line'>  printf("this is procted code!\n");
</span><span class='line'>
</span><span class='line'>  if(sigsuspend(&waitsigset) != -1)
</span><span class='line'>  {
</span><span class='line'>      printf("sigsuspend err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  printf("after sigsuspend\n");
</span><span class='line'>  if(sigprocmask(SIG_SETMASK, &oldsigset, NULL) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("revert old sig mask err\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void sig_int(int signo)
</span><span class='line'>{
</span><span class='line'>  printf("catch signo %d\n", signo);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意sigsuspend函数实现的巧妙之处：</p>

<ul>
<li>为了实现解除屏蔽（sigprocmask）和等待（pause），sigsuspend把进程的屏蔽信号设置为参数信号，并在返回后设置为调用sigsuspend之前的屏蔽信号值。</li>
</ul>


<p>sigsuspend函数还有两种经典应用：</p>

<ol>
<li>等待一个信号处理程序设置一个全局变量</li>
<li>父子进程实现同步</li>
</ol>


<p>注意：在实现父子进程通讯，可以使用kill给对象发信号，并使用sigsuspend等待某种条件</p>

<h1>abort函数</h1>

<p>abort函数使异常程序终止。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void abort(void);
</span></code></pre></td></tr></table></div></figure>


<p>这个函数将SIGABRT信号发送给调用进程。</p>

<p>ISO C规定 abort的实现须向主机环境递送一个成功的通知，一般是通过raise(SITABRT)或kill(gitpid(), SIGABRT)实现，这个规定，允许程序做清理工作。</p>

<p>一般系统的abort实现，都会冲洗输出流以及是否要删除临时文件。</p>

<p>可以看一下abort的函数实现示例，通过这个示例，学会：</p>

<ul>
<li>sigaction函数的使用</li>
<li>kill函数的使用：kill函数可以给其它进程发送信号。若发给本进程，并且此信号是不被阻塞的，那么kill返回之前，该信号（或某个未决、未阻塞的信号）就被传送给了该进程。这样，kill返回了，就知道该进程一定捕捉到该信号。</li>
</ul>


<h1>system函数</h1>

<p>ISO C定义了system函数，这个函数可以执行系统命令，这个函数的实现也牵扯到信号问题。若不处理，会有问题。</p>

<p>这里通过system的实现，注意信号程序开发的各种问题。</p>

<p>看下面调用过程：
<img src="http://baren.github.io/images/assets/Figure10-1.png" title="time-function" alt="alt text" /></p>

<p>若没有处理信号，问题有：</p>

<ul>
<li>若进程（a.out）捕获SIGCHID信号，当system创建的子进程结束，系统会向父进程（a.out）发送SIGCHID信号，父进程会捕捉。<em>但这阻止了system函数获取它自己创建子进程的状态</em></li>
<li>若system系统没有屏蔽中断和退出信号，则如果想给shell调用程序发送中断信号时，系统会同时向负责进程发送信号（因为都属于前台进程组）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程关系)]]></title>
    <link href="http://baren.github.io/blog/2014/05/04/process-relate/"/>
    <updated>2014-05-04T20:00:26+08:00</updated>
    <id>http://baren.github.io/blog/2014/05/04/process-relate</id>
    <content type="html"><![CDATA[<h1>终端登录</h1>

<p>由终端登录至unix，这个过程是类似的，而与所使用的终端无关，终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端，或者是运行窗口系统的图形终端。</p>

<p>终端登录步骤：</p>

<ol>
<li>系统自举时，创建进程ID为1的init进程。使系统进入多用户状态。</li>
<li>init进程读取文件/etc/ttys，对每一个允许登录的终端设备，init进程调用一次fork，fork后的子进程执行getty程序（exec getty程序）</li>
<li>getty程序会调用open函数，以读写方式打开终端，一旦打开设备，则文件描述符0、1、2设置到该设备，输出login:之类的信息</li>
<li>gettty调用login函数（<code>execle("/bin/login", "login", "-p", username, (char *) 0, envp);</code>）</li>
<li>login执行多个工作

<blockquote><p>验证用户、密码正确性，连续几次不对，则退出；父进程init知道子进程终止后，会再次调用fork，执行getty，重复上述动作。登录成功后：
将当前工作目录改为该用户的起始目录（home目录）
chown改变该终端的所有权，使登录用户成为它的所有者
对该终端设备的访问权限改为用户读写
调用setgid及initgroups设置进程的组id
用login所得到的所有信息初始化环境
调用该登录用户的登录shell</p></blockquote></li>
</ol>


<!-- more -->


<h1>网络登录</h1>

<p>在网络登录情况下，所有的登录都是通过内核的网络接口驱动程序（以太网驱动程序），事情并不知道会有多少这样的登录。必须等待一个网络连接请求的到达。</p>

<p>网络登录，一个特点是：1）既能处理终端登录；2）处理网络登录。为了实现，系统采用<em>伪终端</em>（pseudo terminal）的软件驱动程序。</p>

<p>伪终端仿真：</p>

<ul>
<li>串行终端的运行行为，</li>
<li>并将终端操作映射为网络操作，反之亦然</li>
</ul>


<h2>BSD网络登录</h2>

<p>在BSD中，inetd进程负责等待大多数的网络连接。</p>

<p>启动inetd进程的步骤：</p>

<ol>
<li>init进程调用shell，使shell程序执行/etc/rc脚本，</li>
<li>这个脚本启动守护进程inetd，然后shell脚本结束，inetd的父进程变成init。</li>
<li>inetd进程等待TCP/IP连接，当一个连接请求到达时，执行一次fork，生成子进程执行适当的程序。</li>
</ol>


<p>以telnet网络登录为例。</p>

<p>hostname启动的程序被称为telnet服务进程（称为telnetd）。</p>

<p>客户端进行网络登录命令：telnet hostname，这样客户端和hostname以telnet应用协议通过tcp连接交换数据。</p>

<p>然后，</p>

<p>服务端telnetd打开一个伪终端设备，并用fork分成两个进程。</p>

<ul>
<li>父进程处理网络连接的通信</li>
<li>子进程执行login程序</li>
<li>父子进程通过伪终端程序相连接</li>
</ul>


<p>login登录成功，则进行上一节同样的步骤：更改当前工作目录为起始目录，设置登录用户的组ID合用户ID，以及登录用户的初始环境。
然后login调用exec将其自身替换为登录用户的登录shell。</p>

<p>注意：
linux的因特网守护进程是xinetd。</p>

<h1>进程组</h1>

<p>进程组是一个或多个进程的集合。一般进程组与同一个作业相关联（比如shell中，多个命令用管道合起来，这几个命令分别是一个进程，合起来组成一个进程组）。可以接收同一终端的各种信号。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>// 返回调用进程的进程组id
</span><span class='line'>pid_t getpgrp(void);
</span></code></pre></td></tr></table></div></figure>


<p>Sigle UNIX Specification将getpgid函数定义为XSI扩展，模仿了此种运行行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t getpgid(pid_t pid);
</span></code></pre></td></tr></table></div></figure>


<p>若参数pid为0，则返回调用进程的进程组id，这时：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getpgid(0) == getpgrp()</span></code></pre></td></tr></table></div></figure>


<p>进程组可以有一个组长进程。条件是：</p>

<ul>
<li>组长进程的ID等于组的ID</li>
</ul>


<p>组长进程的权限：</p>

<ul>
<li>创建一个进程组</li>
<li>创建该组中的进程</li>
</ul>


<p>进程组中，只要有一个进程存在，进程组就存在，这与组长进程的存在与否无关。</p>

<p>进程组的生存期是：进程组创建到最后一个进程终止，最后一个进程可以终止，也可以转移到另一个进程组。</p>

<p>加入一个进程组或者创建进程组：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int setpgid(pid_t pid, pid_t pgid);
</span></code></pre></td></tr></table></div></figure>


<p>setpgid函数将pid进程的进程组ID设置为pgid。</p>

<ul>
<li>如果这两个参数相等，则由pid指定的进程变成进程组组长，</li>
<li>如果pid是0，则使用调用者的进程ID。</li>
<li>如果pgid为0，则由pid指定的进程ID将用作进程组ID</li>
</ul>


<p>调用条件：</p>

<ul>
<li>一个进程只能为它自己或者它的子进程设置进程组ID，</li>
<li>在它的子进程调用了exec函数之一后，它就不能再改变该子进程的进程组ID</li>
</ul>


<p>在大多数的作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并使子进程设置其自己的进程组ID。</p>

<h1>会话</h1>

<p>会话是一个或多个进程组的集合。</p>

<p>例如下面程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>proc1  | proc2 &
</span><span class='line'>proc3 | proc 4 | proc5
</span></code></pre></td></tr></table></div></figure>


<p>会产生如下会话，包括三个进程组：
1. 登录shell
2. proc1和proc2属于一个进程组
3. proc3和proc4和proc5属于一个进程组</p>

<p>可以使用setsid函数建立新会话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>pid_t setsid(void);
</span></code></pre></td></tr></table></div></figure>


<p>如果调用这个函数的进程不是一个进程组的组长，则此函数就会创建一个新会话，结果将发生下面三件事：</p>

<ol>
<li>该进程会变成新会话的首进程（session leader）（会话首进程是创建该会话的进程），此时该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程，新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也会中断。</li>
</ol>


<p>如果该进程已经是一个进程组的组长，则函数返回出错。为了防止这种情况，一般先fork再调用。</p>

<h1>控制终端</h1>

<ul>
<li>一个会话可以有一个控制终端，通常是登录到其上的终端设备或者伪终端设备。</li>
<li>建立与控制终端的会话首进程被称为控制进程</li>
<li>一个会话中得几个进程组可被分成<em>一个</em>前台进程组以及一个或者多个后台进程组</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，会话中的其它进程组为后台进程组</li>
<li>无论何时键入终端的中断键（ctrl+c），就会将中断信号发送给前台进程组的所有进程</li>
<li>无论何时键入终端的退出键（ctrl+\），将会将退出信号发送给前台进程组中所有进程</li>
<li>如果终端接口检测到调制解释器或网络已经断开连接，则将挂断信号发送给控制进程（会话首进程）</li>
</ul>


<h1>作业控制</h1>

<p>略</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程控制)]]></title>
    <link href="http://baren.github.io/blog/2014/05/04/process-control/"/>
    <updated>2014-05-04T20:00:02+08:00</updated>
    <id>http://baren.github.io/blog/2014/05/04/process-control</id>
    <content type="html"><![CDATA[<h1>进程标识符</h1>

<p>进程都有一个非负整数代表唯一的进程ID。</p>

<p>当进程终止后，进程ID可以重用，为了防止将新进程视为使用同一个进程ID的旧的进程，系统采用了<em>延迟重用</em>算法来重用进程ID。</p>

<p>系统启动后有一些专用进程：</p>

<ul>
<li>ID为0的进程——调度进程，也称为交换进程（swapper），这个进程是内核的一部分，不执行磁盘上的程序，被称为系统进程。</li>
<li>ID为1的进程——init进程，自举结束时由内核调用；早期的进程文件是/etc/init，现在都是/sbin/init。init通常读取系统的配置文件来初始化系统（/etc/rc*或/etc/initab, /etc/init.d）。init进程不会终止，虽然是普通进程，但是以超级用户权限运行，还接收孤儿进程，是所有孤儿进程（子进程还活着，父进程终止了，称为孤儿进程）父进程。</li>
</ul>


<p>下面函数返回与进程相关的其他标识符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t getpid(void);
</span><span class='line'>
</span><span class='line'>pid_t getppid(void);
</span><span class='line'>
</span><span class='line'>uid_t getuid(void);  // 实际用户id
</span><span class='line'>
</span><span class='line'>uid_t geteuid(void);  // 有效用户id
</span><span class='line'>
</span><span class='line'>gid_t getgid(void);  // 实际组id
</span><span class='line'>
</span><span class='line'>gid_t getegid(void);  // 有效组id
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h1>fork函数</h1>

<p>可以调用<code>fork</code>函数创建一个新进程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t fork(void);
</span></code></pre></td></tr></table></div></figure>


<p>fork创建的新进程被称为子进程。fork调用一次返回两次：</p>

<ul>
<li>子进程返回0.</li>
<li>父进程返回子进程的ID，如果返回-1，表示创建进程出错</li>
</ul>


<p>返回后，父进程和子进程继续执行调用fork之后的指令。</p>

<p>fork后，子进程是父进程的副本。比如子进程获得父进程的数据空间，堆和栈的副本。父子进程不共享这些，只是共享正文段。</p>

<p>一般fork后都执行exec函数，因此现在的系统在fork的实现上，并不立即完全复制父进程的数据段、堆栈的完全复制，而是采用copy-on-write的技术，只有在父或子进程写的时候才进行复制，复制也是仅仅复制写的那块区域，一般就是存储系统中的一页。</p>

<p>在fork后，是先返回父进程还是子进程，是不确定的，取决于系统的调度算法的实现。</p>

<p>如果fork后没有调用exec，子进程与父进程执行同一代码，则需要注意调用fork之前的IO流缓冲问题。</p>

<ul>
<li>如果之前有IO流缓冲，则可能会被子进程和父进程各调用一次，伪代码：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>printf("。。。");  // 如果标准输出被重定向到一个文件，则是全缓冲的。
</span><span class='line'>
</span><span class='line'>pid = fork()
</span><span class='line'>if(pid == 0){
</span><span class='line'>  exit()
</span><span class='line'>} else if (pid == -1) {
</span><span class='line'>  printf('error')
</span><span class='line'>} else {
</span><span class='line'>  exit()
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面代码，如果printf的标准输出重定向到文件，则是全缓冲的，因此调用printf的时候，有可能把数据存放到缓冲中。</p>

<p>这样，fork后，父子进程各有一个缓冲，因此exit后，printf各被flush，因此父子进程都会打印printf的输出。</p>

<blockquote><p>注意：
strlen() 和sizeof()的区别。strlen是返回不包含null终止符的字符串的长度。sizeof返回包含null终止符的缓冲区的大小。
strlen() 是一次函数调用。而sizeof在编译时期就知道大小。</p></blockquote>

<h2>文件共享</h2>

<p>fork的一个特征是文件进程所有打开文件的描述符都被复制到子进程。</p>

<p>这样父子进程每个相同的打开描述符共享一个文件表项（内核为每个打开的文件维持文件表，若两个进程打开同一个文件，每个进程都有自己的文件表项。但是fork后，两个进程就会共享同一个文件表项，也就是共享偏移量。）</p>

<p>如图：</p>

<p>如果两个进程打开同一个文件，每个进程都有自己的文件偏移量：
<img src="http://baren.github.io/images/assets/Figure8-1.png" title="time-function" alt="alt text" /></p>

<p>如果fork后，父进程和子进程则共享一个文件表项，共享文件偏移量：
<img src="http://baren.github.io/images/assets/Figure8-2.png" title="time-function" alt="alt text" /></p>

<p>fork后处理文件描述符的两种情况：</p>

<ol>
<li>父进程等子进程完成，在这种情况下，父进程无需对描述符进行任何处理，当子进程结束后，父进程的偏移量也已经被更新。</li>
<li>父子进程各自执行不同的程序段，fork，父子进程各自关闭不需要的文件描述符，这样不会干扰对方使用的文件描述符。网络服务进程常用这种方式。</li>
</ol>


<p>除了文件，许多其它属性也被子进程继承：</p>

<ul>
<li>实际用户（组）ID，有效用户（组）ID</li>
<li>会话ID</li>
<li>环境</li>
</ul>


<p>注意：
 父进程的文件锁不会被继承</p>

<p> fork的两种用法：</p>

<ol>
<li>父进程希望复制自己，是父子进程执行不同的代码段（比如网络服务）</li>
<li>子进程执行一个不同的程序，比如shell</li>
</ol>


<h1>vfork函数</h1>

<p>vfork的目的是创建一个新进程，而该进程的目的是exec一个新进程。</p>

<p>vfork与fork调用相同，有两点不同：</p>

<ul>
<li>vfork不会复制父进程的地址空间，在子进程调用exec或exit之前，子进程在父进程的地址空间中执行（意味着会修改父进程的变量等）</li>
<li>vfork函数保证子进程先执行，在它调用exec或exit之后，父进程才被调度运行</li>
</ul>


<h1>exit函数</h1>

<p>5种正常终止进程的方式：</p>

<ul>
<li>main函数中return返回，等效于调用exit函数</li>
<li>调用exit函数。ISO C定义的函数，操作包括1）调用终止处理程序（atexit注册的函数）；2）关闭所有标准IO流描述符</li>
<li>调用<em>exit或</em>Exit函数。ISO C定义_Exit函数。这两个函数的目的是提供一种无需运行终止处理程序（atexit注册的函数）或信号处理程序而终止的方法；这两个函数一般都不对标准IO流进行冲洗。</li>
<li>进程最后一个线程在启动例程中执行返回语句，进程终止状态为0</li>
<li>进程最后一个线程调用pthread_exit函数，进程终止状态为0</li>
</ul>


<p>3种异常终止程序：</p>

<ul>
<li>调用abort</li>
<li>进程收到某些信号，这个信号可以由其它进程、自己或内核发起。</li>
<li>最后一个线程对“取消”做出响应。</li>
</ul>


<blockquote><p>注意：
不管是正常终止或者是异常终止，内核都会在进程结束后执行一段代码，工作是：
1. 关闭打开的描述符
2. 释放使用的存储器</p></blockquote>

<h2>子进程如何通知父进程它的终止状态</h2>

<ol>
<li>对于三个终止函数（exit, <em>exit, </em>Exit）退出的进程，若通知父进程其退出状态，需要把状态作为参数传递给这三个函数。其它两种正常退出，终止状态为0.</li>
<li>异常终止，内核产生一个指示其异常终止原因的终止状态。</li>
</ol>


<blockquote><p>注意：
不管哪种情况，父进程都可以通过wait和waitpit函数获取其终止状态。</p></blockquote>

<h2>进程领养与僵死进程</h2>

<p>父子进行结束的两种情况：</p>

<ol>
<li>父进程先于子进程终止。</li>
</ol>


<p>对于父进程已经终止的子进程，其父进程改变为init进程（ID为1）。每当一个进程终止时，内核会挨个检查所有活动的进程，判断是否是已终止进程的子进程。是，则将其父进程修改为init进程。</p>

<p>这个步骤称为<em>进程的领养</em>。</p>

<ol>
<li>子进程先于父进程终止。</li>
</ol>


<p>为了让父进程获取其子进程的终止状态，内核为每个终止的子进程保存了一定量的信息。因此当父进程调用wait或waitpid函数时，可以获取子进程的终止状态。</p>

<p>内核为终止的子进程保存的信息有：</p>

<ul>
<li>进程ID</li>
<li>终止状态</li>
<li>进程使用CPU时间总量</li>
</ul>


<blockquote><p>注意：
由于进程终止时，内核释放了其占用的存储空间和关闭了打开的文件描述符，引起，进程占用的大部分资源都已经释放掉了。</p></blockquote>

<p><em>僵死进程（zombie）</em> ：一个已终止，而父进程没有终止，并且父进程还没有对其进行善后处理（获取子进程的终止信息，也就是还没有经过wait调用）的进程，被称为僵死进程，状态为Z。</p>

<blockquote><p>注意：
由init进程领养的子进程终止时，不会称为僵死进程。因为init的实现，只要有子进程终止，就会调用wait函数获取其终止状态。</p></blockquote>

<h1>父进程获取子进程终止状态（wait和waitpid函数）</h1>

<p>当进程的子进程终止时，内核会立即向其父进程发送SIGCHLD信号。因此父进程可以提供一个信号处理程序处理这个信号。</p>

<p>对于这个信号，父进程可以有两种处理方式：</p>

<ul>
<li>编写一个处理这个信号的处理程序（然后调用wait函数获取其终止子进程的终止状态）</li>
<li>忽略掉（系统默认）</li>
</ul>


<p>除了信号方式外，若父进程在程序内调用wait或者waitpid函数，则可能会发生以下：</p>

<ul>
<li>若所有子进程都在运行，阻塞</li>
<li>若一个子进程已经终止，正等待父进程获取其终止状态，则会立刻返回</li>
<li>若没有任何子进程，立即出错返回</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/wait.h&gt;
</span><span class='line'>
</span><span class='line'>pid_t wait(int *statloc);
</span><span class='line'>
</span><span class='line'>pid_t waitpid(pid_t pid, int *statloc, int options);
</span></code></pre></td></tr></table></div></figure>


<p>wait和waitpid函数的区别：</p>

<ul>
<li>在一个子进程终止前，wait函数会使其调用至阻塞，而waitpid有一个选项，可使调用者不阻塞（比如：<code>waitpid(-1, &amp;statloc, WNOHANG)</code>）</li>
<li>waitpid可以不用等待其调用后的第一个终止的子进程，可以指定它等待的进程（参数pid > 0时）</li>
</ul>


<p>参数statloc是一个整型指针，子进程的终止状态存放于此，若不关心终止状态，可以传空指针。而判断子进程的终止状态，可以使用wait.h定义的宏：</p>

<table>
<thead>
<tr>
<th>宏        </th>
<th style="text-align:center;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFEXITED       </td>
<td style="text-align:center;"> 若正常终止的子进程，则为真。此时，可以调用WEXITSTATUS(status)获取子进程传送给exit <em>exit </em>Exit参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED     </td>
<td style="text-align:center;"> 若为异常终止的子进程返回的状态，则为真。可以使用WTERMSIG(status)获取子进程终止的信号编号。</td>
</tr>
<tr>
<td>WIFSTOPPED      </td>
<td style="text-align:center;"> 若为当前暂停子进程的返回状态，则为真。可使用WSTOPSIG(status)获取进程暂停信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED    </td>
<td style="text-align:center;"> 若作业控制暂停后已经继续的子进程返回了状态，则为真。</td>
</tr>
</tbody>
</table>


<h2>waitpid</h2>

<p>waitpid函数功能多于wait函数，其中，pid参数的意义：</p>

<ul>
<li>pid == -1 ，等待任一子进程，此时与wait等效</li>
<li>pid > 0，等待进程Id等于PID的进程</li>
<li>pid == 0，等待其组ID等于调用进程组ID的任意一子进程</li>
<li>pid &lt; -1，等待其组ID等于pid绝对值的任一子进程</li>
</ul>


<p>而waitpid的options参数进一步控制了waitpid的操作：</p>

<ul>
<li>WNOHANG : 不阻塞</li>
<li>WCONTINUED : 作业控制相关</li>
<li>WUNTEACED: 作业控制相关</li>
</ul>


<p>依据这两个参数，waitpid提供了wait不具有的三个功能：</p>

<ul>
<li>可等待特定的进程</li>
<li>提供了wait的非阻塞版本</li>
<li>支持作业控制</li>
</ul>


<h1>关于僵死进程补充</h1>

<h2>僵死进程的危害</h2>

<p>若父进程一直存在，但不调用wait回收终止子进程的终止状态，则：</p>

<ul>
<li>内核保留了僵死进程的一定量信息，资源浪费</li>
<li>进程号一直没有释放，也就得不到重用</li>
</ul>


<h2>避免僵死进程的方法</h2>

<ul>
<li>通过信号机制</li>
<li>wait/waitpid函数调用</li>
<li>fork两次，由init来回收</li>
</ul>


<h2>如何查看僵死进程</h2>

<p>命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps -A -o stat, ppid, pid, cmd | grep -e '^[zZ]'
</span><span class='line'>
</span><span class='line'>* -A 列出所有进程
</span><span class='line'>* -o 自定义输出字段，stat表示进程状态，Z/z表示僵死进程
</span><span class='line'>
</span><span class='line'># 竞争条件
</span><span class='line'>
</span><span class='line'>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则认为发生了*竞争条件（race condition）*
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h1>exec函数</h1>

<p>在fork后，如果调用exec函数，则该进程执行的程序完全替换成新程序，并且从新程序的main函数开始执行。exec并不创建新进程，因此调用exec前后并不改变进程ID。exec只是用全新的程序替换了当前进程的正文数据堆和栈等段。</p>

<p>unix系统提供了6个exec函数，unix对进程的控制：</p>

<ul>
<li>fork</li>
<li>exit</li>
<li>wait</li>
<li>exec</li>
</ul>


<p>这几个函数使得unix进程控制原语更加完善。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>// 下面四个函数，执行程序是路径
</span><span class='line'>int execl(const char *pathname, const char *arg0, ... /* (char *)0 */)  // 参数是列表，以空指针结束
</span><span class='line'>
</span><span class='line'>int execv(const char *pathname, char *const argv[]) // 参数列表是一个数组
</span><span class='line'>
</span><span class='line'>int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */) // 可以传递一个环境表，这个环境表是个指针数组，每个元素是指向字符的指针
</span><span class='line'>
</span><span class='line'>int execve(const char *pathname, char *const argv[], char *const envp[]) // 传递环境表
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// 执行程序是文件名，如果文件名以“/”开头，则认为是路径，否则从PATH变量中搜寻执行文件
</span><span class='line'>int execlp(const char *filename, const char *arg0, ... /* (char *)0 */)
</span><span class='line'>
</span><span class='line'>int execvp(const char *filename, char *const argv[])
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>这六个函数的几种区别是：</p>

<ol>
<li>前四个函数已路径名作为参数，而后两个使用文件名作为参数，如果是文件名作为参数，则：

<ul>
<li>如果filename是包含“/”，则认为是路径</li>
<li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件（如果找到的可执行文件不是链接器生成的机器可执行文件，则认为是shell脚本，就会调用/bin/sh，并以filename作为shell的输入）</li>
</ul>
</li>
</ol>


<blockquote><p>说明：
环境表：每个程序都会接收一张环境表，这个环境表是一个字符指针数组，全局变量environ指向这个数组。
      环境表包含的环境变量，比如PATH=:/bin:/usr/bin:、USER=sar、等</p>

<p>环境变量（环境表中的每个数组元素），可以通过getenv获取环境变量。通过putenv、setenv等设置环境变量，一般使用这两个
函数访问设置环境变量，而不推荐直接访问environ全局变量。</p>

<p>POSIX.1 XSI等预定义了很多环境变量，其中PATH环境变量表示“搜索可执行文件的路径前缀列表”</p></blockquote>

<ol>
<li><p>第二个区别是参数表的传递不同。l表示list，v表示vector。execl、execle、execlp的每个命令行参数都说明为一个单独的参数，最后以空指针结尾。而execv、execve、execvp的命令行参数是以数组提供。</p></li>
<li><p>最后一个区别，传递的环境表有关。已e结尾的两个函数execle和execve，可以传递一个指向环境字符串指针数组的指针，其它几个函数则使用调用进程中的environ变量为新程序复制现有的环境。</p></li>
</ol>


<p>注意几点：</p>

<ol>
<li>对打开的文件的处理</li>
</ol>


<p>这与执行时关闭close-on-exec设置有关</p>

<p>进程中每个打开描述符都有一个执行时关闭标志。若设置此标志，则在执行exec时关闭该描述符，否则该描述符仍然打开。除非特地用fcntl设置了该标志，否则系统默认的操作是在执行exec后仍保持这种描述符的打开。</p>

<blockquote><p>fcntl函数可以：
* 复制一个现有描述符
* 设置/获得文件描述符标记（文件描述符标志，当前只定义了一个，就是FD_CLOEXEC）
* 获得/设置文件状态标志
* 等。</p></blockquote>

<p>posix.1明确要求在执行exec时关闭打开的目录流，这通常是opendir来实现的。它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志。</p>

<blockquote><p>疑问：
设置close-on-exec的场景是什么？？</p></blockquote>

<ol>
<li>有效用户问题</li>
</ol>


<p>exec后，实际用户id和实际组id不变，而有效id是否改变，则取决于程序文件的设置用户id和设置组id是否设置。</p>

<p>很多unix实现中，只有execve是系统调用，其它函数是库函数。</p>

<h1>更改用户ID和组ID</h1>

<p>unix系统中，特权是基于用户和组ID的。</p>

<p>可以调用setuid函数设置实际用户id和有效用户id。setgid函数设置实际组id和有效组id。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>
</span><span class='line'>int setuid(uid_t uid);
</span><span class='line'>
</span><span class='line'>int setgid(gid_t gid);
</span></code></pre></td></tr></table></div></figure>


<p>对于修改ID有以下规则：</p>

<ul>
<li>若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为参数uid</li>
<li>若进程没有超级用户特权，但是参数uid等于实际用户ID<strong>或者</strong>保存的设置用户ID，则setuid只将有效用户ID设置为uid，不改变实际用户ID<strong>和</strong>保存的设置用户ID</li>
<li>若上面两个条件都不满足，则将errno设置为EPERM，并返回-1.</li>
</ul>


<p>关于内核维护的三个用户ID，注意：</p>

<ol>
<li>只有超级用户进程可以更改实际用户ID。通常实际用户ID是在用户登录时，有login程序设置的，而且拥有不会改变他。</li>
<li>仅当对程序文件设置了设置用户ID位时，exec函数才会设置有效用户ID。如果设置用户位没有设置，则exec函数不会改变有效用户ID，而将其维持为原先的值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID。</li>
<li>保存的设置用户id是由exec复制有效用户ID而得来的。如果设置了文件的设置用户ID位（执行位显示为s），则exec根据文件的用户ID设置了进程的有效用户ID以后，就将这个副本保存起来。</li>
</ol>


<table>
<thead>
<tr>
<th>ID    </th>
<th style="text-align:center;"> exec(设置用户ID位关闭) </th>
<th style="text-align:center;"> exec（设置用户ID位开启）</th>
<th style="text-align:center;"> setuid（超级用户） </th>
<th style="text-align:center;"> setuid（非特权用户）</th>
</tr>
</thead>
<tbody>
<tr>
<td>实际用户ID     </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 设置为uid  </td>
<td style="text-align:center;">不变</td>
</tr>
<tr>
<td>有效用户id     </td>
<td style="text-align:center;"> 不变    </td>
<td style="text-align:center;"> 设置为程序文件的用户ID  </td>
<td style="text-align:center;"> 设置为uid  </td>
<td style="text-align:center;">设置为uid</td>
</tr>
<tr>
<td>保存的设置用户ID</td>
<td style="text-align:center;"> 从有效用户ID复制   </td>
<td style="text-align:center;"> 从有效用户ID复制</td>
<td style="text-align:center;">设置为uid </td>
<td style="text-align:center;"> 不变</td>
</tr>
</tbody>
</table>


<h2>su 和sudo和setuid的关系</h2>

<p>su命令可以切换用户，而sudo可以以超级用户权限运行命令。查看这两个文件状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ll /usr/bin/su
</span><span class='line'>-rwsr-xr-x  1 root  wheel  21472  3 13  2013 /usr/bin/su
</span><span class='line'>$ ll /usr/bin/sudo
</span><span class='line'>-r-s--x--x  1 root  wheel  164496  3 13  2013 /usr/bin/sudo
</span></code></pre></td></tr></table></div></figure>


<p>su和sudo的用户执行位都是s，表示setuid为开启。当用户运行这个程序时，</p>

<p>会设置程序的有效用户ID为文件所有者，就会以这个文件的所有者（这里是root）权限运行。</p>

<p>因此，sudo命令可以以root权限执行命令。</p>

<p>当su命令执行时，设置进程的有效用户ID为root。</p>

<h1>解释器文件</h1>

<p>解释器文件，是文本文件，起始行的形式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! pathname [optional-argument]
</span></code></pre></td></tr></table></div></figure>


<p>感叹号和pathname之间的空格是可选的。最常见的解释器是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#! /bin/sh</span></code></pre></td></tr></table></div></figure>


<ul>
<li>pathname通常是绝对路径，对它不进行特殊处理（既不视屏PATH进行路径搜索），对这种文件识别，是由内核作为exec系统调用处理的一部分完成的。</li>
<li>内核调用exec函数实际上执行的并不是解释器文件，而是解释器文件中第一行pathname指定的文件</li>
<li>注意区别解释器文件（文本文件，以#!开头）和解释器之间区别（解释器文件第一行pathname指定）</li>
</ul>


<h2>解释器例子</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;sys/wait.h&gt;
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  pid_t pid;
</span><span class='line'>  if((pid = fork()) == -1)
</span><span class='line'>  {
</span><span class='line'>      printf("fork error\n");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  if(pid == 0)
</span><span class='line'>  {
</span><span class='line'>      printf("child process\n");
</span><span class='line'>      if(execl("/Users/user/work/cproj/testinterp", "testinterp", "myarg1", "My arg2", (char *) 0) &lt; 0)
</span><span class='line'>      {
</span><span class='line'>          printf("error execl\n");
</span><span class='line'>          exit(-1);
</span><span class='line'>      }
</span><span class='line'>      exit(0);
</span><span class='line'>  }
</span><span class='line'>  if(waitpid(pid, NULL, 0) &lt; 0)
</span><span class='line'>  {
</span><span class='line'>      printf("error waitpid");
</span><span class='line'>      exit(-1);
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>解释器文件testinterp很简单，只有一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#! /Users/user/work/cproj/echoarg foo</span></code></pre></td></tr></table></div></figure>


<p>而echoarg程序仅仅是打印参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int main(int argc, char *argv[])
</span><span class='line'>{
</span><span class='line'>  int i;
</span><span class='line'>  for (i = 0; i &lt; argc; i++)
</span><span class='line'>  {
</span><span class='line'>      printf("ARGV[%d]:%s\n", i, *(argv+i));
</span><span class='line'>  }
</span><span class='line'>  exit(0);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>结果如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ser@usertekiMacBook-Pro cproj$ ./execinterp
</span><span class='line'>child process
</span><span class='line'>ARGV[0]:/Users/user/work/cproj/echoarg
</span><span class='line'>ARGV[1]:foo
</span><span class='line'>ARGV[2]:/Users/user/work/cproj/testinterp
</span><span class='line'>ARGV[3]:myarg1
</span><span class='line'>ARGV[4]:My arg2
</span></code></pre></td></tr></table></div></figure>


<p>对程序结果的解释：</p>

<ul>
<li>当exec调用解释器（/Users/user/work/cproj/echoarg）时，argv[0]是该解释器的pathname（）。</li>
<li>argv[1]是解释器文件中的可选参数（foo）</li>
<li>其余参数是pathname（/Users/user/work/cproj/testinterp）</li>
<li>以及第二、三个参数（myarg1和My arg2）</li>
<li>注意，第一个参数（testinterp），是没有用的</li>
</ul>


<h2>解释器文件可选参数例子</h2>

<p>解释器pathname后可跟随可选参数，比如awk支持-f选项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>awk -f myfile</span></code></pre></td></tr></table></div></figure>


<p>它告诉awk从文件myfile中读awk程序。</p>

<p>如果在解释器文件中使用-f选项，则解释器文件可以这么写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#! /bin/awk -f
</span><span class='line'>
</span><span class='line'>后面跟着awk程序</span></code></pre></td></tr></table></div></figure>


<p>比如解释器文件/usr/local/bin/awkexample的内容是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/awk -f 
</span><span class='line'>BEGIN {
</span><span class='line'>  for (i = 0; i &lt; ARGC; i++)
</span><span class='line'>      printf "ARGV[%d] = %s\n", i, ARGV[i]
</span><span class='line'>  exit 
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ awkexample file1 FILENAME2 f3 ARGV[0] = awk
</span><span class='line'>ARGV[1] = file1
</span><span class='line'>ARGV[2] = FILENAME2
</span><span class='line'>ARGV[3] = f3</span></code></pre></td></tr></table></div></figure>


<p>如果执行这个文件时，实际上，是这么调用的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/bin/awk -f /usr/local/bin/awkexample file1 FILENAME2 f3</span></code></pre></td></tr></table></div></figure>


<ol>
<li>解释器文件的路径名/usr/local/bin/awkexample给传给解释器，因为不知道解释器是不是会从搜索路径中搜索该文件，因此传全路径文件名</li>
<li>awk读取解释器文件，第一行是#，注释，因此忽略第一行，执行后续程序</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python杂记]]></title>
    <link href="http://baren.github.io/blog/2014/04/22/python-note/"/>
    <updated>2014-04-22T11:15:07+08:00</updated>
    <id>http://baren.github.io/blog/2014/04/22/python-note</id>
    <content type="html"><![CDATA[<ul>
<li><p>实际上，每一个python函数都有返回值，如果有return，则返回return指定的值；没有就返回None。</p></li>
<li><p>python的搜索路径是在sys.path中搜索，sys.path是一个list，可以修改这个list的值。</p></li>
<li><p>python中，所有都是对象（函数是对象，模块是对象等），意思是所有都可以赋值给变量，或者作为参数传递给函数。所有都是对象，有些可能不具有方法和属性，有些不能被继承，但是都可以赋值和传参。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(进程环境)]]></title>
    <link href="http://baren.github.io/blog/2014/04/09/process-environment/"/>
    <updated>2014-04-09T20:00:58+08:00</updated>
    <id>http://baren.github.io/blog/2014/04/09/process-environment</id>
    <content type="html"><![CDATA[<h1>main函数</h1>

<p>c程序的起始运行函数是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, char *argv[]);
</span></code></pre></td></tr></table></div></figure>


<p>argc是命令行参数数目，argv是指针数组，指向每一个参数。</p>

<p>内核执行C程序是调用exec函数，在调用main函数之前，会先调用一个特殊的启动例程，可执行程序文件指定这个例程作为程序的启动地址。这是由链接编辑器设置的。链接编辑器由编译器调用。</p>

<p>启动例程会从内核取得命令行参数和环境变量值。</p>

<!-- more -->


<h1>进程终止</h1>

<p>有八种终止进程的方式，其中5种方式为正常终止，为：</p>

<ol>
<li>从main函数返回</li>
<li>调用exit函数</li>
<li>调用<em>exit或</em>Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用pthread_exit</li>
</ol>


<p>异常终止的三种方式：</p>

<ol>
<li>调用abort</li>
<li>接到一个信号并终止</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>


<p>程序启动例程，在main函数返回后，会立即调用exit函数。其类似过程是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exit(main(argc, argv));</span></code></pre></td></tr></table></div></figure>


<p>实际上，并不是这样（过程是一样的），启动例程一般是用汇编编写。</p>

<h2>exit函数</h2>

<p>三个用于正常终止程序的函数中，<em>exit和</em>Exit函数立即进入内核。</p>

<p>exit函数则先执行一些清理处理（调用终止处理程序，关闭所有标识I/O流），然后进入内核。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>void exit(int status);
</span><span class='line'>void _Exit(int status);
</span><span class='line'>
</span><span class='line'>#include &lt;unistd.h&gt;
</span><span class='line'>void _exit(int status);
</span></code></pre></td></tr></table></div></figure>


<p>exit的清理操作，执行一个标准的I/O库的清理关闭操作，为所有打开流调用fclose函数（怎么实现的？）</p>

<blockquote><p>注意
exit和<em>Exit函数是ISO C标准定义的，而</em>exit则是POSIX说明的，因此使用的头不一样。</p></blockquote>

<p>由于标准库有buffer，因此怎样退出程序很重要。</p>

<p>若使用fopen函数打开文件，并没用fclost关闭它，影响是什么呢？</p>

<p>若使用exit函数或正常从main函数返回，两种方式都会调用exit函数。因此，exit函数会为你处理：</p>

<ul>
<li>flush输出流</li>
<li>关闭文件</li>
<li>进程拥有的其它资源也会被释放</li>
</ul>


<p>如果非正常退出，或调用<em>exit或</em>Exit函数，则</p>

<ul>
<li>系统会关闭打开的文件</li>
<li>释放资源</li>
<li>buffer并不会被flush</li>
</ul>


<p>三个exit函数都有一个整型参数，称之为终止状态（或退出状态，exit status），shell可用$?查看上一条命令的返回值。</p>

<p>若：</p>

<ul>
<li>调用这些函数不带终止符</li>
<li>main执行了一个无返回值的return语句</li>
<li>main没有生命返回类型为整型</li>
</ul>


<p>则：</p>

<p>进程状态为未定义的。</p>

<p>但：</p>

<p>若main生命为int返回类型，并执行到最后一条语句时返回（隐式返回），</p>

<p>则：</p>

<p>进程终止状态为0</p>

<p>在main函数返回一整型值与用该值调用exit函数是等价的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exit(0) == return 0;</span></code></pre></td></tr></table></div></figure>


<h2>atexit函数</h2>

<p>可以注册终止处理函数，这批函数在exit自动调用，ISO C规定，可注册函数多达32个，注册这些函数使用atexit函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>int atexit(void (*func)(void));
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注：
1. exit调用这些函数顺序与他们登记的顺序相近
2. 同一个函数若登记多次，则会调用多次</p></blockquote>

<p><img src="http://baren.github.io/images/assets/Figure7-1.png" title="time-function" alt="alt text" /></p>

<h1>命令行参数</h1>

<p>比较简单，记录一点。</p>

<p>argv[argc]是一个空指针，这样，可以在循环获取参数时，这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>for(i=0; garv[i] != NULL; i++)
</span><span class='line'>{
</span><span class='line'>  // 代码
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>环境表</h1>

<p>每个程序，都会收到一张环境表，环境表是字符指针数组，每个指针指向的字符以null结束。</p>

<p><strong>全局变量</strong><code>environ</code>包含了该指针数组的地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extern char ** environ;
</span></code></pre></td></tr></table></div></figure>


<p>称environ为环境指针，指针数组为环境表，环境表每个表项由name=value组成。</p>

<h1>C程序的存储空间</h1>

<p>C程序由以下几部分组成</p>

<ul>
<li>正文段：是由CPU执行的机器指令部分，正文段是共享的，而且是只读的。</li>
<li>初始化数据段：常称为数据段，它包含了程序中须明确的赋初始值的变量。比如
在C程序中出现在任何函数之外的声明：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int maxcount = 99;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>非初始化数据段：常称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针，出现在任何函数外的C声明：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>long sum[1000];
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>栈：自动变量，函数调用时所需要保存的信息，都存放到栈中，这种实现方式允许递归调用。</li>
<li>堆：一般在堆中进行动态存储分配。堆位于非初始化数据段和栈之间。</li>
</ul>


<p>示意图：</p>

<p><img src="http://baren.github.io/images/assets/Figure7-2.png" title="time-function" alt="" /></p>

<p>linux的size命令可以报告正文段、数据段和bss段的长度。</p>

<h1>共享库</h1>

<p>共享库使得可执行文件中不再需要包含共用库的例程。</p>

<p>只需要在所有进程都可引用的存储区中维护这种库例程的一个副本，在例程<strong>第一次</strong>执行或在第一次调用某个库函数时，用<strong>动态链接</strong>方法，将程序与共享库函数相链接。</p>

<p>好处：</p>

<ul>
<li>减少了执行文件长度</li>
<li>方便替换使用的库函数的版本而不需要重新链接。</li>
</ul>


<p>坏处：
* 增加了首次的运行时间</p>

<blockquote><p>GCC编译器，默认引用动态库，动态库是以.so结尾；而静态库是以.a为扩展名。引用一个程序库，可以使用-l<em>NAME</em>选项。</p></blockquote>

<h1>存储器分配</h1>

<ol>
<li>malloc 分配指定大小（字节数）的存储区，初始值不确定</li>
<li>calloc 为指定数量且指定长度的对象分配存储空间，初始化值为0</li>
<li>realloc 更改以前分配区的长度（增加或减少）</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'># include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>void *malloc(size_t size);
</span><span class='line'>void *calloc(size_t nobj, size_t size);
</span><span class='line'>void *realloc(void *ptr, size_t newsize);
</span><span class='line'>
</span><span class='line'>void free(void *ptr);
</span></code></pre></td></tr></table></div></figure>


<p>三个函数返回的指针一定是适当对齐的（原理基本上是已对齐单位的倍数的方式多分配内存）。</p>

<p>三个函数返回void *指针，因此可以将其赋值给任何指针而不需要强制转换。</p>

<p>free可以释放由上面三个函数分配的内存。</p>

<p>这些分配函数通常调用sbrk系统调用实现。</p>

<p>sbrk可增大和减少进程的存储空间，但malloc和free一般都不减少存储空间，以便分配并保持在malloc池中不返回内核。</p>

<h1>环境变量</h1>

<p>环境变量字符串的形式为<code>name=value</code>，unix不会查看此字符串，完全由程序解释。</p>

<p>ISO C定义了一个函数getenv，根据name获取其value。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>char *getenv(const char *name);</span></code></pre></td></tr></table></div></figure>


<p>除了获取环境变量，还可以设置环境变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>
</span><span class='line'>int putenv(char *str);
</span><span class='line'>
</span><span class='line'>int setenv(const char *name, const char *value, int rewrite);
</span><span class='line'>
</span><span class='line'>int unsetenv(const char *name);</span></code></pre></td></tr></table></div></figure>


<p>putenv，参数为name=value字符串，若name存在，则先删除</p>

<p>setenv，参数name的值设为value，如果name存在，则根据rewrite参数决定是重写还是不删除。</p>

<p>unsetenv，删除name的定义</p>

<blockquote><p>注意：
1. putenv的实现，linux直接将字符串地址作为参数放入环境表中，如果参数是存放在栈中，则会发生错误。
2. 由于环境变量存放在程序空间的最上面，大小是有边界的，因此，如果设置的环境变量超出了存储空间大小，则需要由malloc在堆上分配空间来存储。</p></blockquote>

<h1>setjmp和longjmp函数</h1>

<p>c语言中，goto语句不能跨函数，如果要跨函数，则需要setjmp和longjmp函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;setjmp.h&gt;
</span><span class='line'>
</span><span class='line'>int setjmp(jmp_buf env);
</span><span class='line'>void longjmp(jmp_buf env, int val);</span></code></pre></td></tr></table></div></figure>


<p>调用这两个函数，遇到的问题是：</p>

<ol>
<li>调用longjmp后，自动变量和寄存器变量的状态如何？这些值能回滚到调用setjmp的状态码？</li>
</ol>


<p>答：不确定，跟实现有关系。大多数实现并不回滚这些自动变量和寄存器变量的值，而所有标准则说他们的值是不确定的。如果有一个自动变量，而又不想使其回滚，则可以定义具有volatile属性。声明为全局或静态变量的值在执行longjmp时保持不变。</p>

<ol>
<li>自动变量的问题：若在函数内部声明指针，并返回了这个指针，则会出问题。</li>
</ol>


<h1>进程资源</h1>

<h2>进程资源使用</h2>

<p>getrusage()系统调用返回调用进程或者其所有子进程运行所使用的各种系统资源。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/resource.h&gt;
</span><span class='line'>
</span><span class='line'>int getrusage(int who, struct rusage *res_usage);</span></code></pre></td></tr></table></div></figure>


<p>参数who指定了进程中谁的资源使用信息将会被获取。有下面几个值：</p>

<ul>
<li>RUSAGE_SELF 返回调用进程的资源</li>
<li>RUSAGE_CHILDREN 返回调用进程的所有子进程的资源。子进程是停止的和wait的。</li>
<li>RUSAGE_THREAD 返回调用线程的资源（Linux 2.6.26）</li>
</ul>


<p>res_usage参数是一个指针，指向结构为rusage的对象。</p>

<h2>进程资源限制</h2>

<p>每个进程都消耗系统资源，OS对每个进程都有一些资源限制。在shell中，可以使用ulimit命令设置进程的资源限制。所有通过shell启动的进程都会继承ulimit设置的限制。</p>

<p><em>getrlimit()</em> 和 <em>setrlimit()</em> 两个函数可以获取和设置进程的资源限制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/resource.h&gt;
</span><span class='line'>int getrlimit(int resource, struct rlimit *rlim);
</span><span class='line'>int setrlimit(int resource, const struct rlimit *rlim);
</span><span class='line'>// Both return 0 on success, or –1 on error
</span></code></pre></td></tr></table></div></figure>


<p><em>resource</em>参数代表了需要获取或设置的资源标记符。rlimit是一个结构体，用来描述资源限制的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct rlimit {
</span><span class='line'>rlim_t rlim_cur; /* Soft limit (actual process limit) */ 
</span><span class='line'>rlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>关于结构体<code>struct rlimit</code>解释如下：</p>

<p>既有软限制（rlim_cur），又有硬限制（rlim_max）。软限制表示进程可以消耗的最大资源设置。一个进程可以调整软限制，调整范围是[0-硬限制]。进程可以调整其硬限制。没有权限的进程，只能降硬限制调小（但不小于软限制），对于大多数进程，硬限制只是说明进程的可消耗的资源的最大值。</p>

<p>有权限的进程（CAP_SYS_RESOURCE）可以调整硬限制大小，既可往大得方向调整，也可以往小的方向调整。</p>

<p>如果rlim_cur和rlim_max的值是RLIM_INFINITY，表示没有限制。</p>

<p>虽然设置进程的资源限制是针对单个进程的。但进程可消耗的资源除了与这个设置有关系外，还需要依赖同一个用户id的进程所消耗的资源之和。</p>

<p>比如RLIMIT_NPROC资源，表示可创建的进程数限制，就是一个很好的例子。但是如果根据进程的子进程数来检查这个限制，将会失效，因为子进程也会创建新的进程。实际上，这个资源限制是针对所有的用户id都相同的进程设置的。但是，即使是具有同样的用户id，如果其他进程并没有针对这个资源进行限制，或者有限制，但是限制数跟其他不一样，则这个限制资源检查则是根据这个进程的相应设置来进行相应检查的。</p>

<p>下表是参数<em>resource</em>的取值表：</p>

<table>
<thead>
<tr>
<th>resource        </th>
<th style="text-align:center;"> Limit on</th>
</tr>
</thead>
<tbody>
<tr>
<td>RLIMIT_AS      </td>
<td style="text-align:center;"> 进程的虚拟内存大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_CORE    </td>
<td style="text-align:center;"> Core 文件大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_CPU     </td>
<td style="text-align:center;"> 进程的cpu时间(seconds)</td>
</tr>
<tr>
<td>RLIMIT_DATA    </td>
<td style="text-align:center;"> 进程的数据段大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_FSIZE   </td>
<td style="text-align:center;"> 文件大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_MEMLOCK </td>
<td style="text-align:center;"> 锁定的内存大小（byte）</td>
</tr>
<tr>
<td>RLIMIT_MSGQUEUE </td>
<td style="text-align:center;"> 为实际用户id分配的POSIX的消息队列的大小(since Linux 2.6.8)</td>
</tr>
<tr>
<td>RLIMIT_NICE    </td>
<td style="text-align:center;"> nice的值(since Linux 2.6.12)</td>
</tr>
<tr>
<td>RLIMIT_NOFILE  </td>
<td style="text-align:center;"> 最大的文件描述符个数</td>
</tr>
<tr>
<td>RLIMIT_NPROC   </td>
<td style="text-align:center;"> 一个实际用户id可创建的进程数</td>
</tr>
<tr>
<td>RLIMIT_RSS     </td>
<td style="text-align:center;"> Resident set size (bytes; not implemented)</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(系统数据文件和信息)]]></title>
    <link href="http://baren.github.io/blog/2014/03/29/system-data-file-and-info/"/>
    <updated>2014-03-29T08:06:39+08:00</updated>
    <id>http://baren.github.io/blog/2014/03/29/system-data-file-and-info</id>
    <content type="html"><![CDATA[<h1>时间和日期</h1>

<p>unix内核提供的<em>基本时间服务</em>是计算自国际标准时间公元1970年1月1日00:00:00以来经过的秒数。</p>

<p>这种秒数是以数据类型time_t表示的。称之为<strong>日历时间</strong>，日历时间包括日期和时间。</p>

<p>time函数返回当前的时间和日期：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>time_t time(time_t *calptr);
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>时间值总是作为函数值返回。如果参数不为空，则时间也存放在由calptr执行的内存中。</p>

<p>gettimeofday函数提供了更高分辨率（最高为微妙级）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;sys/time.h&gt;  ## 这里就是sys/time.h头文件了
</span><span class='line'>
</span><span class='line'>int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>该函数作为XSI扩展定于在Single UNIX Specification中，tzp唯一合法的值是NULL，其它值则将产生不确定的结果。</p>

<p>gettimeofday函数把当前时间放在tp指向的timeval结构中，该结构存储秒和微妙。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct timeval {
</span><span class='line'>  time_t tv_sec;  /*秒*/
</span><span class='line'>  long tv_usec;  /*微妙，注意是微妙，不是毫秒*/
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>取到time_t后，可以调用其它函数来转成成可读的日期和时间。</p>

<p><img src="http://baren.github.io/images/assets/Figure6-1.png" title="time-function" alt="alt text" /></p>

<p>localtime和gmtime将日历时间转换成以年、月、日、时、分、秒、周日表示的时间，并将这些存放在tm结构中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'># 将日历时间转换成国际标准时间的年、月、日、时、分、秒、周日。
</span><span class='line'>struct tm *gmtime(const time_t *calptr);
</span><span class='line'># 将日历时间转换成本地时间（考虑本地时区和夏令时）
</span><span class='line'>struct tm *localtime(const time_t *calptr);
</span><span class='line'>
</span><span class='line'>struct tm{
</span><span class='line'>  int time_sec; /*秒 [0-60]*/
</span><span class='line'>  int time_min; /*分 [0-59]*/
</span><span class='line'>  int tm_hour; /*时 [0-23]*/
</span><span class='line'>  int time_mday; /*日 [0-31]*/
</span><span class='line'>  int tm_mon; /*月 [0-11]*/
</span><span class='line'>  int tm_year; /*年 [1900年开始]*/
</span><span class='line'>  int tm_wday; /*从周日开始的天 [0-6]*/
</span><span class='line'>  int tm_yday; /*从一月开始的天数 [0-365]*/
</span><span class='line'>  int tm_isdst; /*daylight(夏令时)保存时间标记，&lt;0, 0, &gt;0*/
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>秒可以超过59的原因是可以闰秒。如果夏令时生效，夏令时标志值为正；如果非夏令时制时间，标志位0；不可用，则为负。</p>

<p>mktime函数把年月日等作为参数，转换成time_t的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>time_t mktime(struct tm *tmptr);
</span><span class='line'>
</span><span class='line'># 下面两个函数把时间转换成date命令的系统默认输出形式。只是参数不一样
</span><span class='line'>char *asctime(const struct tm *tmptr);
</span><span class='line'>char *ctime(const time_t *calptr);
</span></code></pre></td></tr></table></div></figure>


<p>strftime函数是格式化时间：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;time.h&gt;
</span><span class='line'>
</span><span class='line'>size_t strftime(char *restrict buf, size_t masxize, const char *restrict format, const struct tm *restrict tmptr);
</span></code></pre></td></tr></table></div></figure>


<p>最后一个参数是要格式化的时间值，tm结构指针传递。格式化结果存放在一个长度为maxsize的buf数组中，如果buf长度可以存放格式化结果和一个null终止符，则该函数返回在buf中存放的字符数，否则该函数返回0.</p>

<p>format是格式化字符串。</p>

<p>转换符略。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apue(标准I/O库)]]></title>
    <link href="http://baren.github.io/blog/2014/03/22/standard-io/"/>
    <updated>2014-03-22T20:06:00+08:00</updated>
    <id>http://baren.github.io/blog/2014/03/22/standard-io</id>
    <content type="html"><![CDATA[<h1>流和FILE对象</h1>

<h2>流介绍</h2>

<p>对于标准I/O库，他们的操作是围绕<em>流</em>进行的。</p>

<p>与JAVA使用Stream类来代表流不一样，标准I/O采用结构体FILE来代表流，由于大多数标准库的函数使用FILE <em>来作为参数，因此也用</em>文件指针*来代称流。</p>

<p>struct FILE结构体在stdio.h中做了声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct _sFILE{...} FILE;
</span></code></pre></td></tr></table></div></figure>


<p>数据类型FILE
    > 代表流对象，FILE对象含有所有的连接文件的内部状态，包括文件位置标记和缓存信息等。
    > 每一个流海包含error和文件末尾状态标记，可以通过ferror和feof函数进行测试。</p>

<!-- more -->


<h2>流的定向</h2>

<p>标准I/O可以用于单字节的字符集（ascii字符集）和多字节（宽）字符集，这就要求<em>流的定向</em>。
对于宽字节的处理，有一套专门的多字节处理函数（wchar.h中声明）。
对于同样的流，为了能处理宽的和正常的字符的操作，有一个限制：</p>

<ul>
<li>流要么被标记为宽定向的，要么是字节定向的</li>
<li>一旦确定定向后，不能二者混用</li>
</ul>


<p>有三种方式来定向流：</p>

<ul>
<li>创建流后，任一个正常字符函数被使用，流被标记为字节定向的。</li>
<li>创建流后，任一个宽字符函数被使用，流被标记为宽定向的。</li>
<li>使用<code>fwide函数</code>来设置流的定向。</li>
<li>freopen函数可以清除流的定向。</li>
</ul>


<p>注意：</p>

<ul>
<li>流刚被创建时，并没有定向</li>
<li>在未定向流上使用字节字符函数则置为字节定向的</li>
<li>在未定向流上使用宽字节函数则置为宽字节定向的</li>
</ul>


<p>fwide函数说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;wchar.h&gt;
</span><span class='line'>
</span><span class='line'># 返回值：若流是宽定向的，则返回正值；若流是字节定向的，则返回负值；若流是未定向的，则返回0.
</span><span class='line'>int fwide(FILE *fp, int mode);</span></code></pre></td></tr></table></div></figure>


<p>根据mode参数的值，fwide执行不同的工作：</p>

<ul>
<li>若mode参数为负值，fwide试图使指定的流是字节定向的</li>
<li>若mode参数为正值，fwide试图使指定的流是宽定向的</li>
<li>若mode参数为0，fwide将不试图设置流的定向，但返回标识该流定向的值</li>
</ul>


<blockquote><p>注意:
fwide不会改变已经设置定向的流
fwide不会出错，想检查错误，唯一可用的是调用之前先清除errno，调用fwide后检查errno的值。（errno是全局变量，每次调用失败，系统会用错误代码赋值给errno）</p></blockquote>

<h1>标准输入/输出/错误</h1>

<p>当main函数被调用，就已经有3哥预先定义的打开的流可以使用，这三个流在stdio.h中声明：</p>

<ul>
<li>FILE *stdin。标准输入流</li>
<li>FILE *stdout。标准输出流</li>
<li>FILE *stderr。标准错误流</li>
</ul>


<p>在GNU C中，stdin、stdout和stderr是正常常量，可以直接用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fclost(stdout);
</span><span class='line'>stdout = fopen("filepath", "w");
</span></code></pre></td></tr></table></div></figure>


<h1>缓冲</h1>

<p>标准I/O提供了三种类型的缓冲：</p>

<ul>
<li>全缓冲。填满缓冲区后才进行实际的I/O操作。对于磁盘文件，通常是全缓冲的。在一个流上第一次执行I/O操作时，标准I/O函数通常用malloc获取需要使用的缓冲区。</li>
<li>行缓冲。当输入和输出中遇到换行符时，标准I/O库执行I/O操作。当涉及到终端时，通常使用行缓冲。</li>
</ul>


<blockquote><p>行缓冲有两个限制：</p>

<p>缓冲区长度是固定的，所以只要填满了缓冲区，即使没有缓冲区，也进行I/O操作</p>

<p>任何时候，只要标准I/O库从 a）不带缓冲的流，或者 b）一个行缓冲的流（但数据从内核获取）得到输入数据，那么就会造成冲洗所有行缓冲输出流。</p>

<p>从实现角度说，这么个限制是有原因的：如果从不带缓冲的流中获取数据，那么缓冲区中的没有冲洗的旧数据会对新数据造成污染。</p></blockquote>

<ul>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。标准错误流通常不带缓冲的。</li>
</ul>


<p>iso c 是这样设置缓冲的：
* 当且仅当标准输入和标准输出并不涉及交互设备时，他们才是全缓冲。
* 标准错误绝不会是全缓冲。</p>

<p>但是标准输入输出涉及交互设备时，一般：</p>

<ul>
<li>标准错误不带缓冲。</li>
<li>其它流，涉及终端设备，则是行缓冲；否则是全缓冲。</li>
</ul>


<p>对于这些默认的缓冲情况，可以使用函数进行修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>void setbuf(FILE * fp, char * buf);
</span><span class='line'>int servbuf(FILE * fp, char * buf, int mode, size_t size);
</span></code></pre></td></tr></table></div></figure>


<p>这些函数的使用限制是：</p>

<ul>
<li>一定要在流已被打开后调用</li>
<li>在对流执行任何一个其它操作之前调用</li>
</ul>


<p>setbuf可以打开和关闭缓冲，打开缓冲，将buf指向一个长为BUFSIZE的缓冲区（该常量被定义在stdio.h中）。关闭缓冲，则设置buf为NULL。
setvbuf，可以精确控制缓冲类型，通过mode参数指定：</p>

<ul>
<li>_IOFBF    全缓冲</li>
<li>_IOLBF    行缓冲</li>
<li>_IONBF    不缓冲</li>
</ul>


<blockquote><p>注意：
如果在一个函数内分配一个自动变量类的标准I/O缓冲区，则从该函数返回之前，必须关闭该流（也就是把数据冲洗一下）。
一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。这种情况下，关闭此流时，标准I/O库将自动释放缓冲区。</p></blockquote>

<p>可以通过函数强制缓冲一个流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdih.h&gt;
</span><span class='line'>
</span><span class='line'>int fflush(FILE * fp);</span></code></pre></td></tr></table></div></figure>


<h1>打开流</h1>

<p>使用下列函数打开流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>FILE *fopen(char * pathname, char *type);
</span><span class='line'>FILE *freopen(char *pachname, char *type, FILE *fp);
</span><span class='line'>FILE *fdopen(int fd, char *type);
</span></code></pre></td></tr></table></div></figure>


<p>使用fopen函数打开一个文件，创建一个新流，并建立这个流和文件之间的连接。这个过程也会涉及到创建新文件。</p>

<p>其中，type参数指定对该流的读、写方式：</p>

<ul>
<li><code>'r'</code>: 只读打开文件</li>
<li><code>'w'</code>: 只写打开，若文件存在，截断为0；否则创建新文件</li>
<li><code>'a'</code>: 追加打开，为在文件为写而打开。文件若存在，则不改变内容。</li>
<li><code>'r+'</code>: 读写打开文件，初始化内容不变，初始化文件位置在文件开头。</li>
<li><code>'w+'</code>: 读写打开文件，若文件存在，截断为0.否则创建新文件</li>
<li><code>'a+'</code>: 为在文件尾读和写而打开文件。</li>
</ul>


<blockquote><p>注意：</p>

<p>&lsquo;+&#8217;请求一个流可以读和写，当使用这种流时，在读写之间转换时，必须刷新buffer，fflush或者订货函数fseek都可以。不然内部的buffer可能不空。</p></blockquote>

<p>freopen函数像fclos和fopen的联合。受限关闭有fp指向的流（这个过程会忽略任何错误），然后再打开pathname指向的文件，一般用于将一个指定的文件打开为一个预定义的流。</p>

<p>可以使用fclose关闭流：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fclose(FILE *fp);</span></code></pre></td></tr></table></div></figure>


<p>关闭一个流，关闭文件，并刷新缓冲区的输出数据，并释放由标准I/O库分配的内存。</p>

<blockquote><p>注意：
当程序正常关闭时（调用exit函数和正常从main返回），所有未写缓冲数据的标准I/O流，都会被冲洗；所有打开的标准I/O都会关闭。</p></blockquote>

<h1>读和写流</h1>

<p>一旦打开了流，就可在三中不同类型的非格式化I/O中选择，进行读写。包括：</p>

<ul>
<li>每次只读一个字符的I/O，一次读写一个字符。若流是缓冲的，标准I/O会处理所有缓冲。</li>
<li>每次一行I/O，可以使用fgets和fputs，每行以换行符终止。</li>
<li>direct I/O，直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。用于从二进制文件中每次读或写一个结构。</li>
</ul>


<h2>一次一个字符</h2>

<p>下面三个函数可以用于一次读一个字符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 三个函数的返回值，若成功，返回下一个字符；达文件末尾或失败，则返回EOF
</span><span class='line'>int getc(FILE *fp);
</span><span class='line'>int fgetc(FILE *fp);
</span><span class='line'>
</span><span class='line'>int getchar(void);
</span><span class='line'>
</span><span class='line'># 写入流
</span><span class='line'>int putc(int c, FILE *fp);
</span><span class='line'>int fputc(int c, FILE * fp);
</span><span class='line'>int putchar(int c);
</span></code></pre></td></tr></table></div></figure>


<p>getchar 等价于getc(stdin)，而getc和fgetc的区别是前者可以实现为宏；而后者不可。这意味着：</p>

<ul>
<li>getc的参数不应当是具有副作用的表达式</li>
<li>fgetc是函数，可得到其地址，允许fgetc地址作为参数传递给其它函数</li>
<li>fgetc函数执行时间长于getc函数（宏的优势）</li>
</ul>


<p>不管是出错，还是到达文件末尾，三个函数都返回EOF，为了区分是出错还是到达文件末尾，需要使用ferror或feof函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int ferror(FILE *fp);
</span><span class='line'>
</span><span class='line'>int feof(FILE *fp);
</span><span class='line'>
</span><span class='line'>void clearerr(FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>大多数实现，为每个流在FILE对象中维持了两个标志：</p>

<ul>
<li>出错标志</li>
<li>文件结束标志</li>
</ul>


<p>从流中读取数据后，可以调用ungetc奖字符再压回流中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 成功，返回c，出错返回EOF
</span><span class='line'>int ungetc(int c, FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>关于压回，注意：</p>

<ul>
<li>压回流中的字符可以再读出，但与压入顺序相反。</li>
<li>不能压回EOF。</li>
<li>到达文件末尾，还可压回字符。下次读取将返回该字符，再次读取则返回EOF。这么做的一个原因是，一次成功的ungetc调用会清除该流的文件结束标志。</li>
</ul>


<h2>每次一行</h2>

<p>下面函数是每次一行函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'># 读一行函数，成功，则返回bug，错误或到达末尾，则返回NULL
</span><span class='line'>char * fgets(char * buf, int n, FILE *fp);
</span><span class='line'>
</span><span class='line'>char * gets(char *buf);
</span><span class='line'>
</span><span class='line'># 写一行函数，成功，返回非负值，出错返回EOF
</span><span class='line'>
</span><span class='line'>int fputs(char * str, FILE *fp);
</span><span class='line'>
</span><span class='line'>int puts(char *str);
</span></code></pre></td></tr></table></div></figure>


<p>两个gets函数，指定了缓冲区，把读的行送入其中。gets从标准输入读，fgets从指定流读。</p>

<ul>
<li>fgets必须指定缓冲区的长度。此函数一直读到下一个换行符为止，但不超过n-1（放null字符），读入的数据被送入缓冲区。</li>
<li>该缓冲区一null结尾。</li>
<li>若该行的字符数超过n-1，则fgets只返回一个不完整的行，但是，缓冲区总是以null字符结尾。</li>
</ul>


<blockquote><p>注意：
gets函数不推荐，由于没有指定缓冲区大小，容易造成缓冲区溢出。</p></blockquote>

<p>写入一行函数，将一个以null符终止的字符串写入到指定流。尾端null不会被写入。</p>

<h2>二进制I/O</h2>

<p>对于直接I/O，也就是二进制I/O，提供两个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>size_t fread(void *ptr, size_t size, size_t nobj, FILE *fp);
</span><span class='line'>
</span><span class='line'>size_t fwrite(void * ptr, size_t size, size_t nobj, FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>这两个函数的常用用法：</p>

<ol>
<li>读或写一个二进制数组。比如将一个浮点数组的第2~5个元素写到一个文件上：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>float data[10];
</span><span class='line'>
</span><span class='line'>if (fwrite(&data[2], sizeof(float), 4, fp) != 4)
</span><span class='line'>  printf("error");</span></code></pre></td></tr></table></div></figure>


<ol>
<li>读写一个结构</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct {
</span><span class='line'>  
</span><span class='line'>  short count;
</span><span class='line'>  long total;
</span><span class='line'>  char name[NAMESIZE];
</span><span class='line'>
</span><span class='line'>} item;
</span><span class='line'>
</span><span class='line'>if (fwrite(&item, sizeof(item), 1, fp) != 1)
</span><span class='line'>  printf("error");
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
对于二进制读写的问题是：只能用于同一个系统上已写的数据，原因是：
1. 在同一个结构中，同一个成员的偏移量可能因为编译器和系统而异。
2. 用来存储多字节整数和浮点值的二进制格式，在不同机器体系结构不同。</p></blockquote>

<h1>定位流</h1>

<p>三种方法定位标准I/O流</p>

<ul>
<li>ftell和fseek，假设位置偏移量，可以使用长整型。</li>
<li>ftello和fseeko，文件偏移量，使用off_t代替长整型。</li>
<li>fgetpos和fsetpos，ISO C引入，使用抽象数据类型fpos_t来记录文件的位置。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>long ftell(FILE *fp); # 成功，返回当前文件位置指示，出错返回-1
</span><span class='line'>
</span><span class='line'>int fseek(FILE *fp, long offset, int whence);
</span><span class='line'>
</span><span class='line'>void rewind(FILE *fp);
</span></code></pre></td></tr></table></div></figure>


<p>定位涉及到文本文件和二进制文件，由于存放格式不一样，里面许多注意点。</p>

<h2>对于二进制文件</h2>

<p>二进制文件，文件位置指示器是从文件起始位置开始度量，并以字节为计量单位。</p>

<p>ftell用于二进制文件时，其返回值就是这种字节位置。</p>

<p>为了使用fseek定位一个二进制文件，必须指定一个字节的<em>offset</em>。以及解释这种偏移量的方式。</p>

<p>whence的值与内核函数lseek函数相同：</p>

<ul>
<li>SEEK_SET表示从文件的起始位置开始</li>
<li>SEEK_CUR表示从当前文件位置开始</li>
<li>SEEK_END表示从文件尾端开始。</li>
</ul>


<h2>文本文件</h2>

<p>对于文本文件，他们的文件位置可能不以简单的字节偏移量来度量。主要是在非unix系统中，以不同格式存放文本文件。</p>

<p>为了定位文本文件，<em>whence</em>一定要是SEEK_SET，而<em>offset</em>的值只有两种：0（绕回到文件的起始位置）。或是对该文件调用ftell返回的值。</p>

<p>使用fewind可以将流设置到文件的起始位置。</p>

<h1>格式化I/O</h1>

<h2>scanf函数</h2>

<p>有以下几个scanf函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>
</span><span class='line'>int fscanf(FILE *stream, char const *format, ...);
</span><span class='line'>
</span><span class='line'>int scanf(char const *format, ...);
</span><span class='line'>
</span><span class='line'>int sscanf(char const *string, char const *format, ...);
</span></code></pre></td></tr></table></div></figure>


<p>这些函数都是从输入源中读取字符并根据format字符串给出的格式代码对他们进行转换。</p>

<p>fscanf输入源就是作为参数给出的流，scanf从标准输入读取，sscanf从第一个参数所给的字符串中读取字符。</p>

<p>读取停止条件：</p>

<ol>
<li>当格式化字符串到达末尾</li>
<li>读取的输入不再匹配格式字符串所指定的类型时</li>
</ol>


<p>返回结果是被转换的输入值的数据。</p>

<p>如果在任何输入值被转换之前文件就已经到达尾部，函数就返回常量值EOF。</p>

<blockquote><p>注意：
对于scanf函数的参数，前面需要使用<code>&amp;</code>。</p></blockquote>

<p>scanf函数族中的format字符串参数可能包含下面内容：</p>

<ul>
<li>空白字符————她们与输入中得零个或多个空白字符匹配，在处理过程中被忽略。</li>
<li>格式代码————她们指定函数如何解释接下来的输入字符。</li>
<li>其它字符————当任何其它字符出现在format字符串时，下一个输入字符必须与它匹配。如果匹配，该输入字符随后就被丢弃。如果不匹配，函数就不再读取直接返回。</li>
</ul>


<p>格式代码的结构是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%[*] [fldwidth] [lenmodifier]convtype</span></code></pre></td></tr></table></div></figure>


<p>针对上面的格式，解释如下：</p>

<ul>
<li>可选<code>*</code>字符：将使转换后的值被丢弃而不是进行存储</li>
<li>fldwith宽度：非负整数，它限制将被读取用于转换的输入字符的个数。如果没有给出宽度，函数就连续读入字符直到遇到输入中的下一个空白符。</li>
<li>lenmodifier限定符：用于修改有些格式代码的含义</li>
</ul>


<blockquote><p>对于限定符，说明：
限定符的目的是为了指定参数的长度。如果整型参数比缺省的整型值更短或更长时，在格式化代码中省略限定符就是一个常见的错误。
对于浮点型也是如此。
如果省略了限定符，可能导致一个较长的变量只有部分被初始化。或者一个较短变量的临近变量也被修改，这都取决于这些类型的相对长度。</p></blockquote>

<p>限定符作用到整型和浮点型的效果如下表：</p>

<table>
<thead>
<tr>
<th>格式代码        </th>
<th style="text-align:center;"> h           </th>
<th style="text-align:center;"> l  </th>
<th style="text-align:center;"> L</th>
</tr>
</thead>
<tbody>
<tr>
<td>d,i,n      </td>
<td style="text-align:center;"> short </td>
<td style="text-align:center;"> long </td>
<td style="text-align:center;">    空 </td>
</tr>
<tr>
<td>o,u,x      </td>
<td style="text-align:center;"> 无符号 short      </td>
<td style="text-align:center;">       无符号 long </td>
<td style="text-align:center;"> 空</td>
</tr>
<tr>
<td>e,f,g </td>
<td style="text-align:center;">     空  </td>
<td style="text-align:center;">    double </td>
<td style="text-align:center;">       long double</td>
</tr>
</tbody>
</table>


<p>转换符</p>

<p>看下面例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nfields = fscanf(input, "%4d %4d %4d", &a, &b, &c)</span></code></pre></td></tr></table></div></figure>


<p>上面程序，宽度参数把整数值限制为4个数字或者更少的数字，如果是下面的输入：</p>

<p>1 2</p>

<p>则a的值是1，b的值是2，c没有改变。而nfields值为2.</p>

<p>如果是下面的输入：</p>

<p>12345 67890</p>

<p>则a的值是1234， <strong>b的值是5</strong>。c的值是6789，nfield的值是3。</p>

<p>转换符表格：</p>

<table>
<thead>
<tr>
<th>代码        </th>
<th style="text-align:center;"> 参数类型           </th>
<th style="text-align:left;"> 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c </td>
<td style="text-align:center;"> char *</td>
<td style="text-align:left;"> 读取和存储单个字符。如果给定了宽度，则读取和存储这个数目的字符（因此参数类型是char *），参数必须指向一个足够大的字符数组</td>
</tr>
<tr>
<td>i,d</td>
<td style="text-align:center;">int * </td>
<td style="text-align:left;"> 一个可选的有符号整数倍转换，d把输入解释为十进制；i根据它的第一个字符决定值的基数</td>
</tr>
<tr>
<td>u,o,x</td>
<td style="text-align:center;"> unsigned *</td>
<td style="text-align:left;"> 无符号，分别是u无符号十进制，o无符号八进制，x无符号十六进制</td>
</tr>
<tr>
<td>e，f，g</td>
<td style="text-align:center;"> float *</td>
<td style="text-align:left;">浮点数</td>
</tr>
<tr>
<td>s</td>
<td style="text-align:center;"> char * </td>
<td style="text-align:left;"> 字符串</td>
</tr>
<tr>
<td>p </td>
<td style="text-align:center;"> void * </td>
<td style="text-align:left;"> 指向void的指针。输入预期为一串字符，诸如那些有printf函数的%p格式代码所产生的输出。</td>
</tr>
<tr>
<td>n </td>
<td style="text-align:center;"> int * </td>
<td style="text-align:left;">到目前为止通过这个scanf函数的调用从输入读取的字符数被返回。%n转换的字符不被计算在内。它本身并不耗费任何输入。</td>
</tr>
<tr>
<td>% </td>
<td style="text-align:center;"> 无</td>
<td style="text-align:left;"> %</td>
</tr>
</tbody>
</table>


<h2>printf函数</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int fprintf(FILE *stream, char const *format, ...);
</span><span class='line'>
</span><span class='line'>int printf(char const *format, ...);
</span><span class='line'>
</span><span class='line'>int sprintf(char *buffer, char const *format, ...);
</span></code></pre></td></tr></table></div></figure>


<p>printf，结果输出送到标准输出，fprintf可以指定输出流。sprintf把结果作为一个NUL结尾的字符串存储到指定的buffer缓冲区中。</p>

<blockquote><p>注意：
sprintf有潜在的错误，缓存区大小不是一个参数，因此，如果输出结果长于缓冲区，会改写缓冲区后面的内存位置中得数据。</p></blockquote>

<p>printf中得format构成是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>%[flags] [fldwidth] [precision] [lenmodifier]convtype
</span></code></pre></td></tr></table></div></figure>


<h3>flags字符</h3>

<table>
<thead>
<tr>
<th>标志 </th>
<th> 含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-   </td>
<td> 值在字段中左对齐，默认是右对齐</td>
</tr>
<tr>
<td>0   </td>
<td>当数值为右对齐时，却僧情况下使用空格填充左边未使用的列。使用这个标志，则用零来填充，它可用于d,i,u,o,x,X,e,E,f,g和G代码。</td>
</tr>
<tr>
<td>+   </td>
<td> 正值前有加号</td>
</tr>
<tr>
<td>空格</td>
<td> 只用于转换有符号值的代码。当值非负时，这个标志把一个空格添加到它开始的位置。注意这个标志和+互斥。</td>
</tr>
</tbody>
</table>


<p>代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; print '%0.5f' % 1.1
</span><span class='line'>1.10000
</span><span class='line'>&gt;&gt;&gt; print '%0.5d' % 1.1
</span><span class='line'>00001</span></code></pre></td></tr></table></div></figure>


<h3>fldwidth 宽度</h3>

<p>字段宽度是一个十进制整数，用于指定将要出现在结果中得最小字符数。如果字符数少于字段宽度，就对它进行填充以增加长度。flags字段决定填充
使用空白还是零。</p>

<h3>precision 精度</h3>

<p>精度字段以一个句点开头，后面跟着一个可选的十进制整数，如果没有给出，则精度为0.</p>

<ul>
<li>如果作用的是d、i、u、o、x和X类型转换符，精度字段指定将出现在结果中的最小数子个数。如果转换后的值的位数小于宽度，就在它签名插入零。如果值为零，精度也为零，则不输出数字。</li>
<li>如果作用于e，E和f类型转换符，精度决定将要出现在小数点后的数字位数</li>
<li>如果作用于s，精度指定将被转换的最多字符数。</li>
</ul>

]]></content>
  </entry>
  
</feed>
