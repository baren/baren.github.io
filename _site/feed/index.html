<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>巴人</title>
    <link href="http://baren.github.io/feed/" rel="self" />
    <link href="http://baren.github.io" />
    <lastBuildDate>2014-01-18T19:44:54+08:00</lastBuildDate>
    <webMaster>barenaq@gmail.com</webMaster>
    
    <item>
      <title>linux文件io进一步描述</title>
      <link href="http://baren.github.io/FILEIO-FURTHER-DETAILS/"/>
      <pubDate>2013-12-30T13:15:00Z</pubDate>
      <author>巴人</author>
      <guid>http://baren.github.io/FILEIO-FURTHER-DETAILS</guid>
      <content:encoded><![CDATA[<h2>原子性和条件竞争</h2>

<p>所有系统调用都是原子执行的。原子执行避免了条件竞争。所谓条件竞争，指的是两个进程，在共享资源上操作，产生的结果依赖于两个进程的执行顺序。</p>

<h3>排他性创建文件</h3>

<p>在调用open系统调用函数时，如果文件存在，则如果指定O_EXCL和O_CREAT会导致open失败。这就为进程提供了一种确保是他创建了文件的方式。
如果没有这个选项，则一般是先检查文件存在不存在，如果不存在，就创建一个文件。由于是check-if-absent方式，产生条件竞争。</p>

<h3>追加文件内容</h3>

<p>如果多个进程往一个文件中追加数据（比如一个全局日志文件），通常的做法是lseek到文件末尾，然后write，比如：</p>

<div class="highlight"><pre><code class="c">    <span class="k">if</span> <span class="p">(</span><span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;lseek&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> 
        <span class="n">fatal</span><span class="p">(</span><span class="s">&quot;Partial/failed write&quot;</span><span class="p">);</span>
</code></pre></div>


<p>这也产生了条件竞争。</p>

<p>解决这个问题的方法，就是使用open函数的O_APPEND设置。</p>

<h2>fcntl()文件控制操作</h2>

<p>函数定义：</p>

<div class="highlight"><pre><code class="c">    <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">fcntl</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
    <span class="kt">int</span> <span class="n">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div>


<h3>获得打开文件的状态标记（flag）</h3>

<p>open函数的定义是：</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
</code></pre></div>


<p>使用fcntl系统调用，可以获取文件或者修改文件的状态标记（标记的值是在open时由参数设置的）。</p>

<p>比如下面代码：</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">accessMode</span><span class="p">;</span>
<span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span> <span class="cm">/* Third argument is not required */</span> 
<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>
</code></pre></div>


<p>获得flags后，可以检查是否具有某种标记：</p>

<div class="highlight"><pre><code class="c"><span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_SYNC</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;writes are synchronized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</code></pre></div>


<p>但是，对于O_RDONLY (0), O_WRONLY (1), and O_RDWR (2)，使用上面这种方式判断就不行（O_RDONLY的值是0，怎么&amp;，都是0；写功能，两个值wronly和rdwr都具有写功能，读功能，rdonly和rdwr都具有读功能）。</p>

<p>为了判断，可以使用O_ACCMODE(3),比如下面代码：</p>

<div class="highlight"><pre><code class="c"><span class="n">accessMode</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">accessMode</span> <span class="o">==</span> <span class="n">O_WRONLY</span> <span class="o">||</span> <span class="n">accessMode</span> <span class="o">==</span> <span class="n">O_RDWR</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;file is writable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</code></pre></div>


<p>还可以使用F_SETFL来修改已打开文件的标记。可修改的标记为：O_APPEND, O_NONBLOCK, O_NOATIME, O_ASYNC, and O_DIRECT，试图修改其它会被忽略。</p>

<p>设置标记的办法是先获取标记，再设置，比如：</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>
<span class="n">flags</span> <span class="o">|=</span> <span class="n">O_APPEND</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errExit</span><span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>
</code></pre></div>


<h2>文件描述符和打开文件的关系</h2>

<p>内核维护的三个数据结构：</p>

<ul>
<li>一个进程一个文件描述符表(<a href="http://en.wikipedia.org/wiki/Array_data_structure">Array data type</a>)</li>
<li>系统级别的打开的文件描述符的表</li>
<li>文件系统的i-node表</li>
</ul>


<p>对于每一个进程，内核都维护了这个进程打开的文件描述符表。每一个表项包含的信息是：</p>

<ul>
<li>控制操作文件描述符的标记集。其实就是一个标记close-on-exec</li>
<li>一个指向打开的文件描述符（存储在open file table中的记录，也就是系统级别的打开的文件描述符的表项）的引用。</li>
</ul>


<p>内核维护了一个系统级别的所有的打开文件描述符（通常叫做<em>open file table</em>，其表项一般被称做open file handles）的表。
一个打开文件描述符存储了关于打开文件的所有信息，包括：</p>

<ul>
<li>当前文件的偏移（read()和write()会更新这个值，或者通过lseek()指定）</li>
<li>当打开文件指定的状态标记（比如open()函数的flags参数）</li>
<li>文件访问模式（read-only，write-only或者read-write）</li>
<li>一个指向这个文件的i-node对象的引用</li>
</ul>


<blockquote><p> #include &lt;sys/stat.h></p>

<p> #include &lt;fcntl.h></p>

<p> int open(const char <em>pathname, int flags, ... /</em> mode_t mode */);</p>

<table>
<thead>
<tr>
<th>Access mode </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY    </td>
<td style="text-align:center;"> Open the file for reading only</td>
</tr>
<tr>
<td>O_WRONLY    </td>
<td style="text-align:center;"> Open the file for writing only</td>
</tr>
<tr>
<td>O_RDWR      </td>
<td style="text-align:center;"> Open the file for both reading and writing</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>File creation flags </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_CLOEXEC    </td>
<td style="text-align:center;"> Set the close-on-exec flag (since Linux 2.6.23)</td>
</tr>
<tr>
<td>O_CREAT      </td>
<td style="text-align:center;"> Create file if it doesn’t already exist </td>
</tr>
<tr>
<td>O_DIRECT     </td>
<td style="text-align:center;"> File I/O bypasses buffer cache</td>
</tr>
<tr>
<td>O_DIRECTORY  </td>
<td style="text-align:center;"> Fail if pathname is not a directory </td>
</tr>
<tr>
<td>O_EXCL       </td>
<td style="text-align:center;"> With O_CREAT: create file exclusively </td>
</tr>
<tr>
<td>O_LARGEFILE  </td>
<td style="text-align:center;"> Used on 32-bit systems to open large files </td>
</tr>
<tr>
<td>O_NOATIME    </td>
<td style="text-align:center;"> Don’t update file last access time on read() (since Linux 2.6.8) </td>
</tr>
<tr>
<td>O_NOCTTY     </td>
<td style="text-align:center;"> Don’t let pathname become the controlling terminal </td>
</tr>
<tr>
<td>O_NOFOLLOW   </td>
<td style="text-align:center;"> Don’t dereference symbolic links </td>
</tr>
<tr>
<td>O_TRUNC      </td>
<td style="text-align:center;"> Truncate existing file to zero length </td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th> file status flags </th>
<th style="text-align:center;"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_APPEND    </td>
<td style="text-align:center;"> Writes are always appended to end of file</td>
</tr>
<tr>
<td>O_ASYNC    </td>
<td style="text-align:center;"> Generate a signal when I/O is possible</td>
</tr>
<tr>
<td>O_DSYNC     </td>
<td style="text-align:center;"> Provide synchronized I/O data integrity (since Linux 2.6.33)</td>
</tr>
<tr>
<td>O_NONBLOCK      </td>
<td style="text-align:center;"> Open in nonblocking mode</td>
</tr>
<tr>
<td>O_SYNC      </td>
<td style="text-align:center;"> Make file writes synchronous</td>
</tr>
</tbody>
</table>
</blockquote>

<p>每一个文件的i-node包含的信息有：</p>

<ul>
<li>文件类型（正常文件、socket或者FIFO）和文件权限</li>
<li>一个指向加在这个文件上的锁列表的指针</li>
<li>各种文件属性，包括文件大小，和不同操作相关的时间。</li>
</ul>


<blockquote><p>i-node在磁盘上的描述和在内存中的描述不一样。如果在磁盘上，则记录了一个文件的持久化属性。比如类型、大小和权限等。
i-node在内存的描述，记录了打开的文件描述符指向这个i-node节点的数目、这个i-node所在的磁盘的主要（major）和次要（minor）的ID，还记录的一些短暂的属性，比如加在文件上的锁等。</p></blockquote>

<p>如图：
<img src="/assets/Figure5-2.png" title="Relationship between file descriptors, open file descriptions, and i-nodes" alt="alt text" /></p>

<p>根据上面描述，得出下面几个隐含的意思来：</p>

<ul>
<li>两个不同的文件描述符引用同一个文件，则他们共享同一个文件偏移量。</li>
<li>同样规则也适用于使用fcntl()函数获取或者修改文件状态标记（上面表格中的file status flags,比如O_APPEND, O_NONBLOCK, O_ASYNC）</li>
<li>文件描述符标记（close-on-exec）则是私有的，修改它不会影响到其他的。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>FiFe I/O 通用的I/O模型</title>
      <link href="http://baren.github.io/THE-UNIVERSAL-IO-MODEL/"/>
      <pubDate>2013-12-23T02:36:00+08:00</pubDate>
      <author>巴人</author>
      <guid>http://baren.github.io/THE-UNIVERSAL-IO-MODEL</guid>
      <content:encoded><![CDATA[<h2>总述</h2>

<p>所有完成IO的系统调用，都是使用文件描述符（file descriptor）来引用一个文件。文件描述符用来引用打开的所有类型文件，包括管道、socket、设备等。每个进程都有自己的文件描述符集。</p>

<p>根据惯例，大多数的应用程序都希望打开三个标准的文件描述符（标准输入、输出和错误）。这三个文集描述符，一般是由在程序启动之前启动的shell程序打开的。</p>

<table>
<thead>
<tr>
<th> 文件描述符        </th>
<th style="text-align:center;"> POSIX 名称（在unistd.h头文件中定义）           </th>
<th style="text-align:right;"> 描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td> 0      </td>
<td style="text-align:center;"> STDIN_FILENO </td>
<td style="text-align:right;"> 标准输入 </td>
</tr>
<tr>
<td> 1     </td>
<td style="text-align:center;"> STDOUT_FILENO      </td>
<td style="text-align:right;">   标准输出 </td>
</tr>
<tr>
<td> 2 </td>
<td style="text-align:center;"> STDERR_FILENO     </td>
<td style="text-align:right;">    标准错误 </td>
</tr>
</tbody>
</table>


<p>在程序中，既可以使用数字，也可以使用posix的名称来指向这几个文件描述符。</p>

<p>下面是四个关键的完成IO的系统调用：
* fd = open(pathname, flags, mode) 。通过制定flags参数，open函数既可以打开文件，也可以创建文件。如果创建文件，mode参数用来指定创建文件的访问权限。如果不是用来创建文件，可以忽略mode这个文件。SUSv3规定，如果open成功，他保证使用这个进程的最小的没有使用的文件描述符。
* numread = read(fd, buffer, count)。读取fd引用的文件，最多读取count个字节，返回的是实际读取的字节数，如果到了文件末尾，返回0。
* numwritten = write(fd, buffer, count)。从buffer中，写入count个字节数据到fd所指向的文件中。返回的是实际写入的字节数，有可能小于count。
* status = close(fd) 。释放文件描述符，以及相关的内核资源</p>

<h2>I/O通用性</h2>

<p>所谓通用性，是指这四个函数可以作用于所有的类型文件，来完成IO操作。这些文件包括管道、设备、socket等。</p>

<p>如果需要使用特定类型文件特有的功能，可以使用ioctl系统调用，它提供了所有通用功能以外的特定功能。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>linux最大文件描述符设置</title>
      <link href="http://baren.github.io/linux-open-max-fd-num/"/>
      <pubDate>2013-12-17T02:36:00+08:00</pubDate>
      <author>巴人</author>
      <guid>http://baren.github.io/linux-open-max-fd-num</guid>
      <content:encoded><![CDATA[<p>在linux中，所有都是文件，也就是说一个连接也是一个文件。每打开一个文件，内核会分配一个文件描述符，因此一个进程可打开的最大文件描述符决定了可支持的最大连接数。这是一个重要的参数。</p>

<p>linux有两个限制：</p>

<pre><code>1、系统级限制。限制了整个系统可打开的最大文件描述符

2、每个进程的限制。一个应用可打开的最大文件描述符
</code></pre>

<p>对于系统限制，可以通过这个查看：</p>

<div class="highlight"><pre><code class="bash"><span class="nv">$ </span>cat /proc/sys/fs/file-max
131072
<span class="nv">$ </span>cat /proc/sys/fs/file-nr 
510     0       131072
</code></pre></div>


<p>其中，file-nr返回结果意思是：
    510，已打开的文件句柄
    0，已分配但是没有用的文件句柄
    131072，系统支持最大的文件句柄数</p>

<p>其中，系统支持的最大的文件句柄数还可以用</p>

<div class="highlight"><pre><code class="bash">cat /proc/sys/fs/file-max（或者sysctl fs.file-max）
</code></pre></div>


<p>来查看。</p>

<p>修改系统限制，可以这样修改：</p>

<p>修改文件/etc/sysctl.conf 中的</p>

<div class="highlight"><pre><code class="bash">fs.file-max <span class="o">=</span> 100000
</code></pre></div>


<p>一行，保存后，让用户重新登录一下，即可永久生效；或者执行sysctl -p命令。</p>

<p>对于用户级限制，可以通过下面命令查看：</p>

<div class="highlight"><pre><code class="bash"><span class="nv">$ </span><span class="nb">ulimit</span> -Hn
65536

<span class="nv">$ </span><span class="nb">ulimit</span> -Sn
20240
</code></pre></div>


<p>其中，
-H是硬限制. -S是软限制。区别是软限制，任何进程都可以修改，但是硬限制，只允许root权限用户修改。</p>

<p>如果要修改默认的用户级限制，可以编辑文件/etc/security/limits.conf
比如：</p>

<div class="highlight"><pre><code class="bash"> <span class="c"># End of file</span>
    * soft nproc 20240
    * hard nproc 16384
    * soft nofile 20240
    * hard nofile 65536
</code></pre></div>


<p>解释如下：
第一列的意思是设置针对哪些用户生效，* 表示针对所有用户，但是，它不包含root，因此，如果要对root用户有效，需要增加root用户，也就是后面两行。</p>

<p>第二列，要么是soft，要么是hard，hard只允许root修改，soft允许普通用户修改，最大是hard设定的值。</p>

<p>第三列，包含了要被限制的资源的类型。nofile表示打开的文件数，nproc表示进程数。</p>

<p>第四列，表示设置的值。</p>

<p>临时设置：</p>

<p>如果不想永久设置，还可以使用下面命令临时设置：</p>

<div class="highlight"><pre><code class="bash"><span class="nb">ulimit</span> -n 65536
</code></pre></div>


<p>这样，只影响当前登录用户，下次重新登录后失效</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
